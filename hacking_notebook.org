#+TITLE: Hacking Notebook
* The programming language C
:PROPERTIES:
:NOTER_DOCUMENT: ../Documents/CS/C/Brian W. Kernighan, Dennis M. Ritchie-The ANSI C Programming Language-Prentice Hall (1988).pdf
:END:
** Getting Started
:PROPERTIES:
:NOTER_PAGE: 9
:END:
We can start the typical hello world program by
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n");
}
#+END_SRC

#+RESULTS:
| hello | world |
*** Exercise 1-1
:PROPERTIES:
:NOTER_PAGE: 11
:END:
- Without semicolon:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n")
        }
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:10:5: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
    main(){
    ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:11:33: error: expected ';' after expression
        printf("hello, world\n")
                                ^
                                ;
1 warning and 1 error generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-2QhFQd: Permission denied
    #+END_SRC

  And replacing the escape sequence, which representing /newline/, with the
  what that representing:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world
");
}
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
main(){
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: warning: missing terminating '"' character [-Winvalid-pp-token]
    printf("hello, world
           ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: error: expected expression
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:12:1: warning: missing terminating '"' character [-Winvalid-pp-token]
");
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:14:1: error: expected '}'
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:7: note: to match this '{'
main(){
      ^
3 warnings and 2 errors generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-qJOtkX: Permission denied
  #+END_SRC

  Now it got quite cryptic -- compiler got spit outs all the errors not the one
  that causes all subsequent errors.
*** Exercise 1-2
:PROPERTIES:
:NOTER_PAGE: 11
:END:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("\c\b\d\f\e");
}
#+END_SRC

#+RESULTS:
: cd

If the character is not on the mentioned list, it just ignore the backslash --
just return the following character.
** Variables and Arithmetic Expressions
:PROPERTIES:
:NOTER_PAGE: 11
:END:
*** Output formatting function -- =printf=
:PROPERTIES:
:NOTER_PAGE: 14
:END:
#+BEGIN_SRC C
printf("%d\t%d\n", fahr, celsius);
#+END_SRC
output the first argument -- formatted string -- substituted with second and
third arguemnt in the place of each =%d=, respectively.

I guess it use =%= as expression to be substituted since this character seems
like describing the situation where one element being replaced by another.
*** Exercise 1-3
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 300;                /* upper limit */
    step = 20;                  /* step size */

    fahr = lower;
    printf("%3s %6s\n", "Fahrenheit", "Celsius");
    while (fahr <= upper) {
        celsius = (5.0/9.0) * (fahr - 32.0);
        printf("%3.0f %6.1f\n", fahr, celsius);
        fahr = fahr + step;
    }
}
#+END_SRC

#+RESULTS:
| Fahrenheit | Celsius |
|          0 |   -17.8 |
|         20 |    -6.7 |
|         40 |     4.4 |
|         60 |    15.6 |
|         80 |    26.7 |
|        100 |    37.8 |
|        120 |    48.9 |
|        140 |    60.0 |
|        160 |    71.1 |
|        180 |    82.2 |
|        200 |    93.3 |
|        220 |   104.4 |
|        240 |   115.6 |
|        260 |   126.7 |
|        280 |   137.8 |
|        300 |   148.9 |
*** Exercise 1-4
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 120;                /* upper limit */
    step = 10;                  /* step size */

    celsius = lower;
    printf("%3s %6s\n", "Celsius", "Fahrenheit");
    while (celsius <= upper) {
        fahr = (9.0/5.0) * celsius + 32.0;
        printf("%3.0f %6.1f\n", celsius, fahr);
        celsius = celsius + step;
    }
}
#+END_SRC

#+RESULTS:
| Celsius | Fahrenheit |
|       0 |       32.0 |
|      10 |       50.0 |
|      20 |       68.0 |
|      30 |       86.0 |
|      40 |      104.0 |
|      50 |      122.0 |
|      60 |      140.0 |
|      70 |      158.0 |
|      80 |      176.0 |
|      90 |      194.0 |
|     100 |      212.0 |
|     110 |      230.0 |
|     120 |      248.0 |
** The for statement
:PROPERTIES:
:NOTER_PAGE: 16
:END:
*** Exercise 1-5
:PROPERTIES:
:NOTER_PAGE: 17
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 300, 280, ..., 0; floating-point version*/

main(){
    int fahr;
    for (fahr = 300; fahr >= 0; fahr = fahr - 20) {
        printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32.0));
    }
}

#+END_SRC

#+RESULTS:
| 300 | 148.9 |
| 280 | 137.8 |
| 260 | 126.7 |
| 240 | 115.6 |
| 220 | 104.4 |
| 200 |  93.3 |
| 180 |  82.2 |
| 160 |  71.1 |
| 140 |  60.0 |
| 120 |  48.9 |
| 100 |  37.8 |
|  80 |  26.7 |
|  60 |  15.6 |
|  40 |   4.4 |
|  20 |  -6.7 |
|   0 | -17.8 |
** Symbolic Constants
:PROPERTIES:
:NOTER_PAGE: 17
:END:
I think symbolic constants, defined by =#define=, would be open-coded when it compiled.
#+BEGIN_SRC C :includes <stdio.h> :exports both :defines LOWER 0 UPPER 300 STEP 20
int fahr;
for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
    printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32));
#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
** Character Input and Output
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C :includes <stdio.h>
int c;
c = 50;
printf("\ninteger number %d got translated with putchar into %c\n", c, putchar(c));
#+END_SRC

#+RESULTS:
|       2 |        |    |     |            |      |         |      |   |
| integer | number | 50 | got | translated | with | putchar | into | 2 |
*** File Copying
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C
/* copy input to output; 1st version */
int c;

c = getchar();
while (c != EOF) {
    putchar(c);
    c = getchar();
}
#+END_SRC

More concisely, experienced C programmer would write above program as
#+BEGIN_SRC C
/* copy input to output; 2nd version */
int c;

while ((c = getchar ()) != EOF)
    putchar(c);
#+END_SRC

This exploited the fact that the assignment statement -- ~=~ -- has the value
evaluating the right hand side as its return value. Here also we should note
that =EOF= is just one of pre =define= d variable macro that would be replaced
any integer number that would not appear in the real character code.

Using this /trick/, we should be alerted that now we should be considerate on
the /precedence/ issue -- ~!=~ has higher precedence than ~=~.
**** Exercise 1-6
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
getchar() != EOF;
#+END_SRC

#+RESULTS:
#+BEGIN_SRC sh
~/org ÃŽÂ» ./C_codes/a.out
5
The input character 5 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character
 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character Ã¿ return 0 via "getchar() != EOF"
#+END_SRC

From this exercise, we know that character ~^D~ represent =EOF= (also apparently
0 means the test is false and 1 for the true).
**** Exercise 1-7
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
putchar(EOF);
#+END_SRC

#+RESULTS:
: Ã¿

What we discovered in preceding exercise got verified explicitly.
*** Character Counting
:PROPERTIES:
:NOTER_PAGE: 20
:END:
New operator, which is the mascot expression in C, =++=:
#+BEGIN_SRC C
++nc;
#+END_SRC

Although we have shown in the above example /prefix/ operator =++=, there is
also /postfix/ operator =++=; those have different values in expressions.

As introduced in preceding section, the =for= control structure is just
syntactic sugar for =while=, we could express the word counting program as
#+BEGIN_SRC C :includes <stdio.h> :exports both
double nc;

for (nc = 0; getchar () != EOF; ++nc);
printf("%.0f\n", nc);
#+END_SRC

#+RESULTS:
: 0
**** Exercise 1-8
:PROPERTIES:
:NOTER_PAGE: 22
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
long ns, nt, nl;
int c;

ns = 0;
nt = 0;
nl = 0;

while ((c = getchar ()) != EOF) {
    if (c == ' ')
        ++ns;
    if (c == '\t')
        ++nt;
    if (c == '\n')
        ++nl;
}
printf("The number of blanks, tabs, lines are %ld, %ld, %ld, respectively\n", ns, nt, nl);
#+END_SRC

#+RESULTS:
| The number of blanks | tabs | lines are 0 | 0 | 0 | respectively |
**** Exercise 1-9
:PROPERTIES:
:NOTER_PAGE: 22
:END:
Here is the algorithm that solves our task:
1. If the input character stream is not =EOF=,
2. if taken character stream is blank, print single blank and then
3. consume all the successive blanks;
4. else, print that input stream and then update character stream.
5. go to *1.*

Since we haven't yet learned the =else= control structure -- only =if=-then
structure -- we need to mimic the =if-else= structure:

#+BEGIN_SRC C :exports both
int c;
int flag;
c = getchar();
while (c != EOF) {
    flag = 0;               /* mimic if else control structure */
    if (c == ' ') {
        putchar(c);         /* print single blank */
        flag = 1;           /* signal that the entry character was blank */
        while ((c = getchar()) == ' ') /* comsume the successive blanks */
            ;
    }
    if (flag == 0) {        /* if the entry point was non-blank character */
        putchar(c);
        c = getchar();      /* update the c to be consist with comsumption of blanks */
    }
}
#+END_SRC

Then it works as expected:
#+BEGIN_SRC sh
~/org/C_codes [master] Î» ./a.out
asdfsd   sdf   d
asdfsd sdf d
Hi Test thsi    tis   d
Hi Test thsi tis d

#+END_SRC
**** Exercise 1-10
:PROPERTIES:
:NOTER_PAGE: 22
:END:
This program is analogous that of [[*Exercise 1-8][Exercise 1-8]], mimicking the =else= structure:
#+BEGIN_SRC C :includes <stdio.h> :exports both

int c, flag;


while ((c = getchar ()) != EOF) {
    flag = 1;
    if (c == '\b') {
        flag = 0;
        printf("\\b");
    }
    if (c == '\t') {
        flag = 0;
        printf("\\t");
    }
    if (c == '\n') {
        flag = 0;
        printf("\\n");
    }
    if (c == '\\') {
        flag = 0;
        printf("\\\\");
    }
    if (flag)
        putchar(c);
}
#+END_SRC

#+BEGIN_SRC sh
~/org/C_codes [master] Î» echo "tab	\	" | ./a.out
tab\t\\\t\n
#+END_SRC
*** Word Counting
:PROPERTIES:
:NOTER_PAGE: 22
:END:

#+BEGIN_SRC C :tangle C_codes/current.c :includes <stdio.h> :defines IN 1 OUT 0
int c, nl, nw, nc, state;

state = OUT;
nl = nw = nc = 0;
while ((c = getchar()) != EOF) {
    ++nc;
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
}
printf("%d %d %d\n", nl, nw, nc);
#+END_SRC

#+RESULTS:
: 0 0 0
**** Exercise 1-11
:PROPERTIES:
:NOTER_PAGE: 23
:END:

In Org mode, we can use session whenever the language supports ~REPL~; but since
C is the language should involve compiler to produce program, we can not use
them.

So we have to fall back to alternative approach: Use tangle feature.

Then let's test this code:
#+BEGIN_SRC sh
cd C_codes
cc current.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
echo "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
: 1 5 28

We've setup the environment where we integrated the Org babel with the testing C code.

To test this kind of program, we can take two different approaches:
1. Path complete test;
2. black box test -- test the specifications.


The former one tests all the branches the code implemented; in above case, it
has 2 branches in it: First only has consequent clause, second has also
alternative in addition to consequence:
#+BEGIN_SRC C
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
#+END_SRC

First, let's try the path complete test:
#+BEGIN_SRC sh :exports both
# Test first branch
echo | ./C_codes/current        # echo append '\n' by default
printf | ./C_codes/current      # printf do not append '\n'
# Test second branch
# just pass through first path of second branch
printf "\n\n\n   \t\t\t" | ./C_codes/current
# pass though the second path also
printf "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
| 1 | 0 |  1 |
| 0 | 0 |  0 |
| 3 | 0 |  9 |
| 0 | 5 | 27 |

Then let's do the latter one; it tests all the boundary cases:
#+BEGIN_SRC sh :exports both
# 0 0 0
printf | ./C_codes/current
# 1 0 1
echo | ./C_codes/current
# 0 0 1
printf " " | ./C_codes/current  # space
printf "\t" | ./C_codes/current  # tab
# 0 1 1
printf "c" | ./C_codes/current
# Compound cases
printf "This is \n compound case.\t" | ./C_codes/current
#+END_SRC

#+RESULTS:
| 0 | 0 |  0 |
| 1 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 1 |  1 |
| 1 | 4 | 25 |
**** Exercise 1-12
:PROPERTIES:
:NOTER_PAGE: 23
:END:
All we need to do is
- just copying the input if it were transition of state from
  =IN= to =IN= or =OUT= to =IN=;
- ignore if it were from =OUT= to =OUT=;
- replace it as =\n= if it were from =IN= to =OUT=;


#+BEGIN_SRC C :tangle C_codes/ex1_12.c :includes <stdio.h> :defines IN 1 OUT 0
int c, state;

state = OUT;
while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == OUT)
            ;                   /* ignore the input character */
        else {
            state = OUT;
            putchar('\n');
        }
    }
    else {
        state = IN;
        putchar(c);
    }
}
#+END_SRC

Then test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_12.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
printf "Test words\n\n\n\t\t\t   One Two     Three" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Test  |
| words |
| One   |
| Two   |
| Three |
** Arrays
:PROPERTIES:
:NOTER_PAGE: 25
:END:
**** Exercise 1-13
:PROPERTIES:
:NOTER_PAGE: 25
:END:
The most canonical way to implement this program would be
1. Assume that we have data structure, table that contains entries which
   consist of key and value;
2. modifying the word counting program, which we implemented in preceding
   section, implement program that counts the length of first word from the
   input stream;
3. for each word in the input stream, insert newly calculated word length into
   the predefined table that contains word length - frequency entries;
4. print the entries in that table using histogram.


But, only with what we've learned so far, we can not implement the assumed data
structure, so we need to approach this exercise in more naive manner.

We are going to use array as table like structure but that table possibly be
very scarce -- inefficient; moreover, as we are not allowed to allocates the
input stream into some temporary file or on memory to use more than once, we can
not cope with extreme cases where maximum word length is enormous.


Here is the resulting code, which approximately implement above algorithm naively:
#+BEGIN_SRC C :tangle C_codes/ex1_13.c :includes <stdio.h> :defines IN 1 OUT 0 MAX_LENG 100

int c, i, j, wl, state;
int nwords[MAX_LENG];

state = OUT;
wl = 0;
for (i = 0; i < MAX_LENG; ++i)
    nwords[i] = 0;

while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == IN)        /* IN -> OUT transition */
            ++nwords[wl];

        state = OUT;
    }
    else {
        if (state == OUT)       /* OUT -> IN transition */
            wl = 0;             /* initialize word length counter */
        state = IN;
        ++wl;
    }
}

if (state == IN)                /* EOF is also delimiter */
    ++nwords[wl];

printf("%s\t%s\n", "Word length", "Frequency");
for (i = 0; i < MAX_LENG; ++i) {
    if (nwords[i] != 0) {       /* print only non zero frequency entries */
        printf("%d\t", i);
        for (j = 0; j < nwords[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_13.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_13.c | ./C_codes/current
# printf "test\nMy-test test" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Word length | Frequency                                          |
|           1 | **********************************                 |
|           2 | ************************************************** |
|           3 | ******************                                 |
|           4 | *************                                      |
|           5 | **********                                         |
|           6 | *******                                            |
|           7 | *****                                              |
|           8 | ***                                                |
|           9 | *********                                          |
|          10 | ******                                             |
|          13 | ****                                               |
|          14 | **                                                 |
|          17 | *                                                  |
|          18 | *                                                  |
**** Exercise 1-14
:PROPERTIES:
:NOTER_PAGE: 25
:END:
This is an analogous program of preceding exercise. The maximum length becomes
='z' - 'a'= and the others are obvious relations:

#+BEGIN_SRC C :tangle C_codes/ex1_14.c :includes <stdio.h>
int c, i, j;
int length = 'z' - 'a' + 1;
int nchars[length];

for (i = 0; i < length; ++i)
    nchars[i] = 0;

while ((c = getchar()) != EOF) {
    if ('a' <= c && c <= 'z')
        ++nchars[c - 'a'];
}

printf("%s\t%s\n", "Character", "Frequency");
for (i = 0; i < length; ++i) {
    if (nchars[i] != 0) {       /* print only non zero frequency entries */
        printf("%c\t", i + 'a');
        for (j = 0; j < nchars[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_14.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_14.c | ./C_codes/current
# printf "zzzz AAA aaaa" | ./C_codes/current # only count lowercase character
#+END_SRC

#+RESULTS:
| Character | Frequency                      |
| a         | ****************               |
| c         | ********************           |
| d         | **                             |
| e         | *********************          |
| f         | *********                      |
| g         | ******                         |
| h         | ******************             |
| i         | ****************************   |
| j         | ****                           |
| l         | *******                        |
| m         | **                             |
| n         | ****************************** |
| o         | ********                       |
| p         | *******                        |
| q         | ***                            |
| r         | ***************************    |
| s         | ***********                    |
| t         | ***********************        |
| u         | *******                        |
| w         | **                             |
| y         | ****                           |
| z         | ***                            |
** Functions
:PROPERTIES:
:NOTER_PAGE: 26
:END:
Let's test recursive definition of =power=:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>
int power(int m, int n);

main()
{
    int i;

    printf("power(2,5) is %d", power(2, 5));
}

/* recursive definition of exponentiation */
int power(int base, int n)
{
    if (n == 0)
        return 1;
    else
        return base * power(base, n - 1);
}
#+END_SRC

#+RESULTS:
| power(2 | 5) is 32 |

Yes it works as expected.
**** Exercise 1-15
#+BEGIN_SRC C :main no :tangle C_codes/ex1_15.c :exports both
#include <stdio.h>

#define LOWER 0
#define UPPER 300
#define STEP 20

float fahr2cels(float fahr);
/* test temperature conversion function */
main () {
    float fahr;
    for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf("%3.0f %6.1f\n", fahr, fahr2cels(fahr));
    return 0;
}
/* temperature conversion function from fahrenheit to celsius*/
float fahr2cels(float fahr) {
    return (5.0/9.0) * (fahr - 32.0);
}

#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
** Call by value
** Character array
**** Exercise 1-16
:PROPERTIES:
:NOTER_PAGE: 31
:END:
Since C is strictly typed language, if the specific task does not require, we
usually do not code in dynamic manner -- recursive function definition and so on.

However in this exercise, we can not cope with this task without using
dynamically evolving program since we are dealing with unknown input stream --
it is inheritly dynamic one.

To cope with this task, we will try to use the recursive function definition to
accommodate sufficient memory for given input stream.

We are going to define =printOverflowed= that print longest input line. It takes
=maxline=, =impending[]= (if any):
#+BEGIN_SRC C :main no :tangle C_codes/ex1_16.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    int len;
    int max;
    int overflow = 0;
    char line[INITIALMAX];
    char longest[INITIALMAX];

    max = 0;
    while ((len = getlineFrom(0, line, INITIALMAX)) > 0)
        if (isOverflowed(line, len, INITIALMAX)) {
            overflow = 1;
            printOverflowed(INITIALMAX, line);
        }
        else if (len > max) {
            max = len;
            copy(longest, line);
        }
    if (overflow != 1 && max > 0)
        printf("%s", longest);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[])
{
    int len, max;
    int overflow = 0;
    int lim = 2 * oldLim;
    char line[lim];
    char longest[lim];

    copy(line, impending);
    max = len = getlineFrom(oldLim - 1, line, lim);
    if (isOverflowed(line, len, lim))
        printOverflowed(lim, line);
    else {
        copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (overflow != 1)
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

We've handled the overflowed condition explicitly using the =printOverflowed=
function. It is almost same as the entry point function, =main= except it
handles allocates the current line and longest line with extended limit array indice.

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
**** Exercise 1-17
:PROPERTIES:
:NOTER_PAGE: 31
:END:
We can achieve what we want by modifying the preceding example. That is,
whenever we encounters input line that is longer than threadhold length.

Before doing modification of code of [[*Exercise 1-16][Exercise 1-16]], let us first refactor that
code to encompass the entry point case into the =printOverflowed= so that we can
easily change the behavior of that program by making them modular.

We used following experiment to refactor our code:

#+NAME: Test logical not
#+BEGIN_SRC C :exports both
printf("%d", !0);
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC C :main no :tangle C_codes/ex1_16_refactored.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len, max;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];
    char longest[lim];

    if (isentry) {
        max = 0;
    }
    else {
        copy(line, impending);
        max = len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (!overflow && (!isentry || (isentry && max > 0)))
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Our =main= routine got simplified just calling the subroutines appropriately.
Let's test this refactored code:


Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16_refactored.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |

It works as expected.

Now we turn to the our original task; it actually simpler than preceding
exercise. All we need to do is just print given line if it is longer than the
threadhold length.

#+BEGIN_SRC C :main no :tangle C_codes/ex1_17.c
#include <stdio.h>
#define INITIALMAX 10
#define TREADHOLD 8

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
void copy(char to[], char from[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            if (len >= TREADHOLD)
                printf("%s", line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len >= TREADHOLD)
                printf("%s", line);

    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_17.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "threadhold\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| threadhold |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
| like       | this |      |        |      |        |

Seems like works well.

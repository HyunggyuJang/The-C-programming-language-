#+TITLE: Hacking Notebook
* The programming language C
:PROPERTIES:
:NOTER_DOCUMENT: ../Documents/CS/C/Brian W. Kernighan, Dennis M. Ritchie-The ANSI C Programming Language-Prentice Hall (1988).pdf
:END:
** Chapter 1 - A Tutorial Introduction
:PROPERTIES:
:NOTER_PAGE: 9
:END:

*** Getting Started
:PROPERTIES:
:NOTER_PAGE: 9
:END:
We can start the typical hello world program by
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n");
}
#+END_SRC

#+RESULTS:
| hello | world |
**** Exercise 1-1
:PROPERTIES:
:NOTER_PAGE: 11
:END:
- Without semicolon:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n")
        }
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:10:5: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
    main(){
    ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:11:33: error: expected ';' after expression
        printf("hello, world\n")
                                ^
                                ;
1 warning and 1 error generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-2QhFQd: Permission denied
    #+END_SRC

  And replacing the escape sequence, which representing /newline/, with the
  what that representing:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world
");
}
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
main(){
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: warning: missing terminating '"' character [-Winvalid-pp-token]
    printf("hello, world
           ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: error: expected expression
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:12:1: warning: missing terminating '"' character [-Winvalid-pp-token]
");
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:14:1: error: expected '}'
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:7: note: to match this '{'
main(){
      ^
3 warnings and 2 errors generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-qJOtkX: Permission denied
  #+END_SRC

  Now it got quite cryptic -- compiler got spit outs all the errors not the one
  that causes all subsequent errors.
**** Exercise 1-2
:PROPERTIES:
:NOTER_PAGE: 11
:END:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("\c\b\d\f\e");
}
#+END_SRC

#+RESULTS:
: cd

If the character is not on the mentioned list, it just ignore the backslash --
just return the following character.
*** Variables and Arithmetic Expressions
:PROPERTIES:
:NOTER_PAGE: 11
:END:
**** Output formatting function -- =printf=
:PROPERTIES:
:NOTER_PAGE: 14
:END:
#+BEGIN_SRC C
printf("%d\t%d\n", fahr, celsius);
#+END_SRC
output the first argument -- formatted string -- substituted with second and
third arguemnt in the place of each =%d=, respectively.

I guess it use =%= as expression to be substituted since this character seems
like describing the situation where one element being replaced by another.
**** Exercise 1-3
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 300;                /* upper limit */
    step = 20;                  /* step size */

    fahr = lower;
    printf("%3s %6s\n", "Fahrenheit", "Celsius");
    while (fahr <= upper) {
        celsius = (5.0/9.0) * (fahr - 32.0);
        printf("%3.0f %6.1f\n", fahr, celsius);
        fahr = fahr + step;
    }
}
#+END_SRC

#+RESULTS:
| Fahrenheit | Celsius |
|          0 |   -17.8 |
|         20 |    -6.7 |
|         40 |     4.4 |
|         60 |    15.6 |
|         80 |    26.7 |
|        100 |    37.8 |
|        120 |    48.9 |
|        140 |    60.0 |
|        160 |    71.1 |
|        180 |    82.2 |
|        200 |    93.3 |
|        220 |   104.4 |
|        240 |   115.6 |
|        260 |   126.7 |
|        280 |   137.8 |
|        300 |   148.9 |
**** Exercise 1-4
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 120;                /* upper limit */
    step = 10;                  /* step size */

    celsius = lower;
    printf("%3s %6s\n", "Celsius", "Fahrenheit");
    while (celsius <= upper) {
        fahr = (9.0/5.0) * celsius + 32.0;
        printf("%3.0f %6.1f\n", celsius, fahr);
        celsius = celsius + step;
    }
}
#+END_SRC

#+RESULTS:
| Celsius | Fahrenheit |
|       0 |       32.0 |
|      10 |       50.0 |
|      20 |       68.0 |
|      30 |       86.0 |
|      40 |      104.0 |
|      50 |      122.0 |
|      60 |      140.0 |
|      70 |      158.0 |
|      80 |      176.0 |
|      90 |      194.0 |
|     100 |      212.0 |
|     110 |      230.0 |
|     120 |      248.0 |
*** The for statement
:PROPERTIES:
:NOTER_PAGE: 16
:END:
**** Exercise 1-5
:PROPERTIES:
:NOTER_PAGE: 17
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 300, 280, ..., 0; floating-point version*/

main(){
    int fahr;
    for (fahr = 300; fahr >= 0; fahr = fahr - 20) {
        printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32.0));
    }
}

#+END_SRC

#+RESULTS:
| 300 | 148.9 |
| 280 | 137.8 |
| 260 | 126.7 |
| 240 | 115.6 |
| 220 | 104.4 |
| 200 |  93.3 |
| 180 |  82.2 |
| 160 |  71.1 |
| 140 |  60.0 |
| 120 |  48.9 |
| 100 |  37.8 |
|  80 |  26.7 |
|  60 |  15.6 |
|  40 |   4.4 |
|  20 |  -6.7 |
|   0 | -17.8 |
*** Symbolic Constants
:PROPERTIES:
:NOTER_PAGE: 17
:END:
I think symbolic constants, defined by =#define=, would be open-coded when it compiled.
#+BEGIN_SRC C :includes <stdio.h> :exports both :defines LOWER 0 UPPER 300 STEP 20
int fahr;
for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
    printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32));
#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
*** Character Input and Output
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C :includes <stdio.h>
int c;
c = 50;
printf("\ninteger number %d got translated with putchar into %c\n", c, putchar(c));
#+END_SRC

#+RESULTS:
|       2 |        |    |     |            |      |         |      |   |
| integer | number | 50 | got | translated | with | putchar | into | 2 |
**** File Copying
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C
/* copy input to output; 1st version */
int c;

c = getchar();
while (c != EOF) {
    putchar(c);
    c = getchar();
}
#+END_SRC

More concisely, experienced C programmer would write above program as
#+BEGIN_SRC C
/* copy input to output; 2nd version */
int c;

while ((c = getchar ()) != EOF)
    putchar(c);
#+END_SRC

This exploited the fact that the assignment statement -- ~=~ -- has the value
evaluating the right hand side as its return value. Here also we should note
that =EOF= is just one of pre =define= d variable macro that would be replaced
any integer number that would not appear in the real character code.

Using this /trick/, we should be alerted that now we should be considerate on
the /precedence/ issue -- ~!=~ has higher precedence than ~=~.
***** Exercise 1-6
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
getchar() != EOF;
#+END_SRC

#+RESULTS:
#+BEGIN_SRC sh
~/org ÃŽÂ» ./C_codes/a.out
5
The input character 5 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character
 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character Ã¿ return 0 via "getchar() != EOF"
#+END_SRC

From this exercise, we know that character ~^D~ represent =EOF= (also apparently
0 means the test is false and 1 for the true).
***** Exercise 1-7
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
putchar(EOF);
#+END_SRC

#+RESULTS:
: Ã¿

What we discovered in preceding exercise got verified explicitly.
**** Character Counting
:PROPERTIES:
:NOTER_PAGE: 20
:END:
New operator, which is the mascot expression in C, =++=:
#+BEGIN_SRC C
++nc;
#+END_SRC

Although we have shown in the above example /prefix/ operator =++=, there is
also /postfix/ operator =++=; those have different values in expressions.

As introduced in preceding section, the =for= control structure is just
syntactic sugar for =while=, we could express the word counting program as
#+BEGIN_SRC C :includes <stdio.h> :exports both
double nc;

for (nc = 0; getchar () != EOF; ++nc);
printf("%.0f\n", nc);
#+END_SRC

#+RESULTS:
: 0
***** Exercise 1-8
:PROPERTIES:
:NOTER_PAGE: 22
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
long ns, nt, nl;
int c;

ns = 0;
nt = 0;
nl = 0;

while ((c = getchar ()) != EOF) {
    if (c == ' ')
        ++ns;
    if (c == '\t')
        ++nt;
    if (c == '\n')
        ++nl;
}
printf("The number of blanks, tabs, lines are %ld, %ld, %ld, respectively\n", ns, nt, nl);
#+END_SRC

#+RESULTS:
| The number of blanks | tabs | lines are 0 | 0 | 0 | respectively |
***** Exercise 1-9
:PROPERTIES:
:NOTER_PAGE: 22
:END:
Here is the algorithm that solves our task:
1. If the input character stream is not =EOF=,
2. if taken character stream is blank, print single blank and then
3. consume all the successive blanks;
4. else, print that input stream and then update character stream.
5. go to *1.*

Since we haven't yet learned the =else= control structure -- only =if=-then
structure -- we need to mimic the =if-else= structure:

#+BEGIN_SRC C :exports both
int c;
int flag;
c = getchar();
while (c != EOF) {
    flag = 0;               /* mimic if else control structure */
    if (c == ' ') {
        putchar(c);         /* print single blank */
        flag = 1;           /* signal that the entry character was blank */
        while ((c = getchar()) == ' ') /* comsume the successive blanks */
            ;
    }
    if (flag == 0) {        /* if the entry point was non-blank character */
        putchar(c);
        c = getchar();      /* update the c to be consist with comsumption of blanks */
    }
}
#+END_SRC

Then it works as expected:
#+BEGIN_SRC sh
~/org/C_codes [master] Î» ./a.out
asdfsd   sdf   d
asdfsd sdf d
Hi Test thsi    tis   d
Hi Test thsi tis d

#+END_SRC
***** Exercise 1-10
:PROPERTIES:
:NOTER_PAGE: 22
:END:
This program is analogous that of [[*Exercise 1-8][Exercise 1-8]], mimicking the =else= structure:
#+BEGIN_SRC C :includes <stdio.h> :exports both

int c, flag;


while ((c = getchar ()) != EOF) {
    flag = 1;
    if (c == '\b') {
        flag = 0;
        printf("\\b");
    }
    if (c == '\t') {
        flag = 0;
        printf("\\t");
    }
    if (c == '\n') {
        flag = 0;
        printf("\\n");
    }
    if (c == '\\') {
        flag = 0;
        printf("\\\\");
    }
    if (flag)
        putchar(c);
}
#+END_SRC

#+BEGIN_SRC sh
~/org/C_codes [master] Î» echo "tab	\	" | ./a.out
tab\t\\\t\n
#+END_SRC
**** Word Counting
:PROPERTIES:
:NOTER_PAGE: 22
:END:

#+BEGIN_SRC C :tangle C_codes/current.c :includes <stdio.h> :defines IN 1 OUT 0
int c, nl, nw, nc, state;

state = OUT;
nl = nw = nc = 0;
while ((c = getchar()) != EOF) {
    ++nc;
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
}
printf("%d %d %d\n", nl, nw, nc);
#+END_SRC

#+RESULTS:
: 0 0 0
***** Exercise 1-11
:PROPERTIES:
:NOTER_PAGE: 23
:END:

In Org mode, we can use session whenever the language supports ~REPL~; but since
C is the language should involve compiler to produce program, we can not use
them.

So we have to fall back to alternative approach: Use tangle feature.

Then let's test this code:
#+BEGIN_SRC sh
cd C_codes
cc current.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
echo "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
: 1 5 28

We've setup the environment where we integrated the Org babel with the testing C code.

To test this kind of program, we can take two different approaches:
1. Path complete test;
2. black box test -- test the specifications.


The former one tests all the branches the code implemented; in above case, it
has 2 branches in it: First only has consequent clause, second has also
alternative in addition to consequence:
#+BEGIN_SRC C
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
#+END_SRC

First, let's try the path complete test:
#+BEGIN_SRC sh :exports both
# Test first branch
echo | ./C_codes/current        # echo append '\n' by default
printf | ./C_codes/current      # printf do not append '\n'
# Test second branch
# just pass through first path of second branch
printf "\n\n\n   \t\t\t" | ./C_codes/current
# pass though the second path also
printf "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
| 1 | 0 |  1 |
| 0 | 0 |  0 |
| 3 | 0 |  9 |
| 0 | 5 | 27 |

Then let's do the latter one; it tests all the boundary cases:
#+BEGIN_SRC sh :exports both
# 0 0 0
printf | ./C_codes/current
# 1 0 1
echo | ./C_codes/current
# 0 0 1
printf " " | ./C_codes/current  # space
printf "\t" | ./C_codes/current  # tab
# 0 1 1
printf "c" | ./C_codes/current
# Compound cases
printf "This is \n compound case.\t" | ./C_codes/current
#+END_SRC

#+RESULTS:
| 0 | 0 |  0 |
| 1 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 1 |  1 |
| 1 | 4 | 25 |
***** Exercise 1-12
:PROPERTIES:
:NOTER_PAGE: 23
:END:
All we need to do is
- just copying the input if it were transition of state from
  =IN= to =IN= or =OUT= to =IN=;
- ignore if it were from =OUT= to =OUT=;
- replace it as =\n= if it were from =IN= to =OUT=;


#+BEGIN_SRC C :tangle C_codes/ex1_12.c :includes <stdio.h> :defines IN 1 OUT 0
int c, state;

state = OUT;
while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == OUT)
            ;                   /* ignore the input character */
        else {
            state = OUT;
            putchar('\n');
        }
    }
    else {
        state = IN;
        putchar(c);
    }
}
#+END_SRC

Then test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_12.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
printf "Test words\n\n\n\t\t\t   One Two     Three" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Test  |
| words |
| One   |
| Two   |
| Three |
*** Arrays
:PROPERTIES:
:NOTER_PAGE: 25
:END:
***** Exercise 1-13
:PROPERTIES:
:NOTER_PAGE: 25
:END:
The most canonical way to implement this program would be
1. Assume that we have data structure, table that contains entries which
   consist of key and value;
2. modifying the word counting program, which we implemented in preceding
   section, implement program that counts the length of first word from the
   input stream;
3. for each word in the input stream, insert newly calculated word length into
   the predefined table that contains word length - frequency entries;
4. print the entries in that table using histogram.


But, only with what we've learned so far, we can not implement the assumed data
structure, so we need to approach this exercise in more naive manner.

We are going to use array as table like structure but that table possibly be
very scarce -- inefficient; moreover, as we are not allowed to allocates the
input stream into some temporary file or on memory to use more than once, we can
not cope with extreme cases where maximum word length is enormous.


Here is the resulting code, which approximately implement above algorithm naively:
#+BEGIN_SRC C :tangle C_codes/ex1_13.c :includes <stdio.h> :defines IN 1 OUT 0 MAX_LENG 100

int c, i, j, wl, state;
int nwords[MAX_LENG];

state = OUT;
wl = 0;
for (i = 0; i < MAX_LENG; ++i)
    nwords[i] = 0;

while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == IN)        /* IN -> OUT transition */
            ++nwords[wl];

        state = OUT;
    }
    else {
        if (state == OUT)       /* OUT -> IN transition */
            wl = 0;             /* initialize word length counter */
        state = IN;
        ++wl;
    }
}

if (state == IN)                /* EOF is also delimiter */
    ++nwords[wl];

printf("%s\t%s\n", "Word length", "Frequency");
for (i = 0; i < MAX_LENG; ++i) {
    if (nwords[i] != 0) {       /* print only non zero frequency entries */
        printf("%d\t", i);
        for (j = 0; j < nwords[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_13.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_13.c | ./C_codes/current
# printf "test\nMy-test test" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Word length | Frequency                                          |
|           1 | **********************************                 |
|           2 | ************************************************** |
|           3 | ******************                                 |
|           4 | *************                                      |
|           5 | **********                                         |
|           6 | *******                                            |
|           7 | *****                                              |
|           8 | ***                                                |
|           9 | *********                                          |
|          10 | ******                                             |
|          13 | ****                                               |
|          14 | **                                                 |
|          17 | *                                                  |
|          18 | *                                                  |
***** Exercise 1-14
:PROPERTIES:
:NOTER_PAGE: 25
:END:
This is an analogous program of preceding exercise. The maximum length becomes
='z' - 'a'= and the others are obvious relations:

#+BEGIN_SRC C :tangle C_codes/ex1_14.c :includes <stdio.h>
int c, i, j;
int length = 'z' - 'a' + 1;
int nchars[length];

for (i = 0; i < length; ++i)
    nchars[i] = 0;

while ((c = getchar()) != EOF) {
    if ('a' <= c && c <= 'z')
        ++nchars[c - 'a'];
}

printf("%s\t%s\n", "Character", "Frequency");
for (i = 0; i < length; ++i) {
    if (nchars[i] != 0) {       /* print only non zero frequency entries */
        printf("%c\t", i + 'a');
        for (j = 0; j < nchars[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_14.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_14.c | ./C_codes/current
# printf "zzzz AAA aaaa" | ./C_codes/current # only count lowercase character
#+END_SRC

#+RESULTS:
| Character | Frequency                      |
| a         | ****************               |
| c         | ********************           |
| d         | **                             |
| e         | *********************          |
| f         | *********                      |
| g         | ******                         |
| h         | ******************             |
| i         | ****************************   |
| j         | ****                           |
| l         | *******                        |
| m         | **                             |
| n         | ****************************** |
| o         | ********                       |
| p         | *******                        |
| q         | ***                            |
| r         | ***************************    |
| s         | ***********                    |
| t         | ***********************        |
| u         | *******                        |
| w         | **                             |
| y         | ****                           |
| z         | ***                            |
*** Functions
:PROPERTIES:
:NOTER_PAGE: 26
:END:
Let's test recursive definition of =power=:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>
int power(int m, int n);

main()
{
    int i;

    printf("power(2,5) is %d", power(2, 5));
}

/* recursive definition of exponentiation */
int power(int base, int n)
{
    if (n == 0)
        return 1;
    else
        return base * power(base, n - 1);
}
#+END_SRC

#+RESULTS:
| power(2 | 5) is 32 |

Yes it works as expected.
***** Exercise 1-15
#+BEGIN_SRC C :main no :tangle C_codes/ex1_15.c :exports both
#include <stdio.h>

#define LOWER 0
#define UPPER 300
#define STEP 20

float fahr2cels(float fahr);
/* test temperature conversion function */
main () {
    float fahr;
    for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf("%3.0f %6.1f\n", fahr, fahr2cels(fahr));
    return 0;
}
/* temperature conversion function from fahrenheit to celsius*/
float fahr2cels(float fahr) {
    return (5.0/9.0) * (fahr - 32.0);
}

#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
*** Call by value
*** Character array
***** Exercise 1-16
:PROPERTIES:
:NOTER_PAGE: 31
:END:
Since C is strictly typed language, if the specific task does not require, we
usually do not code in dynamic manner -- recursive function definition and so on.

However in this exercise, we can not cope with this task without using
dynamically evolving program since we are dealing with unknown input stream --
it is inheritly dynamic one.

To cope with this task, we will try to use the recursive function definition to
accommodate sufficient memory for given input stream.

We are going to define =printOverflowed= that print longest input line. It takes
=maxline=, =impending[]= (if any):
#+BEGIN_SRC C :main no :tangle C_codes/ex1_16.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    int len;
    int max;
    int overflow = 0;
    char line[INITIALMAX];
    char longest[INITIALMAX];

    max = 0;
    while ((len = getlineFrom(0, line, INITIALMAX)) > 0)
        if (isOverflowed(line, len, INITIALMAX)) {
            overflow = 1;
            printOverflowed(INITIALMAX, line);
        }
        else if (len > max) {
            max = len;
            copy(longest, line);
        }
    if (overflow != 1 && max > 0)
        printf("%s", longest);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[])
{
    int len, max;
    int overflow = 0;
    int lim = 2 * oldLim;
    char line[lim];
    char longest[lim];

    copy(line, impending);
    max = len = getlineFrom(oldLim - 1, line, lim);
    if (isOverflowed(line, len, lim))
        printOverflowed(lim, line);
    else {
        copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (overflow != 1)
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

We've handled the overflowed condition explicitly using the =printOverflowed=
function. It is almost same as the entry point function, =main= except it
handles allocates the current line and longest line with extended limit array indice.

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
***** Exercise 1-17
:PROPERTIES:
:NOTER_PAGE: 31
:END:
We can achieve what we want by modifying the preceding example. That is,
whenever we encounters input line that is longer than threadhold length.

Before doing modification of code of [[*Exercise 1-16][Exercise 1-16]], let us first refactor that
code to encompass the entry point case into the =printOverflowed= so that we can
easily change the behavior of that program by making them modular.

We used following experiment to refactor our code:

#+NAME: Test logical not
#+BEGIN_SRC C :exports both
printf("%d", !0);
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC C :main no :tangle C_codes/ex1_16_refactored.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len, max;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];
    char longest[lim];

    if (isentry) {
        max = 0;
    }
    else {
        copy(line, impending);
        max = len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (!overflow && (!isentry || (isentry && max > 0)))
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Our =main= routine got simplified just calling the subroutines appropriately.
Let's test this refactored code:


Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16_refactored.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |

It works as expected.

Now we turn to the our original task; it actually simpler than preceding
exercise. All we need to do is just print given line if it is longer than the
threadhold length.

#+BEGIN_SRC C :main no :tangle C_codes/ex1_17.c
#include <stdio.h>
#define INITIALMAX 10
#define TREADHOLD 8

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
void copy(char to[], char from[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            if (len >= TREADHOLD)
                printf("%s", line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len >= TREADHOLD)
                printf("%s", line);

    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_17.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "threadhold\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| threadhold |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
| like       | this |      |        |      |        |

Seems like works well.
***** Exercise 1-18
:PROPERTIES:
:NOTER_PAGE: 31
:END:
What we need is function that removes trailing blanks and tabs from given line;
if we implement that function, all the left is to apply that function to each of
input line that is allowed to be arbitrary length.

So here we are going to design remove trailing blanks and tabs from given
argument character array. It needs to take character array with the length of
that to detect the last element; it will mutate the argument array if it has
trailing white spaces. And finally it will return the truncated length to make
the caller to take action with that information -- for this specific case, not
to print the zero length line.

#+BEGIN_SRC C :main no :results verbatim :exports both
#include <stdio.h>

int removeTrailings(int length, char line[]);
int isWhite(char character);
int stringLength(char line[]);
void copy(char to[], char from[]);

/* Test remove trailings */
int main()
{
    char test[] = "Test trailings     		  \n";
    int len = stringLength(test);
    char testCopy[len];
    copy(testCopy, test);       /* copy the test into the testCopy */
    removeTrailings(len, test); /* remove trailings of test */
    printf("%s, which has length %d, got truncated as \n%s, which now has length %d",
           testCopy,
           stringLength(testCopy),
           test,
           stringLength(test));
    return 0;
}

int removeTrailings(int len, char s[])
{
    int i = len - 2;
    int newlen;
    if (isWhite(s[i])) {
        s[i+1] = '\0';          /* make the newline character to be null */
        while(i >= 0 && isWhite(s[i])) { /* make sure not to be underflow */
            s[i] = '\0';        /* remove trailing white spaces */
            --i;
        }
        if (i >= 0) {
            ++i;
            s[i] = '\n';      /* restore newline character to be end of new result */
            newlen = i;         /* new length */
        } else
            newlen = 0;
    } else
        newlen = len;
    return newlen;
}

int isWhite(char c) {
    return c == '\t' || c == ' ';
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int stringLength(char s[]) {
    int len;
    for (len = 0; s[len] != '\0'; ++len)
        ;
    return len;
}
#+END_SRC

#+RESULTS:
: Test trailings
: , which has length 24, got truncated as
: Test trailings
: , which now has length 15

Seems works well.

Now we can integrate all of the pieces:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_18.c
#include <stdio.h>
#define INITIALMAX 10
#define TRUE 1

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);
int removeTrailings(int length, char line[]);
int isWhite(char character);
void copy(char to[], char from[]);

int main()
{
    printOverflowed(INITIALMAX, "", TRUE);
    return 0;
}

int removeTrailings(int len, char s[])
{
    int i = len - 2;
    int newlen;
    if (isWhite(s[i])) {
        s[i+1] = '\0';          /* make the newline character to be null */
        while(i >= 0 && isWhite(s[i])) { /* make sure not to be underflow */
            s[i] = '\0';        /* remove trailing white spaces */
            --i;
        }
        if (i >= 0) {
            ++i;
            s[i] = '\n';      /* restore newline character to be end of new result */
            newlen = i;         /* new length */
        } else
            newlen = 0;
    } else
        newlen = len;
    return newlen;
}

int isWhite(char c) {
    return c == '\t' || c == ' ';
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            if ((len = removeTrailings(len, line)) > 0)
                printf("%s", line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                printOverflowed(lim, line, 0);
            }
            else if ((len = removeTrailings(len, line)) > 0)
                printf("%s", line);

    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_18.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "trailings        	\nsimple\nones\n" | ./C_codes/current
printf "test empty line\n     	\nlike this" | ./C_codes/current
# printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
: trailings
: simple
: ones
: test empty line
: like this

Works as expected.
***** Exercise 1-19
:PROPERTIES:
:NOTER_PAGE: 31
:END:
I've designed this problem -- the algorithm behind this -- in my digital paper.
It is way more easy to describe in image rather than text; briefly, we are going
to reverse given array in place -- looping through half of the index and
interchange front half part with rear half part.

#+BEGIN_SRC C :main no :results verbatim :exports both
#include <stdio.h>

void reverse(int length, char line[]);
int stringLength(char line[]);
void copy(char to[], char from[]);

/* Test remove trailings */
int main()
{
    char test[] = "Reverse test  \t HiiH \n";
    int len = stringLength(test);
    char testCopy[len];
    copy(testCopy, test);       /* copy the test into the testCopy */
    reverse(len, test); /* reverse the test */
    printf("%s got reversed as \n%s",
           testCopy,
           test);
    return 0;
}

void reverse(int len, char s[])
{
    int lastIndex = len - 2;    /* lastIndex except the newline character */
    int halfIndex = (lastIndex - 1) / 2; /* use integer division to be used in loop */
    char temp;                           /* temporary storage to interchange */
    int i;                               /* loop index */
    for (i = 0; i <= halfIndex; ++i) {
        temp = s[i];
        s[i] = s[lastIndex - i];
        s[lastIndex - i] = temp;
    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int stringLength(char s[]) {
    int len;
    for (len = 0; s[len] != '\0'; ++len)
        ;
    return len;
}
#+END_SRC

#+RESULTS:
: Reverse test  	 HiiH
:  got reversed as
:  HiiH 	  tset esreveR

It works as expected.

Let's finish our works as usual:

#+BEGIN_SRC C :main no :tangle C_codes/ex1_19.c
#include <stdio.h>
#define INITIALMAX 10
#define TRUE 1

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);
void reverse(int length, char line[]);
void copy(char to[], char from[]);

int main()
{
    printOverflowed(INITIALMAX, "", TRUE);
    return 0;
}

void reverse(int len, char s[])
{
    int lastIndex = len - 2;    /* lastIndex except the newline character */
    int halfIndex = (lastIndex - 1) / 2; /* use integer division to be used in loop */
    char temp;                           /* temporary storage to interchange */
    int i;                               /* loop index */
    for (i = 0; i <= halfIndex; ++i) {
        temp = s[i];
        s[i] = s[lastIndex - i];
        s[lastIndex - i] = temp;
    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry) {
            reverse(len, line);
            printf("%s", line);
        }
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                printOverflowed(lim, line, 0);
            }
            else {
                reverse(len, line);
                printf("%s", line);
            }

    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_19.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "trailings        	\nsimple\nones\n" | ./C_codes/current
printf "test empty line\n     	\nlike this\n" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this\n" | ./C_codes/current
#+END_SRC

#+RESULTS:
: 	        sgniliart
: elpmis
: seno
: enil ytpme tset
:
: siht ekil
: tseT
: !eciwt naht regnol esac tset dewolfrevo
: siht ekil
*** External Variables and Scope
:PROPERTIES:
:NOTER_PAGE: 32
:END:
***** Exercise 1-20
:PROPERTIES:
:NOTER_PAGE: 34
:END:


Since we assume that =n= does not change during program execution, it's better
to use symbolic parameter than variable for =n=.

For the designing the behavior, as we don't know prior how many length of line
would it results when we =detab= the given input, we need to dynamic expand the
output string like we did in =printOverflowed=; and we will produce the output
stream by mutating the output string like we did in =copy=.

Or we could achieve the behavior we want by using the strategy used in [[*Exercise 1-9][Exercise
1-9]].

That is, if the input character is tab, then we expand tab as blanks; otherwise,
just copy that input into output. Here is the pseudocode:
#+BEGIN_SRC C
while (input character is not end of file)  {
    if (input eqauls to tab)
        put blanks until (current columns % n) equals to 0;
    else copy the input character into the output;
}

#+END_SRC
So, our program keep track of the current column index as state variable. Here
is the implementation:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_20.c
#include <stdio.h>
#define TABSTOP 4                     /* Tab stop */

int expandtab(int columnIndex);

int main() {
    int c;
    int ncolumn = 0;

    while ((c = getchar()) != EOF) {
        if (c == '\t')
            ncolumn = expandtab(ncolumn); /* update column number */
        else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;    /* initialize column number */
            else ++ncolumn;     /* increase column number */
        }
    }
}

int expandtab(int nc) {
    if ((nc % TABSTOP) == 0) {
        putchar(' ');
        ++nc;
    }
    while((nc % TABSTOP) != 0) {
        putchar(' ');
        ++nc;
    }
    return nc;
}
#+END_SRC

We reasoned the next column line number in =expandtab= by observing that it
should be product of =TABSTOP=; since if the given column index is already
product of =TABSTOP=, it means we should expand the =tab= until next tabstop in
this case, we handled this case explicitly.

Or the we can think =ncolumn= as if the cursor's column number and the input
character stream as user typing in the text editor like now.

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_20.c -o detab
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "sf	a" | ./C_codes/detab
#+END_SRC

#+RESULTS:
: sf  a
***** Exercise 1-21
We can assume the input stream of =entab= to have no tab characters in it -- if
it were, we can eliminate those with the =detab=, which we implemented previously.

Here we also approach to this problem that is analogous to previous one. The
following pseudocode describes our wishful thinking:
#+BEGIN_SRC C
while (the input character is not end of file)  {
    if (input eqauls to blank) {
        consume blanks until it encounters with either next tabstop
            or non-blank character with updating the column line number
            appropriately;
        if (column line is next tabstop)
            print tab character;
        else barfage all the currently consumed blanks /* current input character consumed */
                 }
    else {                      /* non-blanck character */
        copy the input character into the output;
        if (the input character is newline character)
            initialize the column line number -- start with next line;
        else increase column line number by one;
        consume one input character to agree with above if branch;
    }
}

#+END_SRC

#+BEGIN_SRC C :main no :tangle C_codes/ex1_21.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */

int main() {
    int c;
    int ncolumn = 0;
    int nexttabstop;
    int nentry;

    c = getchar();
    while (c != EOF) {
        if (c == ' ') {
            nentry = ncolumn;
            ++ncolumn;
            nexttabstop = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
            while (ncolumn != nexttabstop && (c = getchar()) == ' ') {
                ++ncolumn;
            }
            if (ncolumn == nexttabstop) {
                putchar('\t');
                c = getchar();  /* to agree with next branch */
            } else {
                while(nentry != ncolumn) {
                    putchar(' ');
                    ++nentry;
                }
            }
        } else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;
            else ++ncolumn;
            c = getchar();      /* to agree with above if branch */
        }
    }
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_21.c -o entab
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
# printf "sf		sdfd	d  a" | ./C_codes/detab  | ./C_codes/entab
# printf "sfd a\n" | ./C_codes/entab
printf "sfd     a" | ./C_codes/entab
#+END_SRC
#+RESULTS:
: sfd	a

It agree with my text editor -- Emacs; actually in this environment, we can not
face with the case posed in the statement -- when either a tab or a single blank
would suffice to reach a tab stop -- since in that case, the tab stop character
should reach one more tabstop than next tabstop. We accomplished this by
choosing carefully next tab stop -- ~nexttabstop = ncolumn + (TABSTOP - (ncolumn
% TABSTOP));~, which do the right thing.
***** Exercise 1-22
Before go into designing any code or implementation the requested task, first,
we should make concrete the abstract specification -- it can be seen as part of
designing in a more large scale.

Here is the summary:
+-------+-------------------------+------------------------------------------------+
| Cases |        Situation        |                      Want                      |
+-------+-------------------------+------------------------------------------------+
|     1 | Line contains no blanks |        Fold at n; continue from there.         |
+-------+-------------------------+------------------------------------------------+
|     2 |    Line less than n     |    No fold; just copy that input to output.    |
+-------+-------------------------+------------------------------------------------+
|     3 |  Line with only blanks  | Replace current line with line that has first  |
|       |                         |    non-blank character as its first column     |
|       |                         |                   character.                   |
+-------+-------------------------+------------------------------------------------+
|     4 |   Line has word being   | Fold current line so as the next line to start |
|       |    constructed at n     |   with current word and continue from that.    |
+-------+-------------------------+------------------------------------------------+
|     5 |  Line has blank being   |Consume all consecutive blanks and then initiate|
|       |      consumed at n      | next line & if current input is newline, take  |
|       |                         |      one more character, else do nothing.      |
+-------+-------------------------+------------------------------------------------+

From this, we can observe that to accomplish all of those specifications at the
same time, we need to keep track of the deferred blanks and deferred non-blank
character array separately.

Here is the pseudo state transition diagram to implement:

#+BEGIN_SRC dot :exports results :file C_codes/ex1_22.png
digraph G {
    rankdir = LR;
    subgraph cluster1 {
        style = filled
        color = lightgrey
        node [shape = circle, label="IN"] in
        node [shape = circle, label="OUT"] out
        in -> out [label = "Case 4:
                   handover the current deferred non-blanks to next line processor
                   destroy all the deferred blanks"]
        out -> in [label = "Case 5:
                   destory all the defered blanks
                   continue in next line"]
        label = "for column line number >= n"
    }
    subgraph cluster0 {
        color = white
        node [shape = doublecircle, label="newline"] newline
        node [shape = circle, label="IN"] IN
        node [shape = circle, label="OUT"] OUT
        IN -> OUT [label = "consume blank character\nflush blanks"]
        OUT -> IN [label = "consume word character\nflush word"]
        IN -> in [label = "Case 1:"]
        OUT -> out [label = "Case 3:"]
        {IN, OUT} -> newline [label = "Case 2:"]
        label = "for column line number < n"
    }
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_22.png]]

Now we are going to implement this design. First, we are going to cope with for
column line number < n case. Let us first code the pseudocode:
#+BEGIN_SRC C
while (the input character is not end of file character) {
    if (the input character is blank) { /* entry point of white spaces */
        flush deferred blanks if any;
        initialize the deferred blanks;
        defer all the consecutive blanks;
    }
    else if (the input character is newline) { /* Here we only consider the column line number < n */
        if (current state is in the word) {
            flush deferred blanks if any;
            flush deferred word;
        } else {                /* current state is out of the word */
            flush deferred word if any;
            flush deferred blanks;
        }
        initialize the deferred blanks;
        initialize the deferred word;
        initialize the column line number;
    }
    else {                      /* the input character is non-blank character */
        /* this is the entry point of non-blank characters */
        flush deferred word if any;
        initialize the deferred word;
        defer all the consecutive word characters;
    }
}
#+END_SRC

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0

int updateWhenBlank(char c, int ncolumn) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
    return ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

int main() {
    int c;
    int ncolumn = 0;
    char blanks[FOLD] = "";
    int bInd = 0;
    char word[FOLD] = "";
    int wInd = 0;
    int state = OUT;

    c = getchar();
    while (c != EOF) {
        if (isBlankCharacter(c)) {
            ncolumn = updateWhenBlank(c, ncolumn);
            if (bInd > 0) {     /* flush the blanks if any */
                printf("%s", blanks);
                bInd = 0;
            }
            blanks[bInd] = c;   /* defer input character */
            ++bInd;             /* update next Index of blanks */
            while (isBlankCharacter(c = getchar())) { /* consume one more character */
                ncolumn = updateWhenBlank(c, ncolumn);
                blanks[bInd] = c;   /* defer input character */
                ++bInd;             /* update next Index of blanks */
            }
            blanks[bInd] = '\0'; /* the end of string character */
            state = OUT;         /* update state */
        } else if (c == '\n') {
            if (state == IN) {
                if (bInd > 0)
                    printf("%s", blanks);
                if (wInd > 0)
                    printf("%s", word);
            } else {
                if (wInd > 0)
                    printf("%s", word);
                if (bInd > 0)
                    printf("%s", blanks);
            }
            bInd = 0;
            wInd = 0;
            ncolumn = 0;
            putchar('\n');         /* print newline */
            state = OUT;           /* update state */
            c = getchar();         /* consume one character */
        } else {                   /* input character is non-blank character */
            ++ncolumn;             /* update column line number */
            if (wInd > 0) {        /* flush word */
                printf("%s", word);
                wInd = 0;
            }
            word[wInd] = c;     /* defer current character */
            ++wInd;             /* update the word Index */
            while (isWordCharacter(c = getchar())) {
                ++ncolumn;      /* update column line number */
                word[wInd] = c;     /* defer current character */
                ++wInd;             /* update the word Index */
            }
            word[wInd] = '\0';  /* end of string */
            state = IN;             /* update state */
        }
    }
    if (state == IN) {
        if (bInd > 0)
            printf("%s", blanks);
        if (wInd > 0)
            printf("%s", word);
    } else {
        if (wInd > 0)
            printf("%s", word);
        if (bInd > 0)
            printf("%s", blanks);
    }
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be

It works as expected. Now we are going to refactor above code using the external
variable -- it would actually make the code more modular:

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22_refactored.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0

/* external variables */
int ncolumn = 0;
char blanks[FOLD] = "";
int bInd = 0;
char word[FOLD] = "";
int wInd = 0;
int state = OUT;

void updateColumnWhenBlank(char c) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
}

void updateColumnWhenWord(char c) {
    ++ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

void flushBlanksIfAny(void) {
    if (bInd > 0)      /* flush the blanks if any */
        printf("%s", blanks);
}

void flushWordIfAny(void) {
    if (wInd > 0)      /* flush the word if any */
        printf("%s", word);
}

void flushAll(void) {
    if (state == IN) {
        flushBlanksIfAny();
        flushWordIfAny();
    } else {
        flushWordIfAny();
        flushBlanksIfAny();
    }
}

void deferBlank(char c) {
    blanks[bInd] = c;
    ++bInd;
}

void deferWord(char c) {
    word[wInd] = c;
    ++wInd;
}

void initializeBlanks(void) {
    bInd = 0;
}

void initializeWord(void) {
    wInd = 0;
}

void initializeColumn(void) {
    ncolumn = 0;
}

void endOfBlanks(void) {
    blanks[bInd] = '\0';
}

void endOfWord(void) {
    word[wInd] = '\0';
}

int main() {
    int c;

    c = getchar();
    while (c != EOF) {
        if (isBlankCharacter(c)) {
            updateColumnWhenBlank(c);
            flushBlanksIfAny();
            initializeBlanks();
            deferBlank(c);
            while (isBlankCharacter(c = getchar())) { /* consume one more character */
                updateColumnWhenBlank(c);
                deferBlank(c);
            }
            endOfBlanks();
            state = OUT;         /* update state */
        } else if (c == '\n') {
            flushAll();
            initializeBlanks();
            initializeWord();
            initializeColumn();
            putchar('\n');         /* print newline */
            state = OUT;           /* update state */
            c = getchar();         /* consume one character */
        } else {                   /* input character is non-blank character */
            updateColumnWhenWord(c);
            flushWordIfAny();
            initializeWord();
            deferWord(c);
            while (isWordCharacter(c = getchar())) {
                updateColumnWhenWord(c);
                deferWord(c);
            }
            endOfWord();
            state = IN;             /* update state */
        }
    }
    flushAll();
    printf("\nThe current column line number is %d", ncolumn);
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22_refactored.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be
: The current column line number is 18

The column line number also agree with this. With current tool kit, the external
variable effects in a good way since we aren't allowed to use any higher order function.

Now let's turn into another side -- the case where column line number >= n.

#+BEGIN_SRC C
while (the input character is not end of file character) {
    if (the column line number is greater than or equals to n) {
        if (current state is in the word) { /* the current column line number should eqaul to n */
            if (input character is non-word character) { /* actually the actions are same as newline clause's */
                flush all;
                initialize deferred blanks;
                initialize deferred word;
                print new line character;
                initialize column line number;
                set the state OUT;
            }
            else if (have flushed in current line) {
                initialize deferred blanks;
                print new line character;
                set the column line number to the current deferred word index;
            } else {            /* current line densed with all the word character */
                flush deferred word;
                print character that signal this is the folded line;
                print new line character;
                initialize the column line number;
            }
        } else {                /* reached via consuming all the blank characters */
            initialize deferred blanks;
            if (have flushed in current line) {
                flush deferred word;
                if (the input character is new line) /* ensure the current input character is word character */
                    consume until it gets word character;
                print new line character;
                initialize column line number;
            } else {            /* current line has no word character */
                initialize column line number; /* reuse current line */
            }
        }
    }
    else if (the input character is newline) { /* Here we only consider the column line number < n */
        if (current state is in the word) {
            flush deferred blanks if any;
            flush deferred word;
        } else {                /* current state is out of the word */
            flush deferred word if any;
            flush deferred blanks;
        }
        initialize the deferred blanks;
        initialize the deferred word;
        initialize the column line number;
    }
    else if (the input character is blank) { /* entry point of white spaces */
        flush deferred blanks if any;
        initialize the deferred blanks;
        defer all the consecutive blanks;
        set state OUT;
    }
    else {                      /* the input character is non-blank character */
        /* this is the entry point of non-blank characters */
        flush deferred word if any;
        initialize the deferred word;
        defer all the consecutive word characters until column line number less than n; /* changed from before */
        set state IN;
    }
}
#+END_SRC

You should convince yourself above algorithm cope with all the cases we
specified above. Then let's code it

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22_complete.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0
#define TRUE 1
#define FALSE 0

/* external variables */
int ncolumn = 0;
char blanks[FOLD + 1] = "";
int bInd = 0;
char word[FOLD + 1] = "";
int wInd = 0;
int state = OUT;
int hasFlushed =  FALSE;
int c;

void updateColumnWhenBlank(char c) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
}

void updateColumnWhenWord(char c) {
    ++ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

void flushBlanksIfAny(void) {
    if (bInd > 0) {    /* flush the blanks if any */
        hasFlushed = TRUE;
        printf("%s", blanks);
    }
}

void flushWordIfAny(void) {
    if (wInd > 0) {    /* flush the word if any */
        hasFlushed = TRUE;
        printf("%s", word);
    }
}

void flushAll(void) {
    if (state == IN) {
        flushBlanksIfAny();
        flushWordIfAny();
    } else {
        flushWordIfAny();
        flushBlanksIfAny();
    }
}

void deferBlank(char c) {
    blanks[bInd] = c;
    ++bInd;
}

void deferWord(char c) {
    word[wInd] = c;
    ++wInd;
}

void initializeBlanks(void) {
    bInd = 0;
}

void initializeWord(void) {
    wInd = 0;
}

void initializeColumn(void) {
    initializeBlanks();
    initializeWord();
    hasFlushed = FALSE;
    state = OUT;           /* update state */
    ncolumn = 0;
}

void endOfBlanks(void) {
    blanks[bInd] = '\0';
}

void endOfWord(void) {
    word[wInd] = '\0';
}

void flushAndContinueInNext(void) {
    flushAll();
    initializeColumn();
    putchar('\n');         /* print newline */
    c = getchar();         /* consume one character */
}

void signalFolded(void) {
    putchar('-');
}


int main() {

    c = getchar();
    while (c != EOF) {
        if (ncolumn >= FOLD) {
            if (state == IN) {
                if (!isWordCharacter(c))
                    flushAndContinueInNext();
                else if (hasFlushed) {
                    initializeBlanks();
                    putchar('\n');
                    ncolumn = wInd;
                    hasFlushed = FALSE;
                } else {
                    flushWordIfAny();
                    signalFolded();
                    putchar('\n');
                    initializeColumn();
                }
            } else {
                if (hasFlushed) {
                    flushWordIfAny();
                    if (c == '\n')
                        while (!isWordCharacter(c = getchar()))
                            ;
                    putchar('\n');
                    initializeColumn();
                } else {
                    initializeColumn();
                }
            }
        }
        else if (isBlankCharacter(c)) {
            updateColumnWhenBlank(c);
            flushBlanksIfAny();
            initializeBlanks();
            deferBlank(c);
            while (isBlankCharacter(c = getchar()) && ncolumn < FOLD) { /* consume one more character */
                updateColumnWhenBlank(c);
                deferBlank(c);
            }
            endOfBlanks();
            while (isBlankCharacter(c)) { /* consume overflowed blanks */
                c = getchar();
                updateColumnWhenBlank(c);
            }
            state = OUT;         /* update state */
        } else if (c == '\n') {
            flushAndContinueInNext();
        } else {                   /* input character is non-blank character */
            updateColumnWhenWord(c);
            flushWordIfAny();
            initializeWord();
            deferWord(c);
            while (isWordCharacter(c = getchar()) && ncolumn < FOLD) {
                updateColumnWhenWord(c);
                deferWord(c);
            }
            endOfWord();
            state = IN;             /* update state */
        }
    }
    flushAll();
    printf("\nThe current column line number is %d", ncolumn);
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22_complete.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "This line is really long enough                to overflow the fold limit!!" | ./C_codes/current
#+END_SRC

#+RESULTS:
: This line is really
: long enough
: to overflow the fold
: limit!!
: The current column line number is 7

The above test case was just general case, case 4 and 5, let's try other cases we specified
above:
First, the case 2:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be
: The current column line number is 18

Works as expected.

Now case 3:
#+BEGIN_SRC sh :exports both :results verbatim
printf "         	           this line replaced" | ./C_codes/current
#+END_SRC

#+RESULTS:
: this line replaced
: The current column line number is 18

If the line is all blanks and has no word it should be what?

#+BEGIN_SRC sh :exports both :results verbatim
printf "                          " | ./C_codes/current
#+END_SRC

#+RESULTS:
:                         "
: The current column line number is 26

The above one is not what we expected ever. Why such abnormal result happend? If
we reason through carefully, we came to realize it is due to the overflow of our
=blanks= character array -- its length limited to =FOLD= but this one obviously
overflowed that. As we did in =word= case, we should handle the overflow case
explicitly.

But the behavior that we wanted in this case implies that we have to dynamically
expand the =blanks= to cope with just that case; this can be achieved using the
same strategy with =printOverflowed=; but since this involve dramatic changes in
current code -- we can't use external variables any more since =blanks= should
grow dynamically, so external declarations can not cope with that -- so for now
let us just make informal contraction that blank line ends with end of file
character should not overflow the given fold point.

However, we should handle the overflow case explicitly as noted but in different
perspective. That is, the current version modifies invalid memory -- the
overflowed index -- which can cause unexpected result. I've reflected those
changes in above code (for whom having curiosity about that change, see the git
diff for that). Now the above test case return only 20 blanks no more unexpected one.

Now here is the final state diagram we have implemented:
#+BEGIN_SRC dot :exports results :file C_codes/ex1_22_final.png
digraph G {
    rankdir = LR;
    label = "for input character is not end of file"
    color = black
    subgraph cluster1 {
        style = filled
        color = lightgrey
        node [style=filled, color = white]
        node [shape = circle, label="IN"] in
        node [shape = circle, label="OUT"] out
        in -> out [label = "/handover the current deferred non-blanks to next line processor\ndestroy all the deferred blanks"]
        in -> in [label = "has not flushed\n/flush word in current line\nsiganl this line folded\ncontinue in next line"]
        out -> in [label = "/destory all the defered blanks\ncontinue in next line"]
        label = "for column line number >= n"
    }
    subgraph cluster0 {
        color = white
        node [shape = doublecircle, label="newline"] newline
        node [shape = circle, label="IN"] IN
        node [shape = circle, label="OUT"] OUT
        IN -> OUT [label = "consume blank character\n/flush blanks"]
        OUT -> IN [label = "consume word character\n/flush word"]
        IN -> in [label = "column number >= n\n/hand over the control"]
        OUT -> out [label = "column number >= n\n/consume all the consecutive blanks -- do not defer"]
        {IN, OUT} -> newline [label = "/flush all deferred string;setup next line"]
        label = "for column line number < n"
    }
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_22_final.png]]

#+BEGIN_SRC sh :exports both :results verbatim
printf "                          " | ./C_codes/current
#+END_SRC

#+RESULTS:
:
: The current column line number is 26

Let us continue the rest of cases. The last case -- case 1:
#+BEGIN_SRC sh :exports both :results verbatim
printf "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" | ./C_codes/current
#+END_SRC

#+RESULTS:
: aaaaaaaaaaaaaaaaaaaa-
: aaaaaaaaaaaaaaaaaaaa-
: aaaaaa
: The current column line number is 6

Actually our original implementation couldn't cope with this case; from this
test case, we realized that the =blanks= and =word= string should have length
=FOLD + 1= not exactly =FOLD= to afford the end of string character.
***** Exercise 1-23
#+BEGIN_SRC C
printf("This is test for the response of C compiler about the ill-typed comment syntax");
/* like this
#+END_SRC

So it consume all the subsequent characters after opening comment syntax; all we
need to do is just discard all the subsequent input characters until the closing
comment syntax is matched -- =*/=. This is way more simpler task than the one
just before it.

In state diagram, we can draw what we should implement as follows:
#+BEGIN_SRC dot :file C_codes/ex1_23.png :exports results
digraph G {
    rankdir = LR;
    node [shape = doublecircle] "normal" "in comment";
    node [shape = circle];
    "normal" -> "normal" [label = "copy to output\nother than / character"]
    "normal" -> "/" [label = "consume /"]
    "/" -> "normal" [label = "barfage / and copy to output\nother than * character"]
    "/" -> "in comment" [label = "consume *"]
    "in comment" -> "in comment" [label = "consume other than * character"]
    "in comment" -> "*" [label = "consume *"]
    "*" -> "in comment" [label = "consume other than / character"]
    "*" -> "normal" [label = "consume /"]
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_23.png]]

Let's coding according to this diagram:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_23.c
#include <stdio.h>
#define NORMAL 0
#define SLASH 1
#define INCOMMENT 2
#define ASTERISK 3

int main() {
    int c;
    int state = NORMAL;
    while ((c = getchar()) != EOF) {
        if (state == NORMAL) {
            if (c == '/')
                state = SLASH;
            else putchar(c);    /* copy the input to output */
        }
        else if (state == SLASH) {
            if (c == '*')
                state = INCOMMENT;
            else {
                putchar('/');   /* barfage / */
                putchar(c);     /* copy the input to output */
                state = NORMAL;
            }
        }
        else if (state == INCOMMENT) {
            if (c == '*')
                state = ASTERISK;
        }
        else if (state == ASTERISK) {
            if (c == '/')
                state = NORMAL;
            else state = INCOMMENT;

        }
        else {
            printf("Unknown state %d -- REMOVE_COMMENT", state);
            return 1;           /* error */
        }
    }
    return 0;
}
#+END_SRC

Now let's test! Setup the test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_23.c -o remove_comment
#+END_SRC

#+RESULTS:

Let feed the source file into the resulting program:
#+BEGIN_SRC sh :exports both :results verbatim
cat C_codes/ex1_23.c | ./C_codes/remove_comment
#+END_SRC

#+RESULTS:
#+begin_example
#include <stdio.h>
#define NORMAL 0
#define SLASH 1
#define INCOMMENT 2
#define ASTERISK 3

int main() {
    int c;
    int state = NORMAL;
    while ((c = getchar()) != EOF) {
        if (state == NORMAL) {
            if (c == '/')
                state = SLASH;
            else putchar(c);
        }
        else if (state == SLASH) {
            if (c == '*')
                state = INCOMMENT;
            else {
                putchar('/');
                putchar(c);
                state = NORMAL;
            }
        }
        else if (state == INCOMMENT) {
            if (c == '*')
                state = ASTERISK;
        }
        else if (state == ASTERISK) {
            if (c == '/')
                state = NORMAL;
            else state = INCOMMENT;

        }
        else {
            printf("Unknown state %d -- REMOVE_COMMENT", state);
            return 1;
        }
    }
    return 0;
}
#+end_example

Works as expected.
***** Exercise 1-24
We can classify what we should handle into three parts:
- Syntax that can nest:
  1. parenthesis;
  2. brackets;
  3. braces;
- Syntax that can not nest:
  1. single quotes;
  2. double quotes;
  3. comments;
- Syntax should be treated specially:
  - escape sequences.


Let's think about the behavior our program should have: The specifications we
should implement.

For the syntax that can nest, we want to think as

| Okay case | Ill-defined syntax |
| =[{()}]=  | =[{]}=             |

This example implies that we need to use /stack/ to hold these nested
expressions to check their possible syntax errors.

Stack is the dynamically evolving data structure. However, the only data
structure we have, which contains other expressions in it, is array and that
should be allocated when it is defined in source code, which in turn compiled
and then would be executed; once it defined the array object can not be altered
in their length, so it does not have dynamic process in itself.

To handle this unfortunate, we should notice that this situation is somewhat
familiar; this is exactly same problem we encountered [[*Exercise 1-16][Exercise 1-16]]; but we are
better than then -- now we can use the external variables to wire the
subroutines. Using this combination, we can achevie what we wanted rather
straightforward manner.

As usual, we first figure out what state diagram we want to achieve given task.
For now, we are going to assume that we have stack object to store the nested
bracket things. Then our state specification got simplified: All we need to
keep track of is current state -- in parenthesis or bracket or brace or single
quote or double quote or comment or escape sequences.

The only difference between the expression that can nest or not is that the
nestable expression is current state and another opening syntax consumed, the
current state should be the one encountered syntax and the previous expression
should be stored in stack on the top; on the other hand, if the expression can
not be nested is current state, then the subsequent expression other than
closing expression of the current syntax state are just consumed or, in other
word, ignored.

For the matching the paired syntax is same in both; if stack is not empty after
matching the paired syntax, set the current state to be the one popped from the
stack; if it is empty set the state same as start.

For the special syntax -- escape sequence -- we assume that escape sequence
should consist of two character, backslash to start the sequence and the
following whatever character; this is the only case we have encountered so far.
And we should ensure the escape sequence only occurs in quoted syntax (and in
comment since the inner character in comments are stripped when it handed to
compiler).

Also note that we can include single quotes in double quote syntax but the
opposed case works in unexpected as explained as follows.

#+BEGIN_SRC C :exports both
printf("'hi'");               /* \n */
#+END_SRC

#+RESULTS:
: 'hi'

#+BEGIN_SRC C :exports both
printf("%c", '"hello"');
#+END_SRC

#+RESULTS:

Or if we include more than one characters in between single quotes, we got

#+BEGIN_SRC C :exports both :results verbatim
printf("%c", 'hello');
#+END_SRC

#+RESULTS:
: o

only the last character as value.

Now we ready to draw the state diagram:
#+BEGIN_SRC dot :file C_codes/ex1_24.png :exports results
digraph G {
    rankdir = LR
    label = "While the character is not end of file"
    node[shape = circle]
    start -> nestable [label = "consume opening nestable character"]
    start -> quoted [label = "consume opening quote character"]
    start -> comment [label = "consume opening comment syntax sequence"]
    comment -> start [label = "consume closing comment syntax sequence;\nstack is empty"]
    comment -> nestable [label = "consume closing comment syntax sequence;\nstack is not empty"]
    comment -> comment [label = "consume other than\nclosing comment \nsyntax sequence"]
    start -> start [label = "consume other than special character"]
    quoted -> nestable [label = "consume matched \nquote character;\nstack is not empty"]
    quoted -> quoted [label = "consume other than matched quote character and backslash"]
    quoted -> escape [label = "consume backslash"]
    escape -> quoted [label = "consume one character;\nback to the previous quoted state"]
    quoted -> start [label = "consume matched quote character; stack is empty"]
    nestable -> nestable [label = "consume matched nestable character; stack is not empty"]
    nestable -> start [label = "consume matched character;\nstack is empty"]
    nestable -> nestable [label = "consume another opening nestable character / push current state into the stack"]
    nestable -> nestable [label = "consume normal character -- nor quote, nestable, backslash, comment"]
    nestable -> comment [label = "consume opening comment character"]
    nestable -> quoted [label = "consume opening quoted character"]
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_24.png]]

And here is the skeleton of code:
#+BEGIN_SRC C :main no
#include <stdio.h>

int main() {
    int c = getchar();
    int state;
    while (c != EOF) {
        if (state == START) {
            if (isOpeningQuote(c) || isOpeningNestable(c) || isTransientOpeningComment(c))
                state = c;

            else if (isOpeningEscape(c)){
                return error(c);
            }
            c = getchar();
        }
        else if (isTransientOpeningComment(state)) { /* no consumption of character just set the state */
            if (c == '*')
                state = INCOMMENT;
            else {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
        }
        else if (isTransientClosingComment(state)) { /* same as above since these are transient state */
            if (c == '/') {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
            else
                state = INCOMMENT;
        }
        else if (state == INCOMMENT) {
            if (isTransientClosingComment(c))
                state = c;
            c = getchar();
        }
        else if (isOpeningNestable(state)) {
            if (isOpeningNestable(c) || isOpeningQuote(c) || isTransientOpeningComment(c)) {
                push(state);    /* Push current state to stack */
                state = c;      /* update current */
            }
            else if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c) || isClosingNestable(c)) {
                return error(c);
            }
            c = getchar();
        }
        else if (isOpeningQuote(state)) {
            if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c)) {
                if ((c = getchar()) == EOF) {
                    return error(c);
                }
            }
            c = getchar();
        }
        else                    /* defensive programming */
            return error(c);
    }
    return 0;
}
#+END_SRC

We have to implement each operations we have assumed in above skeleton code.
Except the stack operations, the implementation would be straightforward. For
the test what we've implemented so far, let us replace the stack with static
array -- stack with maximum depth.

#+BEGIN_SRC C :main no :tangle C_codes/ex1_24.c
#include <stdio.h>

#define START 0
#define INCOMMENT 1
#define MAXIMUMDEPTH 1000

/* external varaible -- static stack */
char stack[MAXIMUMDEPTH];
int sp = 0;                     /* current stack point */

int isEmptyStack(void) {
    return sp == 0;
}

char pop(void) {
    --sp;
    return stack[sp];
}

void push(char c) {
    stack[sp] = c;
    ++sp;
}

int error(char c) {
    printf("Unexpected character %c encountered", c);
    return 0;
}

int isOpeningQuote(char c) {
    return c == '\'' || c == '"';
}

int isOpeningNestable(char c) {
    return c == '{' || c == '[' || c == '(';
}

int isClosingNestable(char c) {
    return c == '}' || c == ']' || c == ')';
}

int isTransientOpeningComment(char c) {
    return c == '/';
}

int isOpeningEscape(char c) {
    return c == '\\';
}

int isTransientClosingComment(char c) {
    return c == '*';
}

int isMatched(char o, char c) {
    if (o == '{')
        return c == '}';
    else if (o == '(')
        return c == ')';
    else if (o == '[')
        return c == ']';
    else if (isOpeningQuote(o))
        return c == o;
    else
        return 0;
}

int main() {
    int c = getchar();
    int state = START;
    while (c != EOF) {
        if (state == START) {
            if (isOpeningQuote(c) || isOpeningNestable(c) || isTransientOpeningComment(c))
                state = c;

            else if (isOpeningEscape(c)){
                return error(c);
            }
            c = getchar();
        }
        else if (isTransientOpeningComment(state)) { /* no consumption of character just set the state */
            if (c == '*')
                state = INCOMMENT;
            else {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
        }
        else if (isTransientClosingComment(state)) { /* same as above since these are transient state */
            if (c == '/') {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
            else
                state = INCOMMENT;
        }
        else if (state == INCOMMENT) {
            if (isTransientClosingComment(c))
                state = c;
            c = getchar();
        }
        else if (isOpeningNestable(state)) {
            if (isOpeningNestable(c) || isOpeningQuote(c) || isTransientOpeningComment(c)) {
                push(state);    /* Push current state to stack */
                state = c;      /* update current */
            }
            else if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c) || isClosingNestable(c)) {
                return error(c);
            }
            c = getchar();
        }
        else if (isOpeningQuote(state)) {
            if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c)) {
                if ((c = getchar()) == EOF) {
                    return error(c);
                }
            }
            c = getchar();
        }
        else                    /* defensive programming */
            return error(c);
    }
    if (!isEmptyStack()) {
        stack[sp + 1] = '\0';       /* for printing */
        printf("The stacked nestables are unmatched %s", stack);
    }
    return 0;
}
#+END_SRC

Then let's test!

Setup the test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_24.c -o current
#+END_SRC

#+RESULTS:

Then test:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_24.c | ./C_codes/current
#+END_SRC

#+RESULTS:

Unexpected closing syntax case:
#+BEGIN_SRC sh :exports both
printf "{[}]" | ./C_codes/current
#+END_SRC

#+RESULTS:
: Unexpected character } encountered

General case (well typed syntax):
#+BEGIN_SRC sh :exports both
printf "{([({\'\\x\'})])}" | ./C_codes/current
#+END_SRC

#+RESULTS:

Unmatched quoted syntax case:
#+BEGIN_SRC sh :exports both
printf "{([({\'\\x})])}" | ./C_codes/current
#+END_SRC

#+RESULTS:
: The stacked nestables are unmatched {([({

Unconsumed nested syntax case:
#+BEGIN_SRC sh :exports both
printf "{([({\'\\x\'})]" | ./C_codes/current
#+END_SRC

#+RESULTS:
: The stacked nestables are unmatched {(

#+BEGIN_SRC sh :exports both
printf "{([({\'\\x\'/*})]*/})])}" | ./C_codes/current
#+END_SRC

#+RESULTS:

Now we think of the dynamic stack implementation. This is almost same as
[[*Exercise
1-16][Exercise 1-16]]; this implementation is dirty as those. We should destroy all the
modular function code. I don't want to get bogged down with the gory details to
do that; it is not worth to do. However it is worth to notice that we can
implement the behavior of dynamic stack even with current toolkit although it is
very dirty to read and all the guts of stack leaks out and spoils all other
almost irrelevant code.
** Chapter 2: Types, Operators, and Expressions
:PROPERTIES:
:NOTER_PAGE: 35
:END:
*** Variable Names
*** Data Types and Sizes
**** Exercise 2-1
:PROPERTIES:
:NOTER_PAGE: 36
:END:
First, let's use the standard headers =<limits.h>= and =<float.h>= to find out
the ranges. If we reference the Appendix B to find out those, we came to code as
follows.
#+BEGIN_SRC C :includes <limits.h> <float.h> :results verbatim :exports both
printf("The char type's bits is %d\n", CHAR_BIT);
printf("The char type's minimum value is %d\n", CHAR_MIN);
printf("The char type's maximum value is %d\n", CHAR_MAX);
printf("So the unsigned maximum value of char type is %d\n", UCHAR_MAX);
printf("And the unsigned minimum value of char type is %d\n", 0);

printf("\nThe int type's minimum value is %d\n", INT_MIN);
printf("The int type's maximum value is %d\n", INT_MAX);
printf("So the unsigned maximum value of int type is %ld\n", UINT_MAX);

printf("\nThe short type's minimum value is %d\n", SHRT_MIN);
printf("The short type's maximum value is %d\n", SHRT_MAX);
printf("So the unsigned maximum value of short type is %u\n", USHRT_MAX);

printf("\nThe long type's minimum value is %ld\n", LONG_MIN);
printf("The long type's maximum value is %ld\n", LONG_MAX);
printf("So the unsigned maximum value of long type is %lu\n", ULONG_MAX);

printf("\nThe radix of exponent is %d\n", FLT_RADIX);

printf("\nThe float type's minimum value is %le\n", FLT_MIN);
printf("The float type's maximum value is %le\n", FLT_MAX);
printf("The float type's decimal digits of precision is %d\n", FLT_DIG);
printf("The float type's smallest number to determine whether two number is same is %le\n", FLT_EPSILON);

printf("\nThe double type's minimum value is %le\n", DBL_MIN);
printf("The double type's maximum value is %le\n", DBL_MAX);
printf("The double type's decimal digits of precision is %d\n", DBL_DIG);
printf("The double type's smallest number to determine whether two number is same is %le\n", DBL_EPSILON);
#+END_SRC

#+RESULTS:
#+begin_example
The char type's bits is 8
The char type's minimum value is -128
The char type's maximum value is 127
So the unsigned maximum value of char type is 255
And the unsigned minimum value of char type is 0

The int type's minimum value is -2147483648
The int type's maximum value is 2147483647
So the unsigned maximum value of int type is 4294967295

The short type's minimum value is -32768
The short type's maximum value is 32767
So the unsigned maximum value of short type is 65535

The long type's minimum value is -9223372036854775808
The long type's maximum value is 9223372036854775807
So the unsigned maximum value of long type is 18446744073709551615

The radix of exponent is 2

The float type's minimum value is 1.175494e-38
The float type's maximum value is 3.402823e+38
The float type's decimal digits of precision is 6
The float type's smallest number to determine whether two number is same is 1.192093e-07

The double type's minimum value is 2.225074e-308
The double type's maximum value is 1.797693e+308
The double type's decimal digits of precision is 15
The double type's smallest number to determine whether two number is same is 2.220446e-16
#+end_example

The process via the direct computation, we need to figure out the method to
detect overflow; by assuming that method at our disposal, we can detect allowed
maximum and minimum number of given type only using arithmetic operations.

As we know every data in computer should be represented as bits, in principle,
we can compare the order of any two data if they are in same type. And our
language has no run-time support for overflow, we can assume (or experiment) it
would be wrapped around the limitation, that is, just to ignore the overflowed bit.

Using this observation, we can detect the limitation of number not to be
overflow; this threadhold number is the maximum number in that type.

It's enough word to describe in abstract manner. Now let's turn to concrete code:
#+BEGIN_SRC C :results verbatim :exports both
char c;
char o;
o = 0;
c = 1;
while (o < c)
    o = c++;
printf("The char type's maximum value is %d\n", o);
printf("And the overflowed number got wrapped as %d\n", c);

printf("\nActually this wrapped number is the minimum number of type char. We can show this by\n...");

o = 1;
c = 0;
while (o > c)
    o = c--;
printf("\nThe char type's minimum value is %d\n", o);
printf("And the underflowed number got wrapped as %d\n", c);
#+END_SRC

#+RESULTS:
: The char type's maximum value is 127
: And the overflowed number got wrapped as -128
:
: Actually this wrapped number is the minimum number of type char. We can show this by
: ...
: The char type's minimum value is -128
: And the underflowed number got wrapped as 127

Using this process, we can get those of =int= type:
#+BEGIN_SRC C :results verbatim :exports both
int c;
int o;
o = 0;
c = 1;
while (o < c)
    o = c++;
printf("The int type's maximum value is %d\n", o);
printf("And the overflowed number got wrapped as %d\n", c);

printf("\nActually this wrapped number is the minimum number of type int. We can show this by\n...");

o = 1;
c = 0;
while (o > c)
    o = c--;
printf("\nThe int type's minimum value is %d\n", o);
printf("And the underflowed number got wrapped as %d\n", c);
#+END_SRC

#+RESULTS:
: The int type's maximum value is 2147483647
: And the overflowed number got wrapped as -2147483648
:
: Actually this wrapped number is the minimum number of type int. We can show this by
: ...
: The int type's minimum value is -2147483648
: And the underflowed number got wrapped as 2147483647

We can apply exactly same idea into all of non-floating-point types.

For the floating-point types, we should use multiplication rather than addition
since floating-point numbers has exponent part in it; and this exponent part
mainly determines the range of that type:

#+BEGIN_SRC C :results verbatim :exports both
float c;
float o;
o = 1.0;
c = 10.0;
while (o < c) {
    o = c;
    c = 10.0 * c;
}

printf("The float type's maximum value is %le\n", o);
printf("And the overflowed number got wrapped as %le\n", c);

printf("\nActually this wrapped number is the minimum number of type float. We can show this by\n...");

o = 10.0;
c = 1.0;
while (o > c) {
    o = c;
    c = c / 10.0;
}
printf("\nThe float type's minimum value is %le\n", o);
printf("And the underflowed number got wrapped as %le\n", c);
#+END_SRC

#+RESULTS:
: The float type's maximum value is inf
: And the overflowed number got wrapped as inf
:
: Actually this wrapped number is the minimum number of type float. We can show this by
: ...
: The float type's minimum value is 0.000000e+00
: And the underflowed number got wrapped as 0.000000e+00

Oops.. Turns out it doesn't works as expected; I could not come up with the good
way to detect the overflow of floating-point type as it has =inf= notation for
that.
*** Constants
*** Declarations
*** Arithmetic Operations
*** Relational and Logical Operators
**** Exercise 2-2
:PROPERTIES:
:NOTER_PAGE: 41
:END:

We can achieve the same behavior using the more primitive control method,
flagging:
#+BEGIN_SRC C
int i;
int flag = 0;
for (i = 0; !flag; ++i) {
    if (i < lim - 1) {
        if ((c = getchar()) ! = '\n') {
            if (c != EOF)
                s[i] = c;
            else flag = 1;
        }
        else flag = 1;
    } else flag = 1;
}
#+END_SRC
*** Type Conversions
:PROPERTIES:
:NOTER_PAGE: 41
:END:
**** Exercise 2-3
This function would be analogous to =atoi=; but involving more subtle details.
1. It should consume character representing "0x" or "0X";
2. then it should take character representing decimal digits in addition to
   alphabets 'a' to 'f' and also 'A' to 'F';
3. the rest is almost same process as =atoi=.


Here is the code do the works:
#+BEGIN_SRC C :main no :includes <stdio.h> :exports both :results verbatim
int isDecimalCharacter(int c) {
    return c >= '0' && c <= '9';
}
int isHexaDecimalCharacter(int c) {
    return isDecimalCharacter(c)
        || c >= 'a' && c <= 'f'
        || c >= 'A' && c <= 'F';
}

int hexToInt(int c) {
    if (isDecimalCharacter(c))
        return c - '0';
    else if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    else
        return c - 'A' + 10;
}

/* htoi: convert s which representing hexadecial number to integer */
int htoi(char s[])
{
    int i, n;

    n = 0;
    if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) /* check the first two character */
        for (i = 2; isHexaDecimalCharacter(s[i]); ++i)
            n = 16 * n + hexToInt(s[i]);
    return n;
}

int main(void) {
    char hex[] = "0xffaff";
    printf("The hexadecial string %s got converted as %d\n", hex, htoi(hex));
    printf("It should be %d", 0xffaff);
    return 0;
}
#+END_SRC

#+RESULTS:
: The hexadecial string 0xffaff got converted as 1047295
: It should be 1047295
*** Increment and Decrement Operators
**** Exercise 2-4
:PROPERTIES:
:NOTER_PAGE: 46
:END:

This is quite straightforward function; so let me just code it:
#+BEGIN_SRC C :main no :exports both :results verbatim
/* isMember: check whether c is in s */
int isMember(char c, char s[]) {
    int i;
    for (i = 0; s[i] != '\0'; ++i)
        if (c == s[i])
            return 1;
    return 0;
}
/* test isMember */
int main(void) {
    char c = 's';
    char c2 = 'c';
    char s[] = "string";
    printf("character %c is in %s?\n%d\n", c, s, isMember(c, s));
    printf("character %c is in %s?\n%d\n", c2, s, isMember(c2, s));
    return 0;
}
#+END_SRC

#+RESULTS:
: character s is in string?
: 1
: character c is in string?
: 0

#+BEGIN_SRC C :main no :exports both :results verbatim
/* isMember: check whether c is in s */
int isMember(char c, char s[]) {
    int i;
    for (i = 0; s[i] != '\0'; ++i)
        if (c == s[i])
            return 1;
    return 0;
}
/* squeeze: delete all characters from s1 which matches in s2 */
void squeeze(char s1[], char s2[]) {
    int i, j;

    for (i = j = 0; s1[i] != '\0'; ++i)
        if ((!isMember(s1[i], s2)))
            s1[j++] = s1[i];
    s1[j] = '\0';
}
/* test squeeze */
int main(void) {
    char s1[] = "string";
    char s2[] = "character";
    squeeze(s1, s2);
    printf("string %s is squeezed using %s",s1, s2);
    return 0;
}
#+END_SRC

#+RESULTS:
: string sing is squeezed using character
**** Exercise 2-5
As this behavior has many commonality with preceding exercise, we can exploit
this fact:

#+BEGIN_SRC C :main no :exports both :results verbatim

/* isMember: check whether c is in s */
int isMember(char c, char s[]) {
    int i;
    for (i = 0; s[i] != '\0'; ++i)
        if (c == s[i])
            return 1;
    return 0;
}
/* any: find the first location in s1 where any character is in s2 */
int any(char s1[], char s2[]) {
    int i;

    for (i = 0; s1[i] != '\0'; ++i)
        if (isMember(s1[i], s2))
            return i;
    return -1;
}
/* test any */
int main(void) {
    char s1[] = "string";
    char s2[] = "character";
    int ind = any(s1, s2);
    if (ind >= 0){
        printf("character %c in %s is found at %d, which is in %s",
               s1[ind], s1, ind, s2);
    }
    return 0;
}
#+END_SRC

#+RESULTS:
: character t in string is found at 1, which is in character
*** Bitwise Operators
:PROPERTIES:
:NOTER_PAGE: 46
:END:
**** Exercise 2-6
:PROPERTIES:
:NOTER_PAGE: 47
:END:

We can achieve what we want by taking the bits in specificed range from =y= and
for else from =x= and set that to =x=; for the task of tearing off the
specificed range's bits, we can apply the idea of =getbits=:

#+BEGIN_SRC C :main no :includes <stdio.h>
/* setbits: set n bits of x from position p to those of y */
unsigned setbits(unsigned x, int p, int n, unsigned y) {
    unsigned mask = ~(~0 << n) << (p + 1 - n);
    return x = x & ~mask | (y << (p + 1 - n)) & mask;
}

int main(void) {
    unsigned int x = 0xff;
    unsigned int y = 0;
    printf("x got setbits with y results in %x", setbits(x, 3, 4, y));
    return 0;
}
#+END_SRC

#+RESULTS:
: x got setbits with y results in f0
**** Exercise 2-7
It is more simpler than preceding one:

#+BEGIN_SRC C :main no :includes <stdio.h>
/* invert: returns x with the n bits inverted that begin at position p */
unsigned invert(unsigned x, int p, int n) {
    unsigned mask = ~(~0 << n) << (p + 1 - n);
    return x = x ^ mask;
}

int main(void) {
    unsigned int x = 0xff;
    printf("x got inverted results in %x", invert(x, 3, 4));
    return 0;
}
#+END_SRC

#+RESULTS:
: x got inverted results in f0
**** Exercise 2-8
We can define =rightrot= function to be machine-independent by checking the bits
of =int= type before operates on; the checking process could require linear time
with respect to the bit number of =int= or constant if we use =sizeof=
operater. This is analogous situation we encountered in [[*Exercise 2-1][Exercise 2-1]]:
#+BEGIN_SRC C :main no :includes <stdio.h> :exports both
int rightrot(int x, int n) {
    int wrapped = ~(~0 << n) & x;
    return (x >> n) | (wrapped << (8 * sizeof(int) - n));
}

int main(void) {
    int x = 1;
    printf("The integer %d should be same as %d",
           x, rightrot(rightrot(x, x), (8 * sizeof(int) - x)));
    return 0;
}
#+END_SRC

#+RESULTS:
: The integer 1 should be same as -1

Unfortunately, the shift function works differently in =int= from =unsigned= as
above assertion fails. So we need to use =unsigned= rather than =int= in
=rightrot='s automatic variables.

#+BEGIN_SRC C :main no :includes <stdio.h> :exports both
int rightrot(unsigned int x, int n) {
    int intBits = 8 * sizeof(int);
    int rotatingN = n % intBits; /* to deal with the numbers greater than bits */
    return (x >> rotatingN) | (x << (intBits - rotatingN));
}

int main(void) {
    int x = 1;
    printf("The integer %d should be same as %d",
           x, rightrot(rightrot(x, x), (8 * sizeof(int) - x)));
    return 0;
}
#+END_SRC

#+RESULTS:
: The integer 1 should be same as 1

We have coped with the overflowed shifting number in the above final implementation.
*** Assignment Operators and Expressions
**** Exercise 2-9
:PROPERTIES:
:NOTER_PAGE: 48
:END:

Here we try to prove the observation by case analysis:
- If the rightmost 1 bit positions at n > 0, and let =x= be
  /X_{n}...X_{0}10...0/ then =x-1= is represented in two's complement number
  system as /X_{n}...X_{0}01...1/; so =x & x-1= be /X_{n}...X_{0}00...0/ as
  asserted;
- if the rightmost 1 bit positions at n = 0, and let =x= be
  /X_{n}...X_{0}1/ then =x-1= is represented in two's complement number system
  as /X_{n}...X_{0}0/; so =x & x-1= be /X_{n}...X_{0}0/ as asserted;
- finally, if there is no rightmost 1 bit, that is, 0 represented in two's
  complement number system, =x= is represented as /0...0/ and =x-1= is
  represented /1...1/; so =x & x-1= be /0...0/ as asserted.


As we proved the observation (although in informal manner), we are good to use
this fact to improve the efficiency of program:
#+BEGIN_SRC C :main no
/* bitcount: count 1 bits in x */
int bitcount(unsigned x) {
    int b;

    for (b = 0; x != 0; x &= x - 1)
        ++b;
    return b;
}
#+END_SRC

Now the loop executed =b= times rather than the index of leftmost 1 bit times.
*** Conditional Expressions
:PROPERTIES:
:NOTER_PAGE: 49
:END:

**** Exercise 2-10
#+BEGIN_SRC C :main no
int lower(int c) {
    return (c >= 'A' && c <= 'Z' ? c + 'a' - 'A' : c);
}
#+END_SRC

** Chapter 3 - Control Flow
:PROPERTIES:
:NOTER_PAGE: 52
:END:

*** Else-If
:PROPERTIES:
:NOTER_PAGE: 54
:END:

**** Exercise 3-1
:PROPERTIES:
:NOTER_PAGE: 54
:END:

Since now we have only one test in the loop, we can not detect the immediate
answer; we can only halve the search space in each loop.

To implement this new strategy, we need to use the following observation: The
search space should pass through only one before falls back to the failure.
Using this observation we can detect what is the case where given =x= is found
in given search space or not -- if after the loop, the =low= and =high= equals
each other, it means the given item is found in the search space, otherwise not:
#+BEGIN_SRC C :main no
int binsearch(int x, int v[], int n) {
    int low, high, mid;

    low = 0;
    high = n - 1;
    while (low + 1 < high) {
        mid = (low + high) / 2;
        if (x < v[mid])
            high = mid - 1;
        else
            low = mid;
    }
    if (v[mid] == x)
        return mid;
    else
        return -1;
}
/* test new binsearch process */
int main(void) {
    int test[10];
    int i = 0;
    while (i < 10)              /* initialize */
        test[i] = i++;
    i = 3;                      /* test integer */
    printf("the test integer %d found in index %d at test search space",
           i, binsearch(i, test, 10));
    return 0;
}
#+END_SRC

Unfortunately this version won't work in two reason:
- The initialization does not work as expected. It just fails.
- The =binsearch= we implemented in above, missed the case where =low= \le
  =high= and ~v[mid] >= x~, where the search space does not converge to just one.


Let alone the analysis why those things happened; let's fix those with
alternative way:

#+BEGIN_SRC C :main no :exports both :results verbatim
int binsearch(int x, int v[], int n) {
    int low, high, mid;

    low = 0;
    high = n - 1;
    while (low < high) {
        mid = (low + high) / 2; /* Reduce the high */
        if (x > v[mid])
            low = mid + 1;
        else
            high = mid;
    }
    if (x == v[low])            /* search space became just one */
        return low;
    else
        return -1;
}
/* test new binsearch process */
int main(void) {
    int test[10];
    int i;
    for (i = 0; i < 10; ++i)
        test[i] = i;
    i = 1;                      /* test integer */
    printf("the test integer %d found in index %d at test search space",
           i, binsearch(i, test, 10));
    return 0;
}
#+END_SRC

#+RESULTS:
: the test integer 1 found in index 1 at test search space

Now it works as expected. Then let's think about why those malfunction has
happend in previous version:
- For the initialization problem, we have assumed the of assignment would
  proceed left to right, which depends on implementation detail; so it is
  possible that we have tried to mutate the overflowed indexed element; we
  shouldn't program like that. So we have turned to another way, =for= loop,
  that does not depend on the implementation detail.
- For the search space problem, we should notice that integer division can be
  used to reduce the upper limit of search space implicitly; but not in the
  other way around -- reduce the search space by increasing the lower limit of
  that when the search space come to have just 2 elements in it.


For the other issues that observed at the entry point of this exercise, those
still hold, that is, in that the search space should always be reduced down to
just having one element in that range; no immediate exits with result.

*** Switch
**** Exercise 3-2
For simplicity, here we are going to cope with escape sequences of newline and
horizontal tab. In the abstract level, it would be easier to design the
algorithm using state transition diagram; for the implementation detail, we will
use two indices to keep track of the current looks of two character array, =s=
and =t=.

#+BEGIN_SRC C :main no :includes <stdio.h> :exports both :results verbatim
void escape(char s[],char t[]) {
    int i,j;
    for (i = j = 0; t[j] != '\0'; ++j) {
        switch (t[j]) {
            case '\n':
                s[i++] = '\\';
                s[i++] = 'n';
                break;
            case '\t':
                s[i++] = '\\';
                s[i++] = 't';
                break;
            default:
                s[i++] = t[j];
                break;

        }
    }
    s[i] = '\0';
}

int main(void) {
    char test[] = "test\ncase\n\tlike\tthis";
    char to[30];
    escape(to, test);
    printf("%s got escaped to %s", test, to);
    return 0;
}
#+END_SRC

#+RESULTS:
: test
: case
: 	like	this got escaped to test\ncase\n\tlike\tthis
*** Loops -- While and For
**** Exercise 3-3
We, as usual, will implement the task using state transition diagram. I think it
is usual process dealing with C programming.

First, we should make the specification concrete: We only going to treat given
expression as shorthand notation if the forehand character precedes the latter
in comparison operation and both are in same type -- alphabet or decimal digit.

Then let's code it (the state diagram is drawn in my digital paper)!
#+BEGIN_SRC C :main no :exports both :results verbatim
#include <stdio.h>
#include <ctype.h>

#define START -1

int isSameTypeAndPrecede(char c1, char c2) {
    return c1 < c2 && (isdigit(c1) ? isdigit(c2)
                       : islower(c1) ? islower(c2)
                       : isupper(c1) ? isupper(c2)
                       : 0);
}

void expand(char s1[], char s2[]) {
    int state = START;
    int i, j, k;
    for (i = j = 0; s1[i] != '\0'; ++i) {
        if (state == START) {
            if (isalnum(s1[i]))
                state = s1[i];
            else if (s1[i] == '-') {
                s2[j++] = s1[i];
                state = '-';
            }
            else {
                printf("error: Unexpected state %d", state);
                return;
            }
        }
        else if (state == '-') {
            s2[j++] = s1[i];
            state = START;
        }
        else if (isalnum(state)) {
            if (s1[i] == '-') {
                if (isSameTypeAndPrecede(state, s1[i + 1]) && s1[i + 2] != '-') { /* look ahead */
                    ++i;
                    for (k = state; k <= s1[i]; k++) /* expand */
                        s2[j++] = k;
                    state = START;
                }
                else {
                    s2[j++] = state;
                    s2[j++] = '-';
                    state = '-';
                }
            }
            else {
                s2[j++] = state;
                s2[j++] = s1[i];
                state = START;
            }
        }
        else {
            printf("error: Unexpected state %d", state);
            return;
        }
    }
    s2[j] = '\0';               /* end of string */
}

int main(void) {
    char test[] = "a-b-c";
    char test2[] = "-a-z";
    char test3[] = "a-z0-9";
    char test4[] = "-a-z0-9";
    char expanded[150];
    expand(test, expanded);
    printf("%s\ngot expanded to\n%s\n", test, expanded);
    expand(test2, expanded);
    printf("%s\ngot expanded to\n%s\n", test2, expanded);
    expand(test3, expanded);
    printf("%s\ngot expanded to\n%s\n", test3, expanded);
    expand(test4, expanded);
    printf("%s\ngot expanded to\n%s\n", test4, expanded);
    return 0;
}
#+END_SRC

#+RESULTS:
#+begin_example
a-b-c
got expanded to
a-b-c
-a-z
got expanded to
-a-z
a-z0-9
got expanded to
abcdefghijklmnopqrstuvwxyz0123456789
-a-z0-9
got expanded to
-a-z0123456789
#+end_example

The ambiguity remains in this implementation: What should we return in the last
case? For simplicity let us satisfy with current result.
*** Loops -- Do-while
**** Exercise 3-4
Since the inverted largest negative number is itself in two's complement number
system:
#+BEGIN_SRC C :includes <stdio.h> <limits.h> :exports both :results verbatim
int largestNeg = INT_MIN;
int inverted = - largestNeg;
printf("The largest negative number %d got inverted to %d", largestNeg, inverted);
#+END_SRC

#+RESULTS:
: The largest negative number -2147483648 got inverted to -2147483648

Since this is the specific phenomenon for two's complement number system, we can
also this fact to fix this: The largest negative number never ends with 9.

Then the code got
#+BEGIN_SRC C :main no :includes <stdio.h> <string.h> <limits.h> :exports both :results verbatim
void reverse(char s[]) {
    int c, i, j;
    for (i =0, j = strlen(s) - 1; i < j; i++, j--)
        c = s[i], s[i] = s[j], s[j] = c;
}

void itoa(int n, char s[]) {
    int i, sign;
    int overflow = 0;

    if ((sign = n) < 0)
        if ((n = -n) < 0) {
            n = - (sign + 1);
            overflow = 1;
        }
    i = 0;
    s[i++] = n % 10 + '0' + (overflow ? 1 : 0);
    while ((n /= 10) > 0)
        s[i++] = n % 10 + '0';
    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
}

int main(void) {
    char test[30];
    int neg = INT_MIN;
    itoa(neg, test);
    printf("%d got stringified to %s", neg, test);
    return 0;
}
#+END_SRC

#+RESULTS:
: -2147483648 got stringified to -2147483648
**** Exercise 3-5
Here is also ambiguity in the specification: We should accept only 8, 16, 10,
those handled by C language as number or should we accept whatever base number
that we can afford to support? Reasonable limit of that would be 36 -- number of
alphabet + digit.

Here we are going to take the latter approach.

#+BEGIN_SRC C :main no :includes <stdio.h> <string.h> <limits.h> :defines THREADHOLD 10
void reverse(char s[]) {
    int c, i, j;
    for (i =0, j = strlen(s) - 1; i < j; i++, j--)
        c = s[i], s[i] = s[j], s[j] = c;
}

void itob(int n, char s[], int b) {
    int i, sign, remains;

    if ((sign = n) < 0)
        n = -n;
    i = 0;
    do {
        remains = n % b;
        s[i++] = (remains >= 10) ? remains - 10 + 'a' : remains + '0';
    } while ((n /= b) > 0);
    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
}

int main(void) {
    char test[30];
    int hex = - 0xaff;
    itob(hex, test, 16);
    printf("%x got stringified to %s", hex, test);
    return 0;
}
#+END_SRC

#+RESULTS:
: fffff501 got stringified to -aff

Works as expected; we have not coped with the largest negative number. If we
wanted to do, we could implement that way but this implementation not going to
be efficient as before -- it would cause overhead in loop; as it is not required
in this exercise, let us satisfy with above version.
**** Exercise 3-6

It just need slight modification to the end:
#+BEGIN_SRC C :main no :includes <stdio.h> <string.h> <limits.h> :exports both :results verbatim
void reverse(char s[]) {
    int c, i, j;
    for (i =0, j = strlen(s) - 1; i < j; i++, j--)
        c = s[i], s[i] = s[j], s[j] = c;
}

void itoa(int n, char s[], int min) {
    int i, sign;
    int overflow = 0;

    if ((sign = n) < 0)
        if ((n = -n) < 0) {
            n = - (sign + 1);
            overflow = 1;
        }
    i = 0;
    s[i++] = n % 10 + '0' + (overflow ? 1 : 0);
    while ((n /= 10) > 0)
        s[i++] = n % 10 + '0';
    if (sign < 0)
        s[i++] = '-';
    while (i < min)
        s[i++] = ' ';
    s[i] = '\0';
    reverse(s);
}

int main(void) {
    char test[30];
    int neg = INT_MIN;
    int minimumWidth = 30;
    itoa(neg, test, minimumWidth);
    printf("%d got stringified with minimum width %d to\n%s", neg, minimumWidth, test);
    return 0;
}
#+END_SRC

#+RESULTS:
: -2147483648 got stringified with minimum width 30 to
:                    -2147483648
*** Break and Continue
*** Goto and Labels
** Chapter 4 -- Functions and Program Structure
:PROPERTIES:
:NOTER_PAGE: 62
:END:
*** Basics of Functions
**** Exercise 4-1
There are two possibilities how we implement the code:
- Use reverse and use the =strindex= to find -- this method should resolve the
  "beginning" index problem from using the underlying =stdindex= process.
- Alter =strindex= to start to search from right most possible index.


Here we are going to take the second approach since it is more straightforward
and efficient.

#+BEGIN_SRC C :main no :exports both :results verbatim
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int strrindex(char source[], char searchfor[]);

char pattern[] = "ould";

main() {
    char line[MAXLINE] = "Could would re-mould would";
    printf("From string\n%s\nthe string %s is found at index %d",
           line, pattern, strrindex(line, pattern));
    return 0;
}

int strrindex(char s[], char t[]) {
    int i, j, k;

    for (i = strlen(s) - strlen(t); s[i] != '\0'; i--) {
        for (j=i, k=0; t[k] != '\0' && s[j] == t[k]; j++, k++)
            ;
        if (k > 0 && t[k] == '\0')
            return i;
    }
    return -1;
}
#+END_SRC

#+RESULTS:
: From string
: Could would re-mould would
: the string ould is found at index 22

Works as expected.
*** Functions Returning Non-integers
**** Exercise 4-2
It is straightforward to implement with the help of =pow=:
#+BEGIN_SRC C :main no :exports both
#include <ctype.h>
#include <math.h>

double atof(char s[]) {
    double val, power;
    int i, sign, expSign, exp;

    for (i = 0; isspace(s[i]); i++)
        ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')
        i++;
    for (val = 0.0; isdigit(s[i]); i++)
        val = 10.0 * val + (s[i] - '0');
    if (s[i] == '.')
        i++;
    for (power = 1.0; isdigit(s[i]); i++) {
        val = 10.0 * val + (s[i] - '0');
        power *= 10.0;
    }
    if (s[i] == 'e')
        i++;
    expSign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')
        i++;
    for (exp = 0; isdigit(s[i]); i++)
        exp = 10 * exp + (s[i] - '0');
    return sign * val / power * pow(10, expSign * exp);
}

int main(void) {
    char s[] = "123.45e-6";
    printf("string %s got transformed with atof as %.8f", s, atof(s));
}
#+END_SRC

#+RESULTS:
: string 123.45e-6 got transformed with atof as 0.00012345
*** External Variables
#+BEGIN_SRC C :tangle C_codes/sec4_3.c :main no
#include <stdio.h>
#include <stdlib.h>             /* for atof() */

#define MAXOP 100               /* max size of operand or operator */
#define NUMBER '0'              /* signal that a number was found */

int getop(char []);
void push (double);
double pop(void);

/* reverse Polish calculator */
main() {
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
        switch (type) {
            case NUMBER:
                push(atof(s));
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            case '\n':
                printf("\t%.8g\n", pop());
                break;
            default:
                printf("error: unknown command %s\n", s);
                break;
        }
    }
    return 0;
}

#define MAXVAL 100              /* maximum depth of val stack */

int sp = 0;                     /* next free stack position */
double val[MAXVAL];             /* value stack */

/* push: push f onto value stack */
void push(double f) {
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

double pop(void) {
    if (sp > 0)
        return val[--sp];
    else {
        printf("error: stack empty\n");
        return 0.0;
    }
}

#include <ctype.h>

int getch(void);
void ungetch(int);

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
        return c;               /* not a number */
    i = 0;
    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        ungetch(c);
    return NUMBER;
}

#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */

int getch(void) {               /* get a (possibly pushed back) character */
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}
#+END_SRC

Let's test:
#+BEGIN_SRC sh
cd C_codes
cc sec4_3.c -o expr
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
echo "1 2 - 4 5 + *" | ./C_codes/expr
echo "1.34 1.87 - 4 5 + *" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	-9
: 	-4.77

**** Exercise 4-3
We are going to treat negative number as the number prefixed with "-", no space
between the number and minus sign.

#+BEGIN_SRC C :tangle C_codes/ex4_3.c :main no


#include <stdio.h>
#include <stdlib.h>             /* for atof() */

#define MAXOP 100               /* max size of operand or operator */
#define NUMBER '0'              /* signal that a number was found */

int getop(char []);
void push(double);
double pop(void);
int isInt(double);

/* reverse Polish calculator */
main() {
    int type, intop2;
    double op2;

    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
        switch (type) {
            case NUMBER:
                push(atof(s));
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            case '%':
                op2 = pop();
                if (isInt(op2) && (intop2 = op2) && isInt(op2 = pop())) /* integer check & zero check of second argument */
                    push((int) op2 % intop2);
                else
                    printf("error: arguments to moduls are not proper\n");
                break;
            case '\n':
                printf("\t%.8g\n", pop());
                break;
            default:
                printf("error: unknown command %s\n", s);
                break;
        }
    }
    return 0;
}

#define MAXVAL 100              /* maximum depth of val stack */

int sp = 0;                     /* next free stack position */
double val[MAXVAL];             /* value stack */

/* push: push f onto value stack */
void push(double f) {
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

double pop(void) {
    if (sp > 0)
        return val[--sp];
    else {
        printf("error: stack empty\n");
        return 0.0;
    }
}

#include <ctype.h>

int getch(void);
void ungetch(int);

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';

    i = 0;                      /* char array to be stored index */

    if (!isdigit(c) && c != '.') {
        if (c != '-' && c != '+')
            return c;           /* not a number */
        else if (isdigit(s[1] = c = getch()))
            i = 2;              /* is number */
        else {
            ungetch(c);         /* push back over consumed character */
            return c = s[0];
        }
    }

    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        ungetch(c);
    return NUMBER;
}

#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */

int getch(void) {               /* get a (possibly pushed back) character */
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}

int isInt(double num) {
    int converted = num;
    return (double) converted == num;
}
#+END_SRC

Let's test:
#+BEGIN_SRC sh
cd C_codes
cc ex4_3.c -o expr
#+END_SRC

#+RESULTS:


Negative number test:
#+BEGIN_SRC sh :exports both :results verbatim
echo "1 -2 + 4 5 + *" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	-9

Modulus operation test:
#+BEGIN_SRC sh :exports both :results verbatim
echo "1 4 + 3 %" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	2

And error test:

#+BEGIN_SRC sh :exports both :results verbatim
echo "1.1 4 + 3 %" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: error: arguments to moduls are not proper
: error: stack empty
: 	0

#+BEGIN_SRC sh :exports both :results verbatim
echo "5 -2 + 2 -2 + %" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: error: arguments to moduls are not proper
: 	3
**** Exercise 4-4

#+BEGIN_SRC C :tangle C_codes/ex4_4.c :main no


#include <stdio.h>
#include <stdlib.h>             /* for atof() */

#define MAXOP 100               /* max size of operand or operator */
#define NUMBER '0'              /* signal that a number was found */

int getop(char []);
void push(double);
double pop(void);
void showTop(void);
void duplicate(void);
void swapTops(void);
void initStack(void);
int isInt(double);

/* reverse Polish calculator */
main() {
    int type, intop2;
    double op2;

    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
        switch (type) {
            case NUMBER:
                push(atof(s));
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            case '%':
                op2 = pop();
                if (isInt(op2) && (intop2 = op2) && isInt(op2 = pop())) /* integer check & zero check of second argument */
                    push((int) op2 % intop2);
                else
                    printf("error: arguments to moduls are not proper\n");
                break;
            case 't':
                showTop();
                break;
            case 'd':
                duplicate();
                break;
            case 's':
                swapTops();
                break;
            case 'i':
                initStack();
                break;
            case '\n':
                printf("\t%.8g\n", pop());
                break;
            default:
                printf("error: unknown command %s\n", s);
                break;
        }
    }
    return 0;
}

#define MAXVAL 100              /* maximum depth of val stack */

int sp = 0;                     /* next free stack position */
double val[MAXVAL];             /* value stack */

/* push: push f onto value stack */
void push(double f) {
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

double pop(void) {
    if (sp > 0)
        return val[--sp];
    else {
        printf("error: stack empty\n");
        return 0.0;
    }
}

void showTop(void) {
    if (sp > 0)
        printf("The top element of stack is %.8g\n", val[sp - 1]);
    else {
        printf("error: stack empty\n");
    }
}

void duplicate(void) {
    if (sp > 0) {
        double temp = pop();
        push(temp);
        push(temp);
    }
    else
        printf("error: stack empty\n");
}

void swapTops(void) {
    if (sp > 1) {
        double temp = pop();
        double temp2 = pop();
        push(temp);
        push(temp2);
    }
    else
        printf("error: stack has less element than 2\n");
}

void initStack(void) {
    sp = 0;
}

#include <ctype.h>

int getch(void);
void ungetch(int);

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';

    i = 0;                      /* char array to be stored index */

    if (!isdigit(c) && c != '.') {
        if (c != '-' && c != '+')
            return c;           /* not a number */
        else if (isdigit(s[1] = c = getch()))
            i = 2;              /* is number */
        else {
            ungetch(c);         /* push back over consumed character */
            return c = s[0];
        }
    }

    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        ungetch(c);
    return NUMBER;
}

#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */

int getch(void) {               /* get a (possibly pushed back) character */
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}

int isInt(double num) {
    int converted = num;
    return (double) converted == num;
}
#+END_SRC
#+RESULTS:

#+BEGIN_SRC sh
cd C_codes
cc ex4_4.c -o expr
#+END_SRC

#+RESULTS:

Stack initialization & show top test:
#+BEGIN_SRC sh :exports both :results verbatim
echo "1 4 + t i 3 4 +" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: The top element of stack is 5
: 	7

Swap test:
#+BEGIN_SRC sh :exports both :results verbatim
echo "1 4 + t 3 4 + t s -" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: The top element of stack is 5
: The top element of stack is 7
: 	2

Duplicate test:
#+BEGIN_SRC sh :exports both :results verbatim
echo "1 4 + d +" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	10
**** Exercise 4-5

#+BEGIN_SRC C :tangle C_codes/ex4_5.c :main no


#include <stdio.h>
#include <stdlib.h>             /* for atof() */
#include <math.h>               /* for sin, exp and pow */

#define MAXOP 100               /* max size of operand or operator */
#define NUMBER '0'              /* signal that a number was found */

int getop(char []);
void push(double);
double pop(void);
void showTop(void);
void duplicate(void);
void swapTops(void);
void initStack(void);
int isInt(double);

/* reverse Polish calculator */
main() {
    int type, intop2;
    double op2;

    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
        switch (type) {
            case NUMBER:
                push(atof(s));
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            case '%':
                op2 = pop();
                if (isInt(op2) && (intop2 = op2) && isInt(op2 = pop())) /* integer check & zero check of second argument */
                    push((int) op2 % intop2);
                else
                    printf("error: arguments to moduls are not proper\n");
                break;
            case 's':           /* sin */
                push(sin(pop()));
                break;
            case 'e':           /* exp */
                push(exp(pop()));
                break;
            case 'p':           /* pow */
                op2 = pop();
                push(pow(pop(), op2));
                break;
            case '?':
                showTop();
                break;
            case '#':
                duplicate();
                break;
            case '~':
                swapTops();
                break;
            case '^':
                initStack();
                break;
            case '\n':
                printf("\t%.8g\n", pop());
                break;
            default:
                printf("error: unknown command %s\n", s);
                break;
        }
    }
    return 0;
}

#define MAXVAL 100              /* maximum depth of val stack */

int sp = 0;                     /* next free stack position */
double val[MAXVAL];             /* value stack */

/* push: push f onto value stack */
void push(double f) {
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

double pop(void) {
    if (sp > 0)
        return val[--sp];
    else {
        printf("error: stack empty\n");
        return 0.0;
    }
}

void showTop(void) {
    if (sp > 0)
        printf("The top element of stack is %.8g\n", val[sp - 1]);
    else {
        printf("error: stack empty\n");
    }
}

void duplicate(void) {
    if (sp > 0) {
        double temp = pop();
        push(temp);
        push(temp);
    }
    else
        printf("error: stack empty\n");
}

void swapTops(void) {
    if (sp > 1) {
        double temp = pop();
        double temp2 = pop();
        push(temp);
        push(temp2);
    }
    else
        printf("error: stack has less element than 2\n");
}

void initStack(void) {
    sp = 0;
}

#include <ctype.h>

int getch(void);
void ungetch(int);

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';

    i = 0;                      /* char array to be stored index */

    if (!isdigit(c) && c != '.') {
        if (c != '-' && c != '+')
            return c;           /* not a number */
        else if (isdigit(s[++i] = c = getch()))
            ++i;                /* is number */
        else {                  /* not a number */
            if (c != EOF)
                ungetch(c);     /* push back over consumed character */
            return c = s[0];
        }
    }

    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        ungetch(c);
    return NUMBER;
}

#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */

int getch(void) {               /* get a (possibly pushed back) character */
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}

int isInt(double num) {
    int converted = num;
    return (double) converted == num;
}
#+END_SRC


To cope with the recognizing the operator, here, we used first letter of
operation, causing the changes of the previous stack operations into non-alphabet
characters.

#+BEGIN_SRC sh
cd C_codes
cc ex4_5.c -o expr
#+END_SRC

#+RESULTS:

Power function test:
#+BEGIN_SRC sh :exports both :results verbatim
echo "2 3 p" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	8
**** Exercise 4-6
We are going to use single upper case letter as variable (along with the advice
in the text). To remove the ambiguity what it should do when it receive variable
singal, we have used prefix notation rather than postfix in setting variable
operation.

#+BEGIN_SRC C :tangle C_codes/ex4_6.c :main no


#include <stdio.h>
#include <stdlib.h>             /* for atof() */
#include <math.h>               /* for sin, exp and pow */

#define MAXOP 100               /* max size of operand or operator */
#define NUMBER '0'              /* signal that a number was found */
#define VARIABLE '\0'

int getop(char []);
void push(double);
double pop(void);
void showTop(void);
void duplicate(void);
void swapTops(void);
void initStack(void);
int isInt(double);

/* reverse Polish calculator */
main() {
    int type, intop2;
    double op2;
    double vars['Z' - 'A' + 1]; /* the storage of variables */
    char isdefined['Z' - 'A' + 1]; /* flag for defined variables */
    int setvar = -1;               /* state for setting variable */
    double lastValue = 0.0;        /* last printed value */
    char everPrinted = 0;
    char s[MAXOP];

    int i;

    for (i = 0; i < 'Z' - 'A' + 1; ++i) /* initialize the defined flag */
        isdefined[i] = 0;

    while ((type = getop(s)) != EOF) {
        switch (type) {
            case NUMBER:
                if (setvar > 0)
                    vars[setvar - 'A'] = atof(s), isdefined[setvar - 'A'] = 1, setvar = -1;
                else if (setvar == -1)
                    push(atof(s));
                else printf("error: = called with non-variable\n");
                break;
            case VARIABLE:
                if (setvar == 0)
                    setvar = s[0];
                else if (isdefined[s[0] - 'A'])
                    if (setvar > 0)
                        vars[setvar - 'A'] = vars[s[0] - 'A'], isdefined[setvar - 'A'] = 1, setvar = -1;
                    else push(vars[s[0] - 'A']);
                else
                    printf("error: undefined variable called with other than =\n");
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            case '%':
                op2 = pop();
                if (isInt(op2) && (intop2 = op2) && isInt(op2 = pop())) /* integer check & zero check of second argument */
                    push((int) op2 % intop2);
                else
                    printf("error: arguments to moduls are not proper\n");
                break;
            case '=':           /* setting variable flag */
                setvar = 0;
                break;
            case 's':           /* sin */
                push(sin(pop()));
                break;
            case 'e':           /* exp */
                push(exp(pop()));
                break;
            case 'p':           /* pow */
                op2 = pop();
                push(pow(pop(), op2));
                break;
            case '?':
                showTop();
                break;
            case '#':
                duplicate();
                break;
            case '~':
                swapTops();
                break;
            case '^':
                initStack();
                break;
            case '\n':
                lastValue = pop();
                everPrinted = 1;
                printf("\t%.8g\n", lastValue);
                break;
            case '"':
                if (!everPrinted)
                    printf("error: there is no value calculated ever");
                else
                    push(lastValue);
                break;
            default:
                printf("error: unknown command %s\n", s);
                break;
        }
    }
    return 0;
}

#define MAXVAL 100              /* maximum depth of val stack */

int sp = 0;                     /* next free stack position */
double val[MAXVAL];             /* value stack */

/* push: push f onto value stack */
void push(double f) {
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

double pop(void) {
    if (sp > 0)
        return val[--sp];
    else {
        printf("error: stack empty\n");
        return 0.0;
    }
}

void showTop(void) {
    if (sp > 0)
        printf("The top element of stack is %.8g\n", val[sp - 1]);
    else {
        printf("error: stack empty\n");
    }
}

void duplicate(void) {
    if (sp > 0) {
        double temp = pop();
        push(temp);
        push(temp);
    }
    else
        printf("error: stack empty\n");
}

void swapTops(void) {
    if (sp > 1) {
        double temp = pop();
        double temp2 = pop();
        push(temp);
        push(temp2);
    }
    else
        printf("error: stack has less element than 2\n");
}

void initStack(void) {
    sp = 0;
}

#include <ctype.h>

int getch(void);
void ungetch(int);

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';

    i = 0;                      /* char array to be stored index */

    if (!isdigit(c) && c != '.') {
        if (c != '-' && c != '+')
            if (!isupper(c))
                return c;           /* not a number */
            else
                return VARIABLE;
        else if (isdigit(s[++i] = c = getch()))
            ++i;                /* is number */
        else {                  /* not a number */
            if (c != EOF)
                ungetch(c);     /* push back over consumed character */
            return c = s[0];
        }
    }

    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        ungetch(c);
    return NUMBER;
}

#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */

int getch(void) {               /* get a (possibly pushed back) character */
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}

int isInt(double num) {
    int converted = num;
    return (double) converted == num;
}
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh
cd C_codes
cc ex4_6.c -o expr
#+END_SRC

#+RESULTS:

Variable test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "= B 2 B\nB 5 +\n= A B A B *\n\" B +\n" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	2
: 	7
: 	4
: 	6

We could refactor above =main= routine -- if we chose to initialize all the
variables 0.0 at the start up, then we don't need to keep track of the flag
array; furthermore we could get rid of prefix notation of assignment to postfix
notation-- but for now, let it be as it is.
**** Exercise 4-7
:PROPERTIES:
:NOTER_PAGE: 72
:END:

We use =ungetch= to push back the =getch= ed character /as if/ to the input
stream; =ungetch= should be done in reverse order of =getch=. Since the
=getline= method depends on =getchar= for the manipulation of input stream, it
suggests =ungets(s)= should also rely on =ungetch= for the buffer management.


As we noted =ungets(s)= should push back the characters from the tail of line;
this implies it need to know the length of given string to start from the last
character, or we could use recursive function definition to do this job for us
as we did in [[*Exercise 1-16][Exercise 1-16]]. However, we have not yet learned to slice the given
array to be used in the subsequent function call, we are going to assume that it
takes length of array also as its formal parameter.

#+BEGIN_SRC C :main no
void ungetch(int);

void ungets(char s[], int len) {
    while (len > 0)
        ungetch(s[--len]);
}
#+END_SRC

The resulting code is very simple; but it does not handle erroneous behavior --
e.g. even if there is no space to fit the given length of string, it will try to
=ungetch= until it reaches the first character of string. Furthermore, it do not
know whether =ungetch= complaints that there is no more spaces or not.

This is exactly same problem we would encounter when we try to allocate given
data in the memory dynamically; so unlike the =getline=, =ungets= need to know
the free space in buffer, which in turn means it should access =bufp= and
=BUFSIZE= to calculate the free space.

So our final code should be
#+BEGIN_SRC C :main no
#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */

int getch(void) {               /* get a (possibly pushed back) character */
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}

void ungets(char s[], int len) {
    if (len + bufp < BUFSIZE)   /* if there is enough space in buffer */
        while (len > 0)
            ungetch(s[--len]);
    else
        printf("ungets: too many characters\n");
}
#+END_SRC
**** Exercise 4-8
:PROPERTIES:
:NOTER_PAGE: 72
:END:
Since we know that only one character possibly get pushbacked, we can replace
the character buffer into one character variable. And we also should replace the
=bufp='s role of detecting whether there is any pushbacked character in =getch=
into flag or initializing the pushbacked character to =NULL= character, which
would not appear in input character stream to signal there is no pushbacked.

#+BEGIN_SRC C :main no
#define BUFSIZE 100

char pushbacked = '\0';
char hasPushbacked = 0;        /* signal that the pushback is non */

int getch(void) {               /* get a (possibly pushed back) character */
    if (hasPushbacked) {
        hasPushbacked = 0;
        return pushbacked;
    }
    else
        return getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (hasPushbacked)
        printf("ungetch: too many characters\n"); /* more than one character has ungetched */
    else
        pushbacked = c, hasPushbacked = 1;
}
#+END_SRC
**** Exercise 4-9
To solve this, first, we need to analyze that what malfunction it would cause in
the current =getch= and =ungetch=. In our current functions, we should just
ignore the =EOF= signal, e.g. in =getop=, since this data would not fit into the
=char= type; that is the exactly the purpose of =EOF=.

One possible solution would change the buffer's type into =int= to cope with
=EOF=; but this approach would causes way too overhead for the memory usage
since the only character that it can not handle is =EOF=.

Rather than, we should think of the role of =EOF= and should mimic that in
current =getch= and =ungetch=.

The most reasonable one, I think, is to use flag to signal =ungetch= encountered
=EOF= and if it is, it should destroy all the buffer elements since it should
not be reached in any legitimate way; =getch= should return =EOF= after it
accepts the =EOF= signal. This is what input stream process and that process
=getch= and =ungetch= want to simulate.

#+BEGIN_SRC C :main no
#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */
char isEOF = 0;                 /* the flag of EOF */

int getch(void) {               /* get a (possibly pushed back) character */
    return (isEOF) ? EOF :
        (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (c == EOF)
        isEOF = 1;
    else if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}
#+END_SRC
**** Exercise 4-10
Since our calculator uses the reverse Polish calculator, it doesn't need any
lookahead since the behavior it should take it determined totally by the current
input. This means that we don't need to use =getline= or have no advantage to
use =getline= over =getch= and =ungetch=.

And our calculator uses abstract layers upon the processors of input stream,
=getch= and =ungetch=, we can minimize the change to the most primitive elements
of this layer -- here we are going to alter only the functions that depends on
=getch= and =ungetch= directly.

Or furthermore, if we can mimics the behaviors of =getch= and =ungetch= using
=getline= function, the user of =getch= and =ungetch= can not distinguish the
difference.

Here we are going to exploit the fact that we aren't concerned with reverting
the input stream over the line -- we don't need to store the characters of
previous line.

#+BEGIN_SRC C :tangle C_codes/ex4_10.c :main no
#include <stdio.h>
#include <stdlib.h>             /* for atof() */

#define MAXOP 100               /* max size of operand or operator */
#define NUMBER '0'              /* signal that a number was found */

int getop(char []);
void push (double);
double pop(void);

/* reverse Polish calculator */
main() {
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
        switch (type) {
            case NUMBER:
                push(atof(s));
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            case '\n':
                printf("\t%.8g\n", pop());
                break;
            default:
                printf("error: unknown command %s\n", s);
                break;
        }
    }
    return 0;
}

#define MAXVAL 100              /* maximum depth of val stack */

int sp = 0;                     /* next free stack position */
double val[MAXVAL];             /* value stack */

/* push: push f onto value stack */
void push(double f) {
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

double pop(void) {
    if (sp > 0)
        return val[--sp];
    else {
        printf("error: stack empty\n");
        return 0.0;
    }
}

#include <ctype.h>

int getch(void);
void ungetch(void);

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
        return c;               /* not a number */
    i = 0;
    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    ungetch();
    return NUMBER;
}

#define MAXLINE 100

int getLine(char line[], int limit);

char line[MAXLINE];
char linep = -1;                /* to initialize */
int len = -1;                   /* to initialize */

int getch(void) {               /* get a (possibly pushed back) character */
    if (len == 0)               /* End of file */
        return EOF;
    if (linep < len) {
        return line[linep++];
    }
    len = getLine(line, MAXLINE); /* Reach end of line */
    linep = 0;
    return getch();

}

void ungetch(void) {            /* revert the cursor point one character back */
    if (linep > 0)
        linep--;
}

int getLine(char s[], int lim)
{
    int c, i;
    for (i = 0; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}
#+END_SRC

We have used the same name as before to emphasize the changes we made to use
=getLine= instead of buffered input stream.

Let's test:
#+BEGIN_SRC sh
cd C_codes
cc ex4_10.c -o expr
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
echo "1 2 - 4 5 + *" | ./C_codes/expr
echo "1.34 1.87 - 4 5 + *" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	-9
: 	-4.77

*** Scope Rules
C provides lexicographical scope rule as it would conventional programming
language does.
*** Header Files
:PROPERTIES:
:NOTER_PAGE: 74
:END:

Here we are going to divide the monolithic calculator program into several
pieces. After dividing given program by their roles, we can compile as follows
#+BEGIN_SRC sh
cd C_codes
cc main.c getop.c stack.c getch.c -o expr
#+END_SRC

Then we can use as
#+BEGIN_SRC sh :exports both :results verbatim
echo "1 2 - 4 5 + *" | ./C_codes/expr
echo "1.34 1.87 - 4 5 + *" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	-9
: 	-4.77

Now we can maintain each routines in more modular way.

**** Header file
#+BEGIN_SRC C :tangle C_codes/calc.h :main no
#define NUMBER '0'              /* signal that a number was found */
void push (double);
double pop(void);
int getop(char []);
int getch(void);
void ungetch(int);
#+END_SRC
**** Main routine
#+BEGIN_SRC C :tangle C_codes/main.c :main no
#include <stdio.h>
#include <stdlib.h>             /* for atof() */
#include "calc.h"

#define MAXOP 100               /* max size of operand or operator */

/* reverse Polish calculator */
main() {
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
        switch (type) {
            case NUMBER:
                push(atof(s));
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            case '\n':
                printf("\t%.8g\n", pop());
                break;
            default:
                printf("error: unknown command %s\n", s);
                break;
        }
    }
    return 0;
}
#+END_SRC

**** Stack routine
#+BEGIN_SRC C :tangle C_codes/stack.c :main no
#include <stdio.h>
#include "calc.h"
#define MAXVAL 100              /* maximum depth of val stack */

int sp = 0;                     /* next free stack position */
double val[MAXVAL];             /* value stack */

/* push: push f onto value stack */
void push(double f) {
    if (sp < MAXVAL)
        val[sp++] = f;
    else
        printf("error: stack full, can't push %g\n", f);
}

double pop(void) {
    if (sp > 0)
        return val[--sp];
    else {
        printf("error: stack empty\n");
        return 0.0;
    }
}
#+END_SRC

**** =Getop= routine
#+BEGIN_SRC C :tangle C_codes/getop.c :main no
#include <stdio.h>
#include <ctype.h>
#include "calc.h"

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
        return c;               /* not a number */
    i = 0;
    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        ungetch(c);
    return NUMBER;
}
#+END_SRC

**** I/O routines
#+BEGIN_SRC C :tangle C_codes/getch.c :main no
#include <stdio.h>
#define BUFSIZE 100

char buf[BUFSIZE];              /* buffer for ungetch */
int bufp = 0;                   /* next free position in buf */

int getch(void) {               /* get a (possibly pushed back) character */
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {           /* push character back on input */
    if (bufp >= BUFSIZE)
        printf("ungetch: too many characters\n");
    else
        buf[bufp++] = c;
}
#+END_SRC

*** Static Variables
External =static= declaration is used for hiding the /guts/ of specific
functions that come to communicate using those.

Whereas, the internal =static= declaration make the local variable to remain in
existence rather than coming and going each time the function is activated.

Using this, we can get rid of the =ungetch= and =getch= procedures in our
calculator program:
**** Exercise 4-11
#+BEGIN_SRC C :tangle C_codes/getop_ex_11.c :main no
#include <stdio.h>
#include <ctype.h>
#include "calc.h"

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;
    static char pushbacked = '\0';
    static char hasPushbacked = 0;

    while ((s[0] = c = (hasPushbacked ? (hasPushbacked = 0, pushbacked) : getchar())) == ' ' || c == '\t')
        ;
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
        return c;               /* not a number */
    i = 0;
    if (isdigit(c))             /* collect integer part */
        while (isdigit(s[++i] = c = (hasPushbacked ? (hasPushbacked = 0, pushbacked) : getchar())))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(s[++i] = c = (hasPushbacked ? (hasPushbacked = 0, pushbacked) : getchar())))
            ;
    s[i] = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        hasPushbacked = 1, pushbacked = c;
    return NUMBER;
}
#+END_SRC

Here we used the same approach we took in [[*Exercise 4-8][Exercise 4-8]]. Then let's test.

#+BEGIN_SRC sh
cd C_codes
cc main.c getop_ex_11.c stack.c -o expr
#+END_SRC

#+RESULTS:

Then we can use as
#+BEGIN_SRC sh :exports both :results verbatim
echo "1 2 - 4 5 + *" | ./C_codes/expr
echo "1.34 1.87 - 4 5 + *" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	-9
: 	-4.77
*** Recursion
**** Exercise 4-12
As we mentioned earlier, we have not method to slicing the given array, we have
to pass the alternative one -- the index.

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* itoa_recur: recursive process of itoa take the current
   index and return updated index */
int itoa_recur(int n, char s[], int ind) {
    if (n / 10)
        ind = itoa_recur(n / 10, s, ind);
    s[ind++] = n % 10 + '0';
    return ind;
}

void itoa(int n, char s[]) {
    int sign;
    int i = 0;
    if ((sign = n) < 0) {
        n = -n;
        s[i++] = '-';
    }
    if (n / 10)
        i = itoa_recur(n / 10, s, i);
    s[i++] = n % 10 + '0';
    s[i] = '\0';
}

int main(void) {
    int n = -151;
    char s[10];
    itoa(n, s);
    printf("%d got converted as %s", n, s);
    return 0;
}
#+END_SRC

#+RESULTS:
: -151 got converted as -151

**** Exercise 4-13
Same as before, we pass over the index to the subsequent recursive calls.
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>
#include <string.h>

void reverse_recur(char s[], int start, int end) {
    if (start >= end)           /* base case */
        return;
    int t = s[start];
    s[start++] = s[end];
    s[end--] = t;
    reverse_recur(s, start, end);
}

void reverse(char s[]) {
    int lastInd = strlen(s) - 1;
    if (lastInd < 1)            /* base case */
        return;
    int i = 0;
    int t = s[i];
    s[i++] = s[lastInd];
    s[lastInd--] = t;
    reverse_recur(s, i, lastInd);
}

int main(void) {
    char s[] = "Test String";
    char t[strlen(s)];
    int i;
    for (i = 0; t[i] = s[i]; ++i) /* copy s to t */
        ;
    reverse(s);
    printf("%s got reversed to %s", t, s);
    return 0;
}
#+END_SRC

#+RESULTS:
: Test String got reversed to gnirtS tseT

*** The C Preprocessor
Exploit this preprocessor, we can alleviate the work of run-time execution.
**** Exercise 4-14
Here we need to define temporary variable as we did in =swap= before; and also
we should ensure that the temporary variable's name should be unique --
different from =x=, and =y=, which are arguments.

#+BEGIN_SRC C :main no :exports both
#define swap(t, x, y) \
    {t x ## y = x; x = y; y = x ## y;}

int main(void) {
    int x = 5;
    int y = 2;
    printf("%d and %d got swaped as", x, y);
    swap(int, x, y);
    printf(" %d and %d", x, y);
    return 0;
}
#+END_SRC

#+RESULTS:
: 5 and 2 got swaped as 2 and 5

** Chapter 5 -- Pointers and Arrays
*** Pointers and Function Arguments
**** Exercise 5-1
I think to make the C code concise, we need to eliminate the not wanted case.
Here we used that characteristic property to deduce the code, which is logically consistent.
#+BEGIN_SRC C :main no :tangle C_codes/ex5_1.c
#include <ctype.h>
#include <stdio.h>

int getch(void);
void ungetch(int);

/* getint: get next integer from input into *pn */
int getint(int *pn) {
    int c, sign = 1;

    while (isspace(c = getch())) /* skip white space */
        ;
    if (!isdigit(c) && c != EOF) { /* ensure c is digit */
        if (c != '+' && c != '-') { /* ensure c is sign token */
            ungetch(c);
            return 0;
        }
        char signExp = c;
        c = getch();            /* lookahead */
        if (!isdigit(c)) {
            if (c != EOF)
                ungetch(c);         /* pushback */
            ungetch(signExp);       /* sign is not number */
            return 0;
        }
        sign = (signExp == '-') ? -1 : 1;
    }
    for (*pn = 0; isdigit(c); c = getch())
        ,*pn = *pn * 10 + (c - '0');
    ,*pn *= sign;
    if (c != EOF)
        ungetch(c);
    return c;
}

int main(void) {
    int x = 0;
    getint(&x);
    printf("The input stream is integer %d\n", x);
    return 0;
}
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh
cd C_codes
cc ex5_1.c getch.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
echo - 100 | ./C_codes/current
echo -100 | ./C_codes/current
printf "-100" | ./C_codes/current
printf " -100" | ./C_codes/current
#+END_SRC

#+RESULTS:
: The input stream is integer 0
: The input stream is integer -100
: The input stream is integer 0
: The input stream is integer -100

I don't know why the third test case won't work.
**** Exercise 5-2
Since the return value is the signal how the process terminated, =getfloat=
would have same return value type as =getint=.
#+BEGIN_SRC C :main no :tangle C_codes/ex5_2.c
#include <ctype.h>
#include <stdio.h>

int getch(void);
void ungetch(int);

/* getint: get next integer from input into *pn */
int getfloat(double *pf) {
    int c, sign = 1;
    double power;

    while (isspace(c = getch())) /* skip white space */
        ;
    if (!isdigit(c) && c != EOF) { /* ensure c is digit */
        if (c != '+' && c != '-') { /* ensure c is sign token */
            ungetch(c);
            return 0;
        }
        char signExp = c;
        c = getch();            /* lookahead */
        if (!isdigit(c)) {
            if (c != EOF)
                ungetch(c);         /* pushback */
            ungetch(signExp);       /* sign is not number */
            return 0;
        }
        sign = (signExp == '-') ? -1 : 1;
    }
    for (*pf = 0; isdigit(c); c = getch())
        ,*pf = *pf * 10 + (c - '0');
    if (c == '.')               /* floating point */
        c = getch();
    for (power = 1.0; isdigit(c); c = getch(), power *= 10.0)
        ,*pf = *pf * 10 + (c - '0');
    ,*pf *= sign;
    ,*pf /= power;
    if (c != EOF)
        ungetch(c);
    return c;
}

int main(void) {
    double x ;
    getfloat(&x);
    printf("The input stream is double %g\n", x);
    return 0;
}
#+END_SRC

#+BEGIN_SRC sh
cd C_codes
cc ex5_2.c getch.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
echo -020.235 | ./C_codes/current
#+END_SRC

#+RESULTS:
: The input stream is double -20.235
*** Character Pointers and Functions
:PROPERTIES:
:NOTER_PAGE: 96
:END:
**** Exercise 5-3
#+BEGIN_SRC C :exports both
/* strcat: append string t to the end of s */
void strcat(char *s, char *t) {
    while (*s++)                /* find end of s */
        ;
    --s;                        /* adjust overshot */
    while (*s++ = *t++)         /* use strcpy strategy */
        ;
}

int main(void) {
    char s[] = "This is the one and";
    char t[] = " two";
    strcat(s, t);
    printf("%s", s);
    return 0;
}
#+END_SRC

#+RESULTS:
: This is the one and two
**** Exercise 5-4
#+BEGIN_SRC C :exports both :includes <stdio.h> <string.h> :results verbatim
/* strend: returns 1 if t occurs at the end of the string s else 0 */
char strend(char *s, char *t) {
    int offset = strlen(s) - strlen(t);
    return offset >= 0 && !strcmp(s+offset, t);
}

int main(void) {
    char s[] = "TEst end";
    char t[] = "end";
    printf("%s\noccurs at the end of\n%s\n?\n%d", t, s, strend(s, t));
    return 0;
}
#+END_SRC

#+RESULTS:
: end
: occurs at the end of
: TEst end
: ?
: 1
**** Exercise 5-5
#+BEGIN_SRC C
void strncopy(char *s, char *t, int n) {
    while (n-- > 0 && (*s++ = *t++))
        ;
}

void strncat(char *s, char *t, int n) {
    while (*s++)                /* find end of s */
        ;
    --s;                        /* adjust overshot */
    while (n-- > 0 && (*s++ = *t++)) /* use strncpy strategy */
        ;
}

int strncmp(char *s, char *t, int n) {
    for ( ; n-- > 0 && *s == *t; s++, t++)
        if (*s == '\0')
            return 0;
    return *s - *t;
}
#+END_SRC
**** Exercise 5-6
#+BEGIN_SRC C :tangle C_codes/ex5_6.c :includes <stdio.h> <ctype.h>
int getLine(char *s, int lim) {
    int c;
    int tLim = lim;
    while (lim > 1 && (c = getchar()) != EOF && c != '\n')
        ,*s++ = c, lim--;
    if (c == '\n')
        ,*s++ = c, lim--;
    ,*s = '\0';
    return tLim - lim;
}

void reverse(char *s) {
    char *t = s + strlen(s) - 1;
    char temp;
    while (s < t)
        temp = *s, *s++ = *t, *t-- = temp;
}

int atoi(char *s) {
    int n = 0;
    if (isspace(*s))
        while (isspace(*s++))
            ;
    --s;                        /* revert one overshot */
    while (isdigit(*s))
        n = 10 * n + (*s++ - '0');
    return n;
}

void itoa(int n, char *s) {
    int sign;
    char *t = s;
    if ((sign = n) < 0)
        n = -n;
    do {
        ,*s++ = n % 10 + '0';
    }
    while ((n /= 10) > 0);
    if (sign < 0)
        ,*s++ = '-';
    ,*s = '\0';
    reverse(t);                 /* reverse the whole string */
}

int strindex(char *s, char *t) {
    char *u, *v, *w;            /* moving pointers */
    for (w = s; *w != '\0'; w++) {
        for (u = w, v = t; *u != '\0' && *u++ == *v++;)
            ;
        if ((v - t) && *v == '\0')
            return w - s;
    }
    return -1;
}

int main(void) {
    char test[20];
    getLine(test, 20);
    printf("%s got from getLine\n", test);
    reverse(test);
    printf("and got revered as %s\n", test);
    int testInt = atoi(test);
    printf("Now it transformed as int %d\n", testInt);
    itoa(testInt, test);
    printf("It reverted back as %s\n", test);
    char test2[20];
    getLine(test2, 20);
    printf("Then %s occurs at %d in %s", test2, strindex(test, test2), test);
    return 0;
}
#+END_SRC

#+BEGIN_SRC sh
cd C_codes
cc ex5_6.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
printf "012\n10" | C_codes/current
#+END_SRC

#+RESULTS:
: 012
:  got from getLine
: and got revered as
: 210
: Now it transformed as int 210
: It reverted back as 210
: Then 10 occurs at 1 in 210

And

#+BEGIN_SRC C :tangle C_codes/getop_ptr.c :main no
#include <stdio.h>
#include <ctype.h>
#include "calc.h"

/* getop: get next operator or numeric operand */
int getop(char s[]) {
    int i, c;
    char *t = s;

    while ((*t = c = getch()) == ' ' || c == '\t')
        ;
    ,*++t = '\0';
    if (!isdigit(c) && c != '.')
        return c;               /* not a number */
    t = s;
    if (isdigit(c))             /* collect integer part */
        while (isdigit(*++t = c = getch()))
            ;
    if (c == '.')               /* collect fractional part */
        while (isdigit(*++t = c = getch()))
            ;
    ,*t = '\0';
    if (c != EOF)               /* ungetch cannot cope with EOF, which is not in char range */
        ungetch(c);
    return NUMBER;
}
#+END_SRC

#+BEGIN_SRC sh
cd C_codes
cc main.c getop_ptr.c stack.c getch.c -o expr
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
echo "1 2 - 4 5 + *" | ./C_codes/expr
echo "1.34 1.87 - 4 5 + *" | ./C_codes/expr
#+END_SRC

#+RESULTS:
: 	-9
: 	-4.77
*** Pointers Arrays; Pointers to Pointers
:PROPERTIES:
:NOTER_PAGE: 99
:END:
**** Exercise 5-7
:PROPERTIES:
:NOTER_PAGE: 99
:END:

Rephrasing what the statement said as /assume that the memory allocation is done
in main routines/, then we can directly pass =getline= with the given character
array:

#+BEGIN_SRC C
#define MAXLEN
int getline(char *, int);

int readlines(char *lineptr[], int maxlines) {
    int len, nlines = maxlines;
    while (maxlines-- > 0 && (len = getline(*lineptr, MAXLEN)) > 0)
        ,*lineptr++[len - 1] = '\0'; /* delete newline */
    if (len && getchar() != EOF)
        return -1;
    return nlines - maxlines;
}
#+END_SRC


*** Multi-dimensional Arrays
:PROPERTIES:
:NOTER_PAGE: 99
:END:

#+BEGIN_SRC C
static char daytab[2][13] = {
{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

int day_of_year(int year, int month, int day) {
    int i, leap;
    leap = year % 4 == 0 && year % 100 != 0 || year & 400 == 0;
    for (i = 1; i < month; i++)
        day += daytab[leap][i];
    return day;
}

void month_day(int year, int yearday, int *pmonth, int *pday) {
    int i, leap;
    leap = year % 4 == 0 && year % 100 != 0 || year & 400 == 0;
    for (i = 1; yearday > daytab[leap][i]; i++)
        yearday -= daytab[leap][i];
    ,*pmonth = i;
    *pday = yearday;
}
#+END_SRC
**** Exercise 5-8
:PROPERTIES:
:NOTER_PAGE: 101
:END:

Firstly, we need to ensure month to be between 1 and 12 inclusively; and day
should be less than or equals to the last day of that month. This suggests the
error checking of =day_of_year=:

#+BEGIN_SRC C
int day_of_year(int year, int month, int day) {
    int i, leap;
    if (month > 12 || month < 1) {
        printf("error: such month, %d, doesn't exist", month);
        return 0;
    }
    leap = year % 4 == 0 && year % 100 != 0 || year & 400 == 0;
    if (day > daytab[leap][month] || day < 1) {
        printf("error: such day, %d, doesn't exist", day);
        return 0;
    }
    for (i = 1; i < month; i++)
        day += daytab[leap][i];
    return day;
}
#+END_SRC

For the =month_day=, we need to check given =yearday= is less than the summation
of days in given year: This is a good place to use static internal declaration.

#+BEGIN_SRC C
void month_day(int year, int yearday, int *pmonth, int *pday) {
    int i, leap;
    static char wholeday[2] = {0, 0};
    leap = year % 4 == 0 && year % 100 != 0 || year & 400 == 0;
    if (wholeday[leap] == 0) {
        char *pt = daytab[leap];
        for (*pt++; pt - daytab[leap] <= 13; wholeday[leap] += *pt++)
            ;
    }
    if (yearday > wholeday[leap] || yearday < 1) {
        printf("error: given yearday, %d, does not exist in current year, %d",
               yearday, year);
        ,*pmonth = 0, *pday = 0;
    }
    for (i = 1; yearday > daytab[leap][i]; i++)
        yearday -= daytab[leap][i];
    ,*pmonth = i;
    ,*pday = yearday;

}
#+END_SRC

*** Pointers vs. Multi-dimensional Arrays
:PROPERTIES:
:NOTER_PAGE: 101
:END:

The difference between the pointer array between multi-dimensional array is
followings:
#+BEGIN_SRC C :exports both :results verbatim
int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
int *b[3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

printf("the forth element of a is %d\n", *(a[0] + 3));
/* printf("the forth element of b is %d\n", *(b[0] + 3)); */
/* â†‘doesn't work */
printf("the size of *a is %u\n", sizeof(*a));
printf("the size of *b is %u\n", sizeof(*b));
#+END_SRC

#+RESULTS:
: the forth element of a is 4
: the size of *a is 12
: the size of *b is 8

Using these experiments, you should convince yourself what text described.

**** Exercise 5-9
:PROPERTIES:
:NOTER_PAGE: 102
:END:

#+BEGIN_SRC C :exports both :results verbatim
static char daytab[2][13] = {
{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

int day_of_year(int year, int month, int day) {
    int leap;
    char *pm;                   /* moving pointer for # day of each month */
    leap = year % 4 == 0 && year % 100 != 0 || year & 400 == 0;
    for (pm = daytab[leap]; 1 < month--; day += *++pm)
        ;
    return day;
}

void month_day(int year, int yearday, int *pmonth, int *pday) {
    int leap;
    char *pm;                   /* moving pointer for # day of each month */
    leap = year % 4 == 0 && year % 100 != 0 || year & 400 == 0;
    for (pm = daytab[leap]; yearday > *++pm;)
        yearday -= *pm;
    ,*pmonth = pm - daytab[leap];
    ,*pday = yearday;
}

int main(void) {
    int month = 3, day = 20, year = 1996;
    int yearday =  day_of_year(year, month, day);
    printf("the day of %d/%d/%d is %d\n", year, month, day, yearday);
    month_day(year, yearday, &month, &day);
    printf("and %d of %d is %d/%d/%d", yearday, year, year, month, day);
    return 0;
}
#+END_SRC

#+RESULTS:
: the day of 1996/3/20 is 80
: and 80 of 1996 is 1996/3/20

*** Command-line Arguments
:PROPERTIES:
:NOTER_PAGE: 102
:END:

**** Exercise 5-10
:PROPERTIES:
:NOTER_PAGE: 105
:END:

#+BEGIN_SRC C :tangle C_codes/ex5_10.c :main no
#include <stdio.h>
#include <stdlib.h>             /* for atof() */
#include "calc.h"

#define MAXOP 100               /* max size of operand or operator */

int gettype(char *s) {
    if (!isdigit(*s) && *s != '.')
        return *s;              /* not a number */
    return NUMBER;
}

/* reverse Polish calculator */
int main(int argc, char *argv[]) {
    int type;
    double op2;
    char s[MAXOP];

    while (--argc > 0) {
        switch (gettype(*++argv)) {
            case NUMBER:
                push(atof(*argv));
                break;
            case '+':
                push(pop() + pop());
                break;
            case '*':
                push(pop() * pop());
                break;
            case '-':
                op2 = pop();
                push(pop() - op2);
                break;
            case '/':
                op2 = pop();
                if (op2 != 0.0)
                    push(pop() - op2);
                else
                    printf("error: zero divisor\n");
                break;
            default:
                printf("error: unknown command %s\n", *argv);
                break;
        }
    }
    printf("\t%.8g\n", pop());
    return 0;
}
#+END_SRC

Here is the simplest commandline calculator program.
#+BEGIN_SRC sh
cd C_codes
cc ex5_10.c stack.c -o expr
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
./C_codes/expr 2 3 4 + - 5 \*
#+END_SRC

#+RESULTS:
: 	-25
**** Exercise 5-11

#+BEGIN_SRC C :main no :tangle C_codes/ex5_11_entab.c

#include <stdio.h>
#include <stdlib.h>             /* for atoi */
int main(int argc, char *argv[]) {
    int c;
    int ncolumn = 0;
    int nexttabstop;
    int nentry;
    int tabstop = 4;            /* default tabstop */

    if (argc > 2) {
        printf("Usage: entab TABSTOP\n");
        return 0;
    }

    if (argc == 2)
        tabstop = atoi(argv[argc - 1]);

    c = getchar();
    while (c != EOF) {
        if (c == ' ') {
            nentry = ncolumn;
            ++ncolumn;
            nexttabstop = ncolumn + (tabstop - (ncolumn % tabstop));
            while (ncolumn != nexttabstop && (c = getchar()) == ' ') {
                ++ncolumn;
            }
            if (ncolumn == nexttabstop) {
                putchar('\t');
                c = getchar();  /* to agree with next branch */
            } else {
                while(nentry != ncolumn) {
                    putchar(' ');
                    ++nentry;
                }
            }
        } else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;
            else ++ncolumn;
            c = getchar();      /* to agree with above if branch */
        }
    }
}
#+END_SRC


#+BEGIN_SRC C :main no :tangle C_codes/ex5_11_detab.c
#include <stdio.h>
#include <stdlib.h>             /* for atoi */
#define TABSTOP 4                     /* Tab stop */

int expandtab(int columnIndex);

int main(int argc, char *argv[]) {
    int c;
    int ncolumn = 0;
    int tabstop = 4;            /* default tabstop */

    if (argc > 2) {
        printf("Usage: detab TABSTOP\n");
        return 0;
    }

    if (argc == 2)
        tabstop = atoi(argv[argc - 1]);

    while ((c = getchar()) != EOF) {
        if (c == '\t')
            ncolumn = expandtab(ncolumn); /* update column number */
        else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;    /* initialize column number */
            else ++ncolumn;     /* increase column number */
        }
    }
}

int expandtab(int nc) {
    if ((nc % TABSTOP) == 0) {
        putchar(' ');
        ++nc;
    }
    while((nc % TABSTOP) != 0) {
        putchar(' ');
        ++nc;
    }
    return nc;
}
#+END_SRC
**** Exercise 5-12

Before to add new feature to our current =detab= and =entab=, we are going to
refactor the code; the current one is nasty since it was made in naive approach
and at that moment we didn't have good sense of programming in C.

Now we should be better than that time. So it's time to refactor such clutters.

***** Refactoring =detab= & Implementing new feature

- The =main= routine should be simple as it just delegate real works to the
  subroutines based on the current input character.
- Since =detab= doesn't need to lookahead, only =main= can access to the current
  character.
- =Tabstop= and =ncolumn= should be global variable since subroutines should
  adjust the column line number as it process.

#+BEGIN_SRC C :main no :tangle C_codes/ex5_11_detab_refactored.c
#include <stdio.h>
#include <stdlib.h>             /* for atoi */

int tabstop = 4;            /* default tabstop */
int ncolumn = 0;

void expandtab(void);

int main(int argc, char *argv[]) {
    int c;

    if (argc > 2) {
        printf("Usage: detab TABSTOP\n");
        return 0;
    }

    if (argc == 2)
        tabstop = atoi(argv[argc - 1]);

    while ((c = getchar()) != EOF) {
        switch(c) {
            case '\t':
                expandtab();
                break;
            case '\n':
                putchar('\n');
                ncolumn = 0;
                break;
            default:
                putchar(c);
                ncolumn++;
        }
    }
}

void expandtab() {
    putchar(' '), ncolumn++;    /* remove boundary case */
    int remainingSpace = tabstop - ncolumn % tabstop;
    while (remainingSpace-- > 0)
        putchar(' '), ncolumn++;
}
#+END_SRC

Then let's test:
#+BEGIN_SRC sh
cd C_codes/
cc ex5_11_detab_refactored.c -o detab
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes
printf "this   	tab	tab" | ./detab
#+END_SRC

#+RESULTS:
: this        tab     tab

Then now we need to make =detab= accept =-m= and =+n= arguments in commandline.
This cause change in =main= routine to parse the arguments to setup
appropriately; and also =expandtab()= to deal with =-m= feature. Let us first
support =-m= in =expandtab()=.

This quite straightforward expansion; the only change is that now we need
compare current column line with the starting tabstop, =m= to calculate
=remainingSpace=:
#+BEGIN_SRC C
void expandtab() {
    putchar(' '), ncolumn++;    /* remove boundary case */
    int distFromStartTab = ncolumn - startTab
    int remainingSpace =
        (distFromStartTab > 0) ? tabstop - distFromStartTab % tabstop: -distFromStartTab;
    while (remainingSpace-- > 0)
        putchar(' '), ncolumn++;
}
#+END_SRC

Now let's make the =main= to parse the arguments appropriately:
#+BEGIN_SRC C
int startTab = 2;               /* default startTab */
int tabstop = 4;            /* default tabstop */
int ncolumn = 0;

int main(int argc, char *argv[]) {
    int c;

    while (--argc > 0)
        switch (c = (*++argv)[0]) {
            case '+':
                tabstop = atoi(++argv[0]);
                break;
            case '-':
                startTab = atoi(++argv[0]);
                break;
            default:
                printf("detab: illegal option %s, instead use default setting", argv[0]);
                break;
        }

    while ((c = getchar()) != EOF) {
        switch(c) {
            case '\t':
                expandtab();
                break;
            case '\n':
                putchar('\n');
                ncolumn = 0;
                break;
            default:
                putchar(c);
                ncolumn++;
        }
    }
}
#+END_SRC

Here we chose to overwrite previous setting if it encounters yet another options.

Let's combine all of the works:
#+BEGIN_SRC C :tangle C_codes/ex5_12_detab.c
#include <stdio.h>
#include <stdlib.h>             /* for atoi */

#define STARTTAB 2
#define TABSTOP 4

void expandtab(void);
int startTab = 2;               /* default startTab */
int tabstop = 4;            /* default tabstop */
int ncolumn = 0;

int main(int argc, char *argv[]) {
    int c;

    while (--argc > 0)
        switch (c = (*++argv)[0]) {
            case '+':
                tabstop = atoi(++argv[0]);
                break;
            case '-':
                startTab = atoi(++argv[0]);
                break;
            default:
                printf("detab: illegal option \'%s\', instead use default setting\n", argv[0]);
                tabstop = TABSTOP;
                startTab = STARTTAB;
                break;
        }

    while ((c = getchar()) != EOF) {
        switch(c) {
            case '\t':
                expandtab();
                break;
            case '\n':
                putchar('\n');
                ncolumn = 0;
                break;
            default:
                putchar(c);
                ncolumn++;
        }
    }
}

void expandtab(void) {
    putchar(' '), ncolumn++;    /* remove boundary case */
    int distFromStartTab = ncolumn - startTab;
    int remainingSpace =
        (distFromStartTab > 0) ? tabstop - distFromStartTab % tabstop: -distFromStartTab;
    while (remainingSpace-- > 0)
        putchar(' '), ncolumn++;
}
#+END_SRC

Then let's test:
#+BEGIN_SRC sh
cd C_codes/
cc ex5_12_detab.c -o detab
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes
printf "	this   	tab	tab\n" | ./detab #default setting
printf "	this   	tab	tab\n" | ./detab -5 #tweak startTab
printf "	this   	tab	tab\n" | ./detab -5 +2 #tweak startTab & tabstop
printf "	this   	tab	tab\n" | ./detab -5 +2 power #include invalid option
#+END_SRC

#+RESULTS:
:   this        tab     tab
:      this        tab     tab
:      this      tab   tab
: detab: illegal option 'power', instead use default setting
:   this        tab     tab


***** Refactoring =entab= & Implementing new feature
In the same manner as =detab=, the main should be simple enough to just pass
over tasks to appropriate subroutines; subroutines should be simple enough to
concentrate on their job. However unlike =detab=, the subroutines encounters the
situation where it needs to lookahead to decide what it should do.

First, let's refactor the =main= routine to delegate all real works into
subroutines and then using the specifications used in =main= routine we can
implement the subroutines. Here is the result:
#+BEGIN_SRC C :main no :tangle C_codes/ex5_11_entab_refactored.c
#include <stdio.h>
#include <stdlib.h>             /* for atoi */

void dealWithSpace(void);
int getch(void);
void ungetch(int c);

int ncolumn = 0;
int tabstop = 4;


int main(int argc, char *argv[]) {
    int c;

    if (argc > 2) {
        printf("Usage: entab TABSTOP\n");
        return 0;
    }

    if (argc == 2)
        tabstop = atoi(argv[argc - 1]);

    while ((c = getch()) != EOF) {
        switch (c) {
            case ' ':
                dealWithSpace();
                break;
            case '\n':
                putchar('\n');
                ncolumn = 0;
                break;
            default:
                putchar(c);
                ncolumn++;
                break;

        }
    }
}

void dealWithSpace(void) {
    int nentry = ncolumn;       /* store current column position */
    int isblank;               /* the remaining blanks to reach next tab stop */
    int c;
    ++ncolumn;                 /* remove boundary case */
    for (isblank = tabstop - ncolumn % tabstop; isblank && (c = getch()) == ' '; ++ncolumn, --isblank)
        ;
    if (!isblank) {           /* tabstop */
        putchar('\t');
        return;
    }
    while (nentry++ < ncolumn)
        putchar(' ');
    if (c != EOF)
        ungetch(c);             /* overshot */
}
#+END_SRC

Then let's test:
#+BEGIN_SRC sh
cd C_codes/
cc ex5_11_entab_refactored.c getch.c -o entab
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes
printf "this   	tab	tab" | ./detab | ./entab
#+END_SRC

Let turn to new commandline argument; as usual, first we are going to modify
=dealWithSpace=:
#+BEGIN_SRC C
void dealWithSpace(void) {
    int nentry = ncolumn;       /* store current column position */
    int distFromStartTab = ncolumn - startTab;
    int isblank;               /* the remaining blanks to reach next tab stop */
    int c;
    ++ncolumn;                 /* remove boundary case */
    for (isblank = (distFromStartTab > 0) ? tabstop - distFromStartTab % tabstop: -distFromStartTab;
         isblank && (c = getch()) == ' '; ++ncolumn, --isblank)
        ;
    if (!isblank) {           /* tabstop */
        putchar('\t');
        return;
    }
    while (nentry++ < ncolumn)
        putchar(' ');
    if (c != EOF)
        ungetch(c);             /* overshot */
}
#+END_SRC

As the code change is exactly same as =detab= we could capture this commonality
with new function, namely =nextTabstop()=. For now let it be as it is.

Now main: This is also same as =detab=. So the final code would be
#+BEGIN_SRC C :tangle C_codes/ex5_12_entab.c
#include <stdio.h>
#include <stdlib.h>             /* for atoi */

#define TABSTOP 4
#define STARTTAB 2

void dealWithSpace(void);
int getch(void);
void ungetch(int c);

int ncolumn = 0;
int tabstop = TABSTOP;
int startTab = STARTTAB;


int main(int argc, char *argv[]) {
    int c;

    while (--argc > 0)
        switch (c = (*++argv)[0]) {
            case '+':
                tabstop = atoi(++argv[0]);
                break;
            case '-':
                startTab = atoi(++argv[0]);
                break;
            default:
                printf("entab: illegal option \'%s\', instead use default setting\n", argv[0]);
                tabstop = TABSTOP;
                startTab = STARTTAB;
                break;
        }

    while ((c = getch()) != EOF) {
        switch (c) {
            case ' ':
                dealWithSpace();
                break;
            case '\n':
                putchar('\n');
                ncolumn = 0;
                break;
            default:
                putchar(c);
                ncolumn++;
                break;

        }
    }
}

void dealWithSpace(void) {
    int nentry = ncolumn++;       /* store current column position */
    int isblank;               /* the remaining blanks to reach next tab stop */
    int c;
    int distFromStartTab = ncolumn - startTab;

    for (isblank = (distFromStartTab > 0) ? tabstop - distFromStartTab % tabstop : -distFromStartTab;
         isblank && (c = getch()) == ' '; ++ncolumn, --isblank)
        ;
    if (!isblank) {           /* tabstop */
        putchar('\t');
        return;
    }
    while (nentry++ < ncolumn)
        putchar(' ');
    if (c != EOF)
        ungetch(c);             /* overshot */
}
#+END_SRC

#+BEGIN_SRC sh
cd C_codes
cc ex5_12_entab.c getch.c -o entab
#+END_SRC

#+RESULTS:


Then test:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes
printf "	this		tab	tab\n" | ./detab | ./entab #default setting
printf "	this		tab	tab\n" | ./detab -5 | ./entab -5 #tweak startTab
printf "	this		tab	tab\n" | ./detab -5 +2 | ./entab -5 +2 #tweak startTab & tabstop
printf "	this		tab	tab\n" | ./detab -5 +2 power | ./entab -5 +2 power #include invalid option
#+END_SRC

#+RESULTS:
: 	this		tab	tab
: 	this		tab	tab
: 	this		tab	tab
: entab: illegal option 'power', instead use default setting
: detab: illegal option 'power', instead use default setting
: 	this		tab	tab
**** Exercise 5-13
This exercise has quite complicated constraint than usual; actually what the
statement want us to do is implement heap memory management system, which
happens to be used for =tail= program. As you know, heap memory management
system should involve garbage collecting algorithm to reuse the finite memory
economically.

So, we need to implement heap memory system, which will start with one
monolithic free memory at which data are going to be stored.

Since this memory management system is just for =tail= process, we can exploit
the way it stores data into heap. Here is the idea:

1. Prepare one monolithic memory to which data going to be stored.
2. Start to allocate each data into that memory from the starting pointer of it.
3. If given data would cause overflow of the heap memory, it need to calculate
   to decide whether the heap memory is full with useful memory so it can not be
   used anymore. That is,
4. it first find out the first pointer of useful data -- the ones held by
   =tail=; if the available memory from the last pointer to that first pointer
   accounting wrapping afford to allocate requested new data, then it start to
   clean up garbages in current memory and then allocate new data.
5. Else, the heap has no memory available to allocate the requested data; it
   should signal this fact to the user.


In the above informal description, we exploited the fact the =tail='s data would
be allocated sequentially; so we can calculate the first pointer of useful data
in our heap. Note that we have to provide another same size of memory as
currently used heap to cleanup safely.

We could use the heap memory in other way: Not cleanup explicitly the memory
when it needs to, just explicitly wrap the data itself; it would be more
efficiently than above one since it never modify any datum once it allocates
that in heap, and thus doesn't need to provide another any auxiliary memory
standing by to be used when it comes to need to be cleanup.

In either implementation, we can cope with any arbitrary length of input line
since allocation ensured to be done sequentially. This deals with the constrain
of /unreasonable input/. The rest constraint is trivial -- just use default /n/
if it is unrealistic.

Finally, we should deal with the case where the current line is too big to be
allocated but, at the end, turns out it was not needed at all; the last /n/
lines can safely fit into given heap. To work around this, we should not abort
as soon as our heap is full with useful data -- it should wait until the end of
input stream destroying from the first stored data if current heap is full.

And then after the input stream end, if the pointer array ever hold pointer to
the destroyed line, then it can complaint this fact to the user. Otherwise, that
is, if there is no destruction at all in process or the destroyed ones replaced
by unharmed ones, it should prints the last /n/ lines as normal.

This exercise involves multiple abstraction layer in it, that is, the user of
function that allocates last /n/ lines, function that prints those at the top
level.

In turn, the line allocating function use heap data structure with input
functions, and print function which uses the information line allocator produced
and output functions.

At the very low level there is I/O functions and heap data representation.

Can we implement this layered structure in C naturally? We have used to do that
in Scheme, but in C we have rarely cared about that; all information got
cluttered up so one can not easily be divided into one independent unit.

So for here, we will deal with those abstract concepts to implement =tail=
program. It would be great help when we try to design and implement more
complicated program and the ones that has nasty specifications.

***** =Main= routine

First, let us start from the very top level as usual. Using the type constraint
we defined in this implementation, we are going to implement subsequent below
level's functions.

The =main= should
- parse the command line arguments;
- set that option to the given variable;
- give control to the readline process;
- error check based on the value returned from readline process;
- give control to the writeline process;
- end of the process.

#+BEGIN_SRC C
#define DEFAULTN 10

int n = DEFAULTN;

enum {ERROR = -1, SUCCESS = 0};

int
main(int argc, char *argv[])
{
    parseCommand(argc, argv);

    if (readLineWrappedN(???) == ERROR)
        return error("error: tail's heap is full with last %d lines", n);
    writeLineWrappedN(???);
    return 0;
}
#+END_SRC

We haven't decided what =readLineWrappedN= should take and return but it should
signal how the process ended when it return the control to =main=. It is also
true for =writeLineWrappedN=. The only concrete process would be =parseComamnd=. Let
us tackle that first.

The =parseCommand= should
- parse the argument until there is no more argument left to parse;


This is exactly same process with that of =find=:

#+BEGIN_SRC C
void
parseCommand(int argc, char *argv[]) {
    while (--argc > 0 && (*++argv)[0] == '-')
        if (isdigit(*++argv[0]))
            n = atoi(argv[0]);
        else {
            printf("tail: %s is not number, default value used instead\n", argv[0]);
            n = DEFAULTN;
        }
    if (argc != 1) {
        printf("tail: illegal arguments will be ignored\n");
        printf("Usage: tail [-n]\n");
    }
    if (n < 1)                  /* unrealistic value */
        n = DEFAULTN;
}
#+END_SRC

Let's delegate the other specifications into subroutines.

***** =ReadLineWrappedN= subroutine
This procedure should
- call =getline= procedure to take line from input stream;
- if =getline= terminate normally, it should call =allocateWrapped=;
- as =allocatedWrapped= return the control with newly allocated pointer, it
  should call =installWrapped= to install given line into the memory;
- then if it installed with out any abnormal, it should put the current pointer
  into the queue like data structure, which holds pointers to last /n/ lines.


We have not described what happening in =allocatedWrapped= and =installWrapped=
since it doesn't have to know about the heap and queue data structure. It is
enough for =realLindWrapped= to update appropriately.

The only tricky point is that when the line returned by =getline= overflowed. In
that case, it should link the current line with the subsequent line, which will
be got from next loop. Here is the code:
#+BEGIN_SRC C :main no :tangle C_codes/readLineWrappedN.c
#define MAXLEN 20
#include "ex5_13.h"

int isOverflowed(char *, int, int);
int getLine(char *, int);

int
readLineWrappedN()
{
    char line[MAXLEN];          /* current input line */
    int len;
    char overflowed = 0;
    char shouldInsert;
    char isWrapped = 0;
    char *p;
    while ((len = getLine(line, MAXLEN)) > 0)
    {
        shouldInsert = !overflowed;
        if ((overflowed = isOverflowed(line, len, MAXLEN)))
            len -= 1;           /* remove last null character to link with next */
        else if (line[len - 1] == '\n')        /* not last line */
            line[--len] = '\0'; /* remove newline character */
        isWrapped = 0;          /* initialize isWrapped */
        p = allocWrapped(len + 1, &isWrapped); /* install until null character */
        if (shouldInsert)
            insertLast(p, isWrapped);
        installWrapped(p, line, len + 1); /* install until null character */
    }
    if (existDestroyed())
        return ERROR;
    return SUCCESS;
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

We found out that it need to also control the whether current allocation wrapped
or not.
***** =AllocateWrapped=, =installWrapped=, heap representation, and queue representation
Now we need to implement all the low level representations. Since our heap and
queue, which holds pointers last /n/ lines, are mutually dependent as those
exploits the fact that this is all for just =tail= program.

First, =allocateWrapped= manage the free pointer as =alloc= did, and it should
handle the wrapping case to calculate new free pointer. We will base on the
=alloc= implementation in text book:

#+BEGIN_SRC C :tangle C_codes/heapWrapped.c :main no
#define ALLOCSIZE 100           /* size of available space */

static char allocbuf[ALLOCSIZE]; /* storage for allocWrapped */
static char *allocp = allocbuf;  /* next free position */

char *allocWrapped(int n, char *isWrapped) {
    if (allocbuf + ALLOCSIZE - allocp >= n) { /* it fits without wrapping */
        allocp += n;
        return allocp - n;      /* old p */
    } else {                    /* should wrap */
        n -= allocbuf + ALLOCSIZE - allocp; /* allocate until end of buffer and wrap */
        ,*isWrapped = 1;
        allocp = allocbuf;      /* wrapped */
        return allocWrapped(++n, isWrapped); /* take account the null character since this string is broken */
    }
}

char *firstPointer(void) {
    return allocbuf;
}

char isLastPointer(char *p) {
    return p == allocbuf + ALLOCSIZE - 1;
}
#+END_SRC

Now we need to =installWrapped=; it should have access to the =allocbuf= in case
it should install wrapping around, and it need to check also the current
character pointer held by queue; if it is destroy that:
#+BEGIN_SRC C :tangle C_codes/installWrapped.c :main no
#include "ex5_13.h"
#include <stdio.h>
void installWrapped(char *p, char *line, int len) {
    len--;
    ,*p++ = *line++;             /* entry point should not be destroyed */
    while (len-- > 0) {
        if (isLastPointer(p))
            destroyIfHeld(p), *p = '\0', p = firstPointer(); /* break current line */
        destroyIfHeld(p);
        ,*p++ = *line++;
    }
}
#+END_SRC

When now we are going to represent queue. It should support =insertLast=,
=destroyIfHeld=, =existDestroyed=, and lastly =writeLineWrappedN=.

#+BEGIN_SRC C :tangle C_codes/lastN.c :main no
#include <stdlib.h>
#include <stdio.h>
#include "ex5_13.h"

enum {DESTROYED = -1, UNDEFINED = 0, DEFINED = 1};

static char **lastN;            /* pointer array holding last n lines */
static char *flags;             /* flags for above array whether it defined or destroyed */
static int next = 0;            /* index to be set next */
static int wrapped = -1;        /* the index holding wrapped line */
static int size;                /* size of pointer array */

void setLastN(int n) {
    lastN = malloc(sizeof(char *) * n);
    flags = malloc(sizeof(char) * n);
    size = n;
    while (n-- > 0)             /* initialize flags */
        flags[n] = UNDEFINED;
    n = size;
    while (n-- > 0)             /* initialize pointer array */
        lastN[n] = NULL;
}

void insertLast(char *p, int isWrapped) {
    if (isWrapped)
        wrapped = next;
    else if (wrapped == next)
        wrapped = -1;           /* need to unset wrapped */
    lastN[next] = p, flags[next++] = DEFINED;
    if (next == size)           /* need to wrap */
        next = 0;
}

int heldBy(char *p) {
    int i = size;
    while (i-- > 0)
        if (lastN[i] == p)
            return i;
    return -1;

}

void destroyIfHeld(char *p) {
    int i = heldBy(p);
    if (i < 0)
        return;
    flags[i] = DESTROYED;
}

char existDestroyed(void) {
    int i = size;
    while (i-- > 0)
        if (flags[i] == DESTROYED)
            return 1;
    return 0;
}

void writeLineWrappedN(void) {
    int i = next;
    do {
        if (flags[i] != DEFINED)
            continue;
        if (i == wrapped)
            printf("%s%s\n", lastN[i], firstPointer());
        else
            printf("%s\n", lastN[i]);
    } while ((i = (i + 1) % size) != next); /* for wrapping case */
}

void inspectLastN(void) {
    int i = size;
    while (i-- > 0)
        if (i == wrapped)
            printf("current line is wrapped one. The first one is \n%s\nat heap index %d\nand the rest is\n%s\n",
                   lastN[i], lastN[i] - firstPointer(), firstPointer());
        else
            printf("%s\nis stored at heap index %d\n", lastN[i], lastN[i] - firstPointer());
}

void freeLastN(void) {
    free(lastN);
    free(flags);
}
#+END_SRC

Here we used =malloc= to allocate the queue data structure into the memory.
***** Put all together
Let's put all together. First the header file:
#+BEGIN_SRC C :main no :tangle C_codes/ex5_13.h
enum {ERROR = -1, SUCCESS = 0};

int readLineWrappedN(void);
void writeLineWrappedN(void);
/* heap representations */
char *allocWrapped(int, char *);
char *firstPointer(void);
char isLastPointer(char *);
void installWrapped(char *, char *, int);
/* queue representation */
void setLastN(int);
void freeLastN(void);
void insertLast(char *, int);
void destroyIfHeld(char *);
char existDestroyed(void);
void inspectLastN(void);
#+END_SRC

=Main= file got to be concrete:
#+BEGIN_SRC C :tangle C_codes/ex5_13_main.c

#include <stdio.h>
#include <ctype.h>              /* for isdigit */
#include <stdlib.h>             /* for atoi */
#include "ex5_13.h"

#define DEFAULTN 10

static int n = DEFAULTN;

void
parseCommand(int argc, char *argv[]) {
    while (--argc > 0 && (*++argv)[0] == '-')
        if (isdigit(*++argv[0]))
            n = atoi(argv[0]);
        else {
            printf("tail: %s is not number, default value used instead\n", argv[0]);
            n = DEFAULTN;
        }
    if (argc) {
        printf("tail: illegal arguments will be ignored\n");
        printf("Usage: tail [-n]\n");
    }
    if (n < 1)                  /* unrealistic value */
        n = DEFAULTN;
}

int
main(int argc, char *argv[])
{
    parseCommand(argc, argv);
    setLastN(n);
    if (readLineWrappedN() == ERROR) {
        printf("error: tail's heap is full with last %d lines\n", n);
        return 0;
    }
    writeLineWrappedN();
    /* inspectLastN(); */
    freeLastN();
    return 0;
}
#+END_SRC

=getLine= subroutine:
#+BEGIN_SRC C :tangle C_codes/getLine.c :main no
#include <stdio.h>

int getLine(char *s, int lim) {
    int c;
    int tLim = lim;
    while (lim > 1 && (c = getchar()) != EOF && c != '\n')
        ,*s++ = c, lim--;
    if (c == '\n')
        ,*s++ = c, lim--;
    ,*s = '\0';
    return tLim - lim;
}
#+END_SRC

#+RESULTS:

Then let's test:
#+BEGIN_SRC sh
cd C_codes
cc ex5_13_main.c readLineWrappedN.c heapWrapped.c installWrapped.c lastN.c getLine.c -o tail
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes
printf "test\nline\nlike\nthis\n" | ./tail -10
#+END_SRC

#+RESULTS:
: test
: line
: like
: this

The long line test
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes
printf "This line is so long to be fit into the line that can be obtained in one getLine\nand yes.\n" | ./tail -10
#+END_SRC

#+RESULTS:
: This line is so long to be fit into the line that can be obtained in one getLine
: and yes.

But it turns out sometimes it falls into infinite loop unexpected. After a
couple of trial, we could find out the error in =allocateWrapped=:
#+BEGIN_SRC C :tangle C_codes/heapWrapped_fixed.c :main no
#define ALLOCSIZE 100           /* size of available space */

static char allocbuf[ALLOCSIZE]; /* storage for allocWrapped */
static char *allocp = allocbuf;  /* next free position */

void calculateWrapped(int n) {
    if (ALLOCSIZE >= n)        /* it fits without additional wrapping */
        allocp += n;
    else
        calculateWrapped(n - ALLOCSIZE + 1); /* need additional wrapping */
}

char *allocWrapped(int n, char *isWrapped) {
    char *returnPointer = allocp;
    if (allocbuf + ALLOCSIZE - allocp >= n) { /* it fits without wrapping */
        allocp += n;
    } else {                    /* should wrap */
        n -= allocbuf + ALLOCSIZE - allocp; /* allocate until end of buffer and wrap */
        ,*isWrapped = 1;
        allocp = allocbuf;      /* wrapped */
        calculateWrapped(++n);  /* account null character for wrapping */
    }
    return returnPointer;       /* return old pointer */
}


char *firstPointer(void) {
    return allocbuf;
}

char isLastPointer(char *p) {
    return p == allocbuf + ALLOCSIZE - 1;
}
#+END_SRC

The previous version has returned improper value in recursive case. It should
have return the old pointer in any case.

And after quite subtle debugging process,

Now finally let's test:
#+BEGIN_SRC sh
cd C_codes
cc ex5_13_main.c readLineWrappedN.c heapWrapped_fixed.c installWrapped.c lastN.c getLine.c -o tail
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes
printf "This line is so long to be fit into the line that can be obtained in one getLine\nand yes." | ./tail -2
printf "And even this line is so huge that it can not be fit into even the provded heap not just getLine but is should signal this normally" | ./tail -1
printf "And even this line is so huge that it can not be fit into even the provded heap not just getLine but is should signal this normally\nAnd that was not used." | ./tail -1
printf "And even this line is so huge that it can not be fit into any one getLine process but fit in heap." | ./tail -1
#+END_SRC
#+RESULTS:
: This line is so long to be fit into the line that can be obtained in one getLine
: and yes.
: error: tail's heap is full with last 1 lines
: And that was not used.
: And even this line is so huge that it can not be fit into any one getLine process but fit in heap.

Now it works as expected; but it was quite hard to reason all of the bugs that
wiggling beneath. We need to use smart unit test to eliminate such unfortunates
but in this specific example, as all the routines got intertwined intimately, it
is hard to do that.

We need to consider good way to avoid from that.
*** Pointers to Functions

Fortunately, even in C, we can pass the function into another function and
return function as value as if it were higher order function at surface. But as
noted before in the block structure section, we can not defined new function
with in function block or more precisely, within any block which delimited by
brackets.

Then how we got to be able to use higher order type contraction in C -- as
noted, although it is very restricted in behavior -- ? The answer is by using
the pointer. Since function is also an object that should be stored in memory in
definition time, we can use pointer to point that function object, and apply
the result obtained by dereferencing that to arguments.

First let us experiment with the code in the text. Since we haven't typed all
the dependant programs that used in =sort=, first we start to type the library
routines.

And as we learend from previous exercise, it is way too hard debugging program
that has a lot of mutually dependant subroutines. So here for practice, we add
unit test to each of the subcomponents if possible. To do that, here we try to
use =assert.h= library.

=Alloc= and =afree=:
#+BEGIN_SRC C :main no :tangle C_codes/alloc.c :results verbatim
#define ALLOCSIZE 10000         /* size of available space */

static char allocbuf[ALLOCSIZE]; /* storage for alloc */
static char *allocp = allocbuf;  /* next free position */

char *alloc(int n) {            /* return pointer to n characters */
    if (allocbuf + ALLOCSIZE - allocp >= n) { /* it fits */
        allocp += n;
        return allocp - n;       /* old p */
    } else                      /* not enough room */
        return 0;
}

void afree(char *p) {           /* free storage pointed to by p */
    if (p >= allocbuf && p < allocbuf + ALLOCSIZE)
        allocp = p;
}

#include <assert.h>
#include <string.h>
/* testing alloc and free */
int main_(void) {
    int n = 10;
    assert(allocp == allocbuf);        /* before allocating any, it should be initialzied */

    char *teststring = alloc(n);
    assert(teststring == allocbuf); /* the old pointer is bound to newly allocated data */

    assert(allocp == allocbuf + n); /* after allocating n blocks, it should point to next free pointer */
    strcpy(teststring, "123456789"); /* exactly n = 10 block size */

    char *testAlloc = alloc(n);     /* new allocating */
    assert(strcmp(teststring, "123456789") == 0); /* after allocating it should retain previosly allocated one */

    assert(allocp == allocbuf + 2*n); /* before freeing the current pointer */
    /* freeing */
    afree(testAlloc);
    assert(allocp == allocbuf + n); /* the last one freed */

    afree(teststring);
    assert(allocp == allocbuf);    /* reverted to initial pointer */
    char *testLast = alloc(n);  /* make garbages */
    strcpy(testLast, "987654321");                /* destroyed garbage */
    assert(strcmp(teststring, "123456789") != 0); /* the previous one destructed */
}
#+END_SRC

#+RESULTS:

=Readlines=:
#+BEGIN_SRC C :main no :tangle C_codes/readlines.c
#include <string.h>
#include <stdio.h>

#define MAXLEN 1000             /* max length of any input line */
int getLine(char *, int);
char *alloc(int);

/* readlines: read input lines */
int readlines(char *lineptr[], int maxlines) {
    int len, nlines;
    char *p, line[MAXLEN];

    nlines = 0;
    while ((len = getLine(line, MAXLEN)) > 0)
        if (nlines >= maxlines || (p = alloc(len)) == NULL)
            return -1;
        else {
            line[len - 1] = '\0'; /* delete newline */
            strcpy(p, line);
            lineptr[nlines++] = p;
        }
    return nlines;
}

void writelines(char *lineptr[], int nlines) {
    while (nlines-- > 0)
        printf("%s\n", *lineptr++);
}

int main_(void) {
    int maxlines = 100;
    /* spit out what it read */
    char *lineptr[maxlines];

    int nlines = readlines(lineptr, maxlines);
    writelines(lineptr, nlines);
    return 0;
}
#+END_SRC

As this function involves standard input and output, we can not easily implement
the unit test style in C as we did =alloc=.

So here is the test in manual:
#+BEGIN_SRC sh
cd C_codes
cc readlines.c getLine.c alloc.c -o readlines_test
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes
./readlines_test < readlines.c
printf "test" | ./readlines_test
#+END_SRC

#+RESULTS:
#+begin_example
#include <string.h>
#include <stdio.h>

#define MAXLEN 1000             /* max length of any input line */
int getLine(char *, int);
char *alloc(int);

/* readlines: read input lines */
int readlines(char *lineptr[], int maxlines) {
    int len, nlines;
    char *p, line[MAXLEN];

    nlines = 0;
    while ((len = getLine(line, MAXLEN)) > 0)
        if (nlines >= maxlines || (p = alloc(len)) == NULL)
            return -1;
        else {
            line[len - 1] = '\0'; /* delete newline */
            strcpy(p, line);
            lineptr[nlines++] = p;
        }
    return nlines;
}

void writelines(char *lineptr[], int nlines) {
    while (nlines-- > 0)
        printf("%s\n", *lineptr++);
}

int main(void) {
    int maxlines = 100;
    /* spit out what it read */
    char *lineptr[maxlines];

    int nlines = readlines(lineptr, maxlines);
    writelines(lineptr, nlines);
    return 0;
}
tes
#+end_example

As noted before, =readlines= routine did not deal with the case where the last
line is not ended with newline character.

Now let's turn around to our original topic, generalized =sort= program.

#+BEGIN_SRC C :tangle C_codes/sort.c :main no
#include <stdio.h>
#include <string.h>

#define MAXLINES 5000           /* max #lines to be sorted */
char *lineptr[MAXLINES];        /* pointers to text lines */

int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);

void qsort(void *lineptr[], int left, int right,
           int (*comp)(void *, void *));
int numcmp(char *, char *);

/* sort input lines */
int main(int argc, char *argv[]) {
    int nlines;                 /* number of input lines read */
    int numeric = 0;            /* 1 if numeric sort */

    if (argc > 1 && strcmp(argv[1], "-n") == 0)
        numeric = 0;
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
        qsort((void **) lineptr, 0, nlines - 1,
              (int (*)(void *, void *)) (numeric ? numcmp : strcmp));
        writelines(lineptr, nlines);
        return 0;
    } else {
        printf("input too big to sort\n");
        return 1;
    }
}
#+END_SRC

And the generalized quick sort subroutine:
#+BEGIN_SRC C :tangle C_codes/qsort.c :main no

/* qsort: sort v[left]...v[right] into increasing order */
void qsort(void *v[], int left, int right,
           int (*comp)(void *, void *)) {
    int i, last;
    void swap(void *v[], int, int);

    if (left >= right)          /* do nothing if array contains */
        return;                 /* fewer than two elements */
    swap(v, left, (left + right) / 2);
    last = left;
    for (i = left+1; i <= right; i++)
        if ((*comp)(v[i], v[left]) < 0)
            swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last - 1, comp);
    qsort(v, last + 1, right, comp);
}

#include <string.h>
#include <stdio.h>
#include <assert.h>

void swap(void *v[], int i, int j) {
    void *temp;

    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}

/* test qsort */
int main(void) {
    char *test[] = {"9", "7", "8", "5", "2", "6", "3", "4", "1"};
    int len = 9;
    char temp[len];
    qsort((void **) test, 0, len - 1, (int (*)(void *, void *)) strcmp); /* sort */
    while (len-- > 0) {
        sprintf(temp, "%d", len + 1);
        assert(strcmp(temp ,test[len]) == 0); /* test[i] == i + 1 */
    }
}

#+END_SRC

#+RESULTS:
* Test-Driven Development for Embedded C
:PROPERTIES:
:NOTER_DOCUMENT: ../MEGAsync/MIT Challenge/6.001/Test-Driven Development for Embedded C [Grenning 2011-05-05].pdf
:END:
** Getting Started
*** Test-Driving Tools and Conventions
**** Put the Knowledge to Work
***** Setup development system
I've done with Emacs. For the Unity, CppUTest, I've added those modules to
current git project as submodules.
***** Run the Unity Test
Since the lastest version of Unity does not agree with the version used in this
book, we need to decide what to use; as we are novice to this field let us
follow the book's contents since that is what we are meant to learn.

Fortunately, the source code in the website contains the Unity source file also
with which the test configured, we can do execution without any further configurations.

Let's run the test:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make -f MakefileUnity.mk
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
compiling FakeTimeService.c
unity/HomeAutomation/FakeTimeService.c:48:26: error: if statement has empty body [-Werror,-Wempty-body]
    if (callback != NULL);
                         ^
unity/HomeAutomation/FakeTimeService.c:48:26: note: put the semicolon on a separate line to silence this warning
1 error generated.
make: *** [objs/unity/HomeAutomation/FakeTimeService.o] Error 1
#+END_EXAMPLE

Actually there was error in the book's code! The test code meant to eliminate
all the bugs but it has in it. Well, since this is easy stuff, after fixing, let
rerun the test:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make -f MakefileUnity.mk
#+END_SRC

#+RESULTS:
: Running BookCode_Unity_tests
: Unity test run 1 of 1
: ..........!............................................................
: -----------------------
: 71 Tests 0 Failures 1 Ignored
: OK
***** Run the CppUTest Test
The setting up the environment for CppUTest is way more easier than Unity since
CppUTest is available in brew, we can just install it in shell:
#+BEGIN_SRC sh
brew install cpputest
#+END_SRC

And then let's do the works.

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make -f MakefileCppUTest.mk
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
mocks/FakeMicroTime.c:35:6: error: no previous prototype for function 'FakeMicroTime_Init' [-Werror,-Wmissing-prototypes]
void FakeMicroTime_Init(uint32_t start, uint32_t incr)
     ^
mocks/FakeMicroTime.c:54:10: error: no previous prototype for function 'FakeMicroTime_GetDelayDuration' [-Werror,-Wmissing-prototypes]
uint32_t FakeMicroTime_GetDelayDuration(void)
         ^
2 errors generated.
make: *** [objs/mocks/FakeMicroTime.o] Error 1
mocks/FakeMicroTime.c:35:6: error: no previous prototype for function 'FakeMicroTime_Init' [-Werror,-Wmissing-prototypes]
void FakeMicroTime_Init(uint32_t start, uint32_t incr)
     ^
mocks/FakeMicroTime.c:54:10: error: no previous prototype for function 'FakeMicroTime_GetDelayDuration' [-Werror,-Wmissing-prototypes]
uint32_t FakeMicroTime_GetDelayDuration(void)
         ^
2 errors generated.
make: *** [objs/mocks/FakeMicroTime.o] Error 1
#+END_EXAMPLE

This is due to the =-Werror= flag, let's suppress this for now. Then it got:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make -f MakefileCppUTest.mk
#+END_SRC

#+RESULTS:
: Running BookCode_CppUTest_tests
: ..................................................
: ..............................................!...
: ...........................
: OK (127 tests, 126 ran, 525 checks, 1 ignored, 0 filtered out, 3 ms)
:
***** Write more =sprintf()= tests
Here we are going to add more tests. First, as suggested in the book, let us add
the test for the "underrun"

Here is the result.
#+BEGIN_SRC C
#if 1
static char _output[100];
static char *output = &_output[1];
#endif


...


TEST_SETUP(sprintf)
{
#if 1
    memset(_output, 0xaa, sizeof _output);
#endif
#if 0
    memset(output, 0xaa, sizeof output);
#endif
    expected = "";
}

...

static void given(int charsWritten)
{
    TEST_ASSERT_EQUAL(strlen(expected), charsWritten);
    TEST_ASSERT_EQUAL_STRING(expected, output);
    TEST_ASSERT_BYTES_EQUAL(0xaa, output[strlen(expected) + 1]);
#if 1
    TEST_ASSERT_BYTES_EQUAL(0xaa, _output[0]);
#endif
}
#+END_SRC

Let's check this new test!

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling SprintfTest.c
: Running BookCode_Unity_tests
: Unity test run 1 of 1
: ..........!............................................................
: -----------------------
: 71 Tests 0 Failures 1 Ignored
: OK

Now let's add new test case not the fixture:
#+BEGIN_SRC C
TEST(sprintf, InsertInteger)
{
    expect("20");
    given(sprintf(output, "%d", 20));
}
#+END_SRC

Then let's run!

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling SprintfTest.c
: Running BookCode_Unity_tests
: Unity test run 1 of 1
: ..........!............................................................
: -----------------------
: 71 Tests 0 Failures 1 Ignored
: OK

This time let's stud bug in it and see the change:
#+BEGIN_SRC C
TEST(sprintf, InsertInteger)
{
    expect("21");
    given(sprintf(output, "%d", 20));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling SprintfTest.c
: Running BookCode_Unity_tests
: Unity test run 1 of 1
: ..........!............................................................
: -----------------------
: 71 Tests 0 Failures 1 Ignored
: OK

Oops! Our bug didn't get revealed! This is since we didn't update
=SprintfTestRunner.c= file appropriately. So we need to add the following line
into =TEST_GROUP_RUNNER=:
#+BEGIN_SRC C
    RUN_TEST_CASE(sprintf, InsertInteger);
#+END_SRC

Then,
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
Running BookCode_Unity_tests
Unity test run 1 of 1
..........!.........
TEST(sprintf, InsertInteger)
    unity/stdio/SprintfTest.c:68: FAIL:
    Expected '21' Was '20'
....................................................
-----------------------
72 Tests 1 Failures 1 Ignored
FAIL
#+end_example

Now it spit out as expected with increased number of tests. Then fix the bug and
rerun the test:

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: Running BookCode_Unity_tests
: Unity test run 1 of 1
: ..........!.............................................................
: -----------------------
: 72 Tests 0 Failures 1 Ignored
: OK

Lastly, let's test what test hidden in =SprintfTestRunner.c= file:
#+BEGIN_SRC C
    RUN_TEST_CASE(sprintf, StringWithSpace);
#+END_SRC

That is, =sprintf= should print the white spaces appropriately:
#+BEGIN_SRC C
TEST(sprintf, StringWithSpace)
{
    expect("Space should be	approriately printed");
    given(sprintf(output, "Space%cshould be%capproriately printed", ' ', '\t'));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: Running BookCode_Unity_tests
: Unity test run 1 of 1
: ..........!..............................................................
: -----------------------
: 73 Tests 0 Failures 1 Ignored
: OK

Now the CppUTest versions:
#+BEGIN_SRC C
#if 1
    char _output[100];
    char *output = &_output[1];
#else
    char output[100];
#endif

...

#if 1
        memset(_output, 0xaa, sizeof _output);
#else
        memset(output, 0xaa, sizeof output);
#endif

...

        BYTES_EQUAL(0xaa, _output[0]);
#+END_SRC

Then test!
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeCppUTest
#+END_SRC

#+RESULTS:
: make -i -f MakefileCppUTest.mk
: Running BookCode_CppUTest_tests
: ..................................................
: ................................................!.
: .............................
: OK (129 tests, 128 ran, 535 checks, 1 ignored, 0 filtered out, 2 ms)
:

Works as expected.
***** Modify =TEST_GROUP(Sprintf)=
That is, we need to modify the size of =output= dynamically. Fortunately we can
extract the length of resulting =output= array via =expect=; so it implies we
need to allocate the =output= in the =expect= function. Since the order of
evaluation already fixed as calling =expect= and then =given=, we don't have to
change that structure at all.

All we need to do is delegate allocation from external definition and
=TEST_SETUP= to =expect=.

Here is the results:
#+BEGIN_SRC C
#if 1
static char *_output;
static char *output;
#endif

static void expect(const char * s)
{
    int newLen = strlen(s) + 3; /* null chracter + check overrun + check underrun */

    expected = s;

    /* dynamic allocation */
    _output = calloc(newLen, sizeof(char));
    memset(_output, 0xaa, newLen);
    output = &_output[1];
}
#+END_SRC


Then check
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
Running BookCode_Unity_tests
Unity test run 1 of 1
..........!.......
TEST(sprintf, NoFormatOperations)
    unity/stdio/SprintfTest.c:159:FAIL: This test leaks!
.
TEST(sprintf, InsertString)
    unity/stdio/SprintfTest.c:159:FAIL: This test leaks!
.
TEST(sprintf, InsertInteger)
    unity/stdio/SprintfTest.c:159:FAIL: This test leaks!
.
TEST(sprintf, StringWithSpace)
    unity/stdio/SprintfTest.c:159:FAIL: This test leaks!
....................................................
-----------------------
73 Tests 0 Failures 1 Ignored
OK
#+end_example

Oops! It complains about the memory leakage!

We should =free= what we allocated dynamically:
#+BEGIN_SRC C
TEST_TEAR_DOWN(sprintf)
{
#if 1
    free(_output);
#endif
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code
make codeUnity
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: Running BookCode_Unity_tests
: Unity test run 1 of 1
: ..........!..............................................................
: -----------------------
: 73 Tests 0 Failures 1 Ignored
: OK

Now it works fine.
*** Starting a C Module
**** Put the Knowledge to Work
***** Start your own =LedDriver=
The author of this book provides us the starting point of the project in
=code/SandBox=. Unfortunately, there is no =README.txt= for us to follow; but as
it is quite simple and straightforward code, we can look through the code to
start.

All we need to do is just follow what the text did in this section and
experience with our own.

Let us remind ourselves the specifications we need to implement:
- All LEDs are off after the driver is initialized.
- A single LED can be turned on.
- A single LED can be turned off.
- Multiple LEDs can be turned on/off.
- Turn on all LEDs.
- Turn off all LEDs.
- Query LED state.
- Check boundary values.
- Check out-of-bounds values.


Actually those is already processed one: At the very first, we need to deduce
the above specifications from more abstract, ambiguous one; but for this
specific case, these are trivial ones. So let us focus the implementation of
tests for now. We will have to consider the design issues later for more complex
real world application.

First, let's write starting point.
#+BEGIN_SRC C
TEST(LedDriver, StartHere)
{
   TEST_FAIL_MESSAGE("Start here");
}
#+END_SRC

Then try the test:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
Running SandBox_Unity_tests
Unity test run 1 of 1
.
TEST(LedDriver, StartHere)
    unity/LedDriver/LedDriverTest.c:44:FAIL: Start here

-----------------------
1 Tests 1 Failures 0 Ignored
FAIL
#+end_example

Now we can start from there!

As did in the book, let's start from the =LedsOffAfterCreate= first.

See whether it is updated:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
Running SandBox_Unity_tests
Unity test run 1 of 1
.
TEST(LedDriver, LedsOffAfterCreate)
    unity/LedDriver/LedDriverTest.c:44:FAIL: Start here

-----------------------
1 Tests 1 Failures 0 Ignored
FAIL
#+end_example

Now let's fake out it:
#+BEGIN_SRC C
TEST(LedDriver, LedsOffAfterCreate)
{
    uint16_t virtualLeds = 0xffff; /* the LEDs on by connection */
    LedDriver_Create(&virtualLeds);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
unity/LedDriver/LedDriverTest.c:46:22: error: too many arguments to function call, expected 0, have 1
    LedDriver_Create(&virtualLeds);
    ~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~
./include/LedDriver/LedDriver.h:30:1: note: 'LedDriver_Create' declared here
void LedDriver_Create(void);
^
1 error generated.
make[1]: [objs/./unity/LedDriver/LedDriverTest.o] Error 1 (ignored)
Linking SandBox_Unity_tests
clang: error: no such file or directory: 'objs/./unity/LedDriver/LedDriverTest.o'
make[1]: [SandBox_Unity_tests] Error 1 (ignored)
Running SandBox_Unity_tests
Unity test run 1 of 1
.
TEST(LedDriver, LedsOffAfterCreate)
    unity/LedDriver/LedDriverTest.c:44:FAIL: Start here

-----------------------
1 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Cool! we have progressed since it detect our implementation is not sufficient.
Let's complement that. First, let's modify the prototype of the function with error.
#+BEGIN_SRC C
void LedDriver_Create(uint16_t *);
...
void LedDriver_Create(uint16_t *address)
{
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
Running SandBox_Unity_tests
Unity test run 1 of 1
.
TEST(LedDriver, LedsOffAfterCreate)
    unity/LedDriver/LedDriverTest.c:46: FAIL:
    Expected 0x0000 Was 0xFFFF

-----------------------
1 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now it's time to implement the source code:
#+BEGIN_SRC C
void LedDriver_Create(uint16_t *address)
{
    *address = 0;
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: .
: -----------------------
: 1 Tests 0 Failures 0 Ignored
: OK

I myself have the impression that TDD is bottom up approach whereas BDD top down
approach, which is the same approach in the different angle from wishful
thinking that we leared from SICP.

But in the text book, it says
#+BEGIN_QUOTE
The first few tests drive the interface design. The focus on the interface means
that we're working form the outside of the code being developed to the inside.
#+END_QUOTE

Which implies, TDD is based on the top down approach rather than bottom up
fashion. Actually we can think of the BDD as extension of TDD in a more top down
manner.

So let's start with the boundary conditions to fixate the interface from outside
of it; that is, we going to implement the second specification among the list.

#+BEGIN_SRC C
TEST(LedDriver, TurnOnLedOne)
{
    uint16_t virtualLeds;       /* get the address of LEDs */
    LedDriver_Create(&virtualLeds); /* initialize the LEDs */
    LedDriver_TurnOn(1);            /* turn on #1 of LEDs */
    TEST_ASSERT_EQUAL_HEX16(1, virtualLeds);
}
#+END_SRC

Then setup and run the test:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
unity/LedDriver/LedDriverTest.c:53:5: error: implicit declaration of function 'LedDriver_TurnOn' is invalid in C99 [-Werror,-Wimplicit-function-declaration]
    LedDriver_TurnOn(1);            /* turn on #1 of LEDs */
    ^
1 error generated.
make[1]: [objs/./unity/LedDriver/LedDriverTest.o] Error 1 (ignored)
Linking SandBox_Unity_tests
clang: error: no such file or directory: 'objs/./unity/LedDriver/LedDriverTest.o'
make[1]: [SandBox_Unity_tests] Error 1 (ignored)
Running SandBox_Unity_tests
Unity test run 1 of 1
.
-----------------------
1 Tests 0 Failures 0 Ignored
OK
#+end_example

It complains that we have not provided the protype of function. Let's provide
minimal code to pass that error:
#+BEGIN_SRC C
void LedDriver_TurnOn(int);

...

void LedDriver_TurnOn(int ledNumber)
{
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..
TEST(LedDriver, TurnOnLedOne)
    unity/LedDriver/LedDriverTest.c:54: FAIL:
    Expected 0x0001 Was 0x0000

-----------------------
2 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now it detects the bug appropriately. Let's add minimal source code to pass the
test. To do that, we need to add private variable that would be used in
=LedDriver_...= ADT; that is, our =TurnOn= function needs the address of LEDs to
turn on and that is passed to =Create=. It implies we need to make =address= as
static external variable that would be shared in the =LedDriver= source file:
#+BEGIN_SRC C
static uint16_t *ledsAddress;

void LedDriver_Create(uint16_t *address)
{
    ledsAddress = address;
    *ledsAddress = 0;
}
#+END_SRC

And the hard-coding:
#+BEGIN_SRC C
void LedDriver_TurnOn(int ledNumber)
{
    *ledsAddress = 1;
}
#+END_SRC

Let's check:

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..
-----------------------
2 Tests 0 Failures 0 Ignored
OK
#+end_example

Next, we are going to implement the third requirement; yes we ain't done with
the previous ones but, as we noted before, we are going to make interface
concrete with /code vice/:
#+BEGIN_SRC C
TEST(LedDriver, TurnOffLedOne)
{
    uint16_t virtualLeds;
    LedDriver_Create(&virtualLeds);
    LedDriver_TurnOn(1);
    LedDriver_TurnOff(1);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
}
#+END_SRC

And, as usual, provide minimal code to make the compiler happy:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...
TEST(LedDriver, TurnOffLedOne)
    unity/LedDriver/LedDriverTest.c:63: FAIL:
    Expected 0x0000 Was 0x0001

-----------------------
3 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

This time we are going to hard-code again:
#+BEGIN_SRC C
void LedDriver_TurnOff(int ledNumber)
{
    *ledsAddress = 0;
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...
-----------------------
3 Tests 0 Failures 0 Ignored
OK
#+end_example

As all the tests written passed, it's time to refactor /on green/; you would be
uncomfortable with the duplicate code: Initialization of LEDs address and link
that with =LedDriver=.

#+BEGIN_SRC C
TEST_GROUP(LedDriver);

static uint16_t virtualLeds;

TEST_SETUP(LedDriver)
{
    LedDriver_Create(&virtualLeds);
}
#+END_SRC


Then re-run the test to check all the previous behavior works as expected:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
unity/LedDriver/LedDriverTest.c:47:14: error: declaration shadows a variable in the global scope [-Werror,-Wshadow]
    uint16_t virtualLeds = 0xffff; /* the LEDs on by connection */
             ^
unity/LedDriver/LedDriverTest.c:34:17: note: previous declaration is here
static uint16_t virtualLeds;
                ^
1 error generated.
make[1]: [objs/./unity/LedDriver/LedDriverTest.o] Error 1 (ignored)
Linking SandBox_Unity_tests
clang: error: no such file or directory: 'objs/./unity/LedDriver/LedDriverTest.o'
make[1]: [SandBox_Unity_tests] Error 1 (ignored)
Running SandBox_Unity_tests
Unity test run 1 of 1
...
-----------------------
3 Tests 0 Failures 0 Ignored
OK
#+end_example

Actually we need to change the statement of definition of =virtualLeds= in the
=LedsOffAfterCreate= test case to assignment:
#+BEGIN_SRC C
TEST(LedDriver, LedsOffAfterCreate)
{
    virtualLeds = 0xffff; /* the LEDs on by connection */
    LedDriver_Create(&virtualLeds);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling LedDriverTest.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: ...
: -----------------------
: 3 Tests 0 Failures 0 Ignored
: OK

Now we have caught the pace of book.
***** Write a test list for a first-in first-our =CircularBuffer=
Here we consider what we delegated or assumed in the preceding exercise: Deduce
the specification from more abstract and ambiguous one.

This data structure is queue. There are several ambiguities lurking around:
- Should the queue initialized based on the user handed value? E.g. the size of
  buffer?
- Should we extend the size of the queue if it is overflowed with the elements?


These ambiguity is due to the static property of C language. The main feature of
requested one is first-in first-out property; we should rephrase this feature in
the more specific words. The base case can be expressed as
- With fresh =CircularBuffer=, if one input an integer value to that, one should
  get the same value by popping.


More generally,
- If there were made /n/ number of pushing as whole, and if /m/ is less than or
  equals to /n/, /m/ th popping should retrieve the integer pushed /m/ th
  counting from the first pushing.


We need to resolve the abstruse specification with concrete test cases.

For testing, we need to resolve the ambiguities posed above. It is totally
arbitrary for this situation since there is no other constraint; or we can take
these ambiguities as implementation details we can exploit.

So here we are going to specify those in the perspective of easiness of
implementation:
- =CircularBuffer= is initialized with size user supplied.
- One can put an integer value into =CircularBuffer=.
- One can retrieve an integer value from =CircularBuffer= if the number of push
  is greater than or equals to the number of pop, including currently made one.
- The value got by popping that was made /m/ th only counting the pops from the
  first pop should be the one pushed at /m/ th only counting the pushes.


The last one specifies the contraction between the pop and push.

****** Revision the Test list
Actually, with above specifications we can not decide how to implement our tests
in concrete sense and I've learned not to think what I don't need to think for
now in SICP. But we can not stick with that, at least for now, since TDD
progress in slightly different direction.

The answer the author thinks as correct is posted on [[http://blog.wingman-sw.com/tdd-guided-by-zombies][his blog]]; we should rethink
the specifications in different perspective since we are going to implement
concretely.

From his blog, I've realized that I've misunderstood the TDD a lot although I'm
really newbie to TDD world. I myself assumed implicitly that TDD would align
with the wishful thinking and it would design with that idea behind.

With that mind, as I acquaint with the wishful thinking, I've listed above
specifications in contraction manner the submodules should satisfy. But this
list is the result of designing the main module.

So in wishful thinking, we first experiment with the given problem to deduce or
design the specifications. By this reasoning, I've said that list the
specifications is not the starting point in principle.

I've expected that my reasoning does not hold; but it seems like hold but in the
totally opposite direction: Test list is not the specifications. We need to
design the topmost abstraction layer; and then we can start to figure out tests
we need to implement.

As evidence for this observation, the author states the presumed operations --
=Get()=, =Put()=, =Create()=, =IsEmpty()=, =IsFull()= -- plainly; these
operations is the result of wishful thinking. In higher level language like
Scheme (or Lisp) and Java, Python, Haskell, ML, and so on the remaining task is
mostly trivial ones and straightforward concepts.

But in C, it is not so trivial to implement the rest pieces since we have to
count the memory leakage and all the other runtime errors like overrun or
underrun and so on.

As a solution or method, one rules out the methods to tackle with these
problems; or to implement the rest correctly, one would use the TDD method.
Mostly, one use BDD approach to exploit the wishful thinking paradigm.

TDD is more implementation strategy than paradigm since one should have done
with the topmost abstraction design. For the test phase, one should got concrete
idea how one going to implement given task.

First we define the behaviors we want from our resulting product. This is
actually the ones we listed above saying as "this is the test list."

Now we should think how we are going to implement the task. Since we are
programming in C, it is natural to use the memory structure, array, as backbone
of our data structure. Even if with this backbone we can support the dynamically
evolving =CircularBuffer=; but as we said before this is implementation details,
for simplicity we will use the static size of backbone. Then we can list out the
tests:
- Empty case
- Full case
- Overflow case
- Underflow case
- Wrap around case


These are also the cases we should handle in the implementation. We can deduce
those by experimenting with the data structure model we are going to make
concrete. Since above list also somewhat abstract, let's open up the tests that
we are going to implement in this section:
- Empty test ::
  - The buffer should be empty right after the creation.
  - The buffer should not be empty right after =push=.
- Full test ::
  - The buffer should not be full right after the creation.
- =Push= and =Pop= test ::
  - The buffer should be empty if one push value into the fresh buffer and
    rightafter pop that.
  - If one start with fresh buffer, push one value and pop from that buffer, the
    popped value should be same as the pushed one.

***** Start test-driving the =CircularBuffer=
Here we are going to implement the TDD only the amount that is done in this
section.

The first step is writing failling test:
#+BEGIN_SRC C
TEST(CircularBuffer, EmptyAfterCreation)
{
    TEST_FAIL_MESSAGE("Start from here");
}
#+END_SRC

And wire up all the other files. And then we got:

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
....
TEST(CircularBuffer, EmptyAfterCreation)
    unity/CircularBuffer/CircularBufferTest.c:15:FAIL: Start from here

-----------------------
4 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Then let's implement the test code as
#+BEGIN_SRC C
TEST(CircularBuffer, EmptyAfterCreation)
{
    CircularBuffer *buf = CircularBuffer_Create();
    TEST_ASSERT_TRUE(IsEmpty(buf));
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
unity/CircularBuffer/CircularBufferTest.c:15:5: error: use of undeclared identifier 'CircularBuffer'
    CircularBuffer *buf = CircularBuffer_Create();
    ^
unity/CircularBuffer/CircularBufferTest.c:15:21: error: use of undeclared identifier 'buf'
    CircularBuffer *buf = CircularBuffer_Create();
                    ^
unity/CircularBuffer/CircularBufferTest.c:15:27: error: implicit declaration of function 'CircularBuffer_Create' is invalid in C99 [-Werror,-Wimplicit-function-declaration]
    CircularBuffer *buf = CircularBuffer_Create();
                          ^
unity/CircularBuffer/CircularBufferTest.c:16:22: error: implicit declaration of function 'IsEmpty' is invalid in C99 [-Werror,-Wimplicit-function-declaration]
    TEST_ASSERT_TRUE(IsEmpty(buf));
                     ^
unity/CircularBuffer/CircularBufferTest.c:16:30: error: use of undeclared identifier 'buf'
    TEST_ASSERT_TRUE(IsEmpty(buf));
                             ^
5 errors generated.
make[1]: [objs/./unity/CircularBuffer/CircularBufferTest.o] Error 1 (ignored)
compiling CircularBuffer.c
src/CircularBuffer/CircularBuffer.c:1:10: fatal error: 'CircularBuffer.h' file not found
#include "CircularBuffer.h"
         ^~~~~~~~~~~~~~~~~~
1 error generated.
make[1]: [objs/./src/CircularBuffer/CircularBuffer.o] Error 1 (ignored)
Building archive lib/libSandBox_Unity.a
ar: objs/./src/CircularBuffer/CircularBuffer.o: No such file or directory
r - objs/./src/LedDriver/LedDriver.o
a - objs/./src/CircularBuffer/CircularBuffer.o
make[1]: [lib/libSandBox_Unity.a] Error 1 (ignored)
Linking SandBox_Unity_tests
clang: error: no such file or directory: 'objs/./unity/CircularBuffer/CircularBufferTest.o'
make[1]: [SandBox_Unity_tests] Error 1 (ignored)
Running SandBox_Unity_tests
Unity test run 1 of 1
....
TEST(CircularBuffer, EmptyAfterCreation)
    unity/CircularBuffer/CircularBufferTest.c:15:FAIL: Start from here

-----------------------
4 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Yes it complains about undefined types. It's time to add those.

=CircularBuffer.h=
#+BEGIN_SRC C
#ifndef CIRCULAR_BUFFER
#define CIRCULAR_BUFFER
#include <stdbool.h>
typedef struct CircularBufferStructure CircularBuffer;
CircularBuffer *CircularBuffer_Create(void);
bool IsEmpty(*CircularBuffer);

#endif // CIRCULAR_BUFFER
#+END_SRC

Then now
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
Linking SandBox_Unity_tests
Undefined symbols for architecture x86_64:
  "_CircularBuffer_Create", referenced from:
      _TEST_CircularBuffer_EmptyAfterCreation_ in CircularBufferTest.o
  "_IsEmpty", referenced from:
      _TEST_CircularBuffer_EmptyAfterCreation_ in CircularBufferTest.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[1]: [SandBox_Unity_tests] Error 1 (ignored)
Running SandBox_Unity_tests
/bin/sh: ./SandBox_Unity_tests: No such file or directory
make[1]: [all] Error 127 (ignored)
#+end_example

Now we need to implement those undefined functions to pass the tests:
#+BEGIN_SRC C
CircularBuffer *CircularBuffer_Create(void)
{
}

bool IsEmpty(CircularBuffer *buf)
{
    true;
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
src/CircularBuffer/CircularBuffer.c:5:1: error: control reaches end of non-void function [-Werror,-Wreturn-type]
}
^
src/CircularBuffer/CircularBuffer.c:10:1: error: control reaches end of non-void function [-Werror,-Wreturn-type]
}
^
2 errors generated.
make[1]: [objs/./src/CircularBuffer/CircularBuffer.o] Error 1 (ignored)
Building archive lib/libSandBox_Unity.a
ar: objs/./src/CircularBuffer/CircularBuffer.o: No such file or directory
r - objs/./src/LedDriver/LedDriver.o
make[1]: [lib/libSandBox_Unity.a] Error 1 (ignored)
/Library/Developer/CommandLineTools/usr/bin/ranlib: file: lib/libSandBox_Unity.a(CircularBuffer.o) has no symbols
Linking SandBox_Unity_tests
Undefined symbols for architecture x86_64:
  "_CircularBuffer_Create", referenced from:
      _TEST_CircularBuffer_EmptyAfterCreation_ in CircularBufferTest.o
  "_IsEmpty", referenced from:
      _TEST_CircularBuffer_EmptyAfterCreation_ in CircularBufferTest.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[1]: [SandBox_Unity_tests] Error 1 (ignored)
Running SandBox_Unity_tests
/bin/sh: ./SandBox_Unity_tests: No such file or directory
make[1]: [all] Error 127 (ignored)
#+end_example

So we have to construct the forward declared =CircularBuffer= to make the
compiler happy:
#+BEGIN_SRC C
struct CircularBufferStructure {
    int going_to_be_implemented;
};

CircularBuffer *CircularBuffer_Create(void)
{
    CircularBuffer *temp = NULL;
    return temp;
}

bool IsEmpty(CircularBuffer *buf)
{
    return true;
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
....
-----------------------
4 Tests 0 Failures 0 Ignored
OK
#+end_example

Now we turn to the next clause -- =IsFull=:
#+BEGIN_SRC C
TEST(CircularBuffer, NotFullAfterCreation)
{
    CircularBuffer *buf = CircularBuffer_Create();
    TEST_ASSERT_FALSE(IsFull(buf));
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
unity/CircularBuffer/CircularBufferTest.c:23:23: error: implicit declaration of function 'IsFull' is invalid in C99 [-Werror,-Wimplicit-function-declaration]
    TEST_ASSERT_FALSE(IsFull(buf));
                      ^
1 error generated.
make[1]: [objs/./unity/CircularBuffer/CircularBufferTest.o] Error 1 (ignored)
Linking SandBox_Unity_tests
clang: error: no such file or directory: 'objs/./unity/CircularBuffer/CircularBufferTest.o'
make[1]: [SandBox_Unity_tests] Error 1 (ignored)
Running SandBox_Unity_tests
Unity test run 1 of 1
....
-----------------------
4 Tests 0 Failures 0 Ignored
OK
#+end_example

As the test needs the code, let's provide it:
#+BEGIN_SRC C
bool IsFull(CircularBuffer *);

bool IsFull(CircularBuffer *buf)
{
    return true;
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.....
TEST(CircularBuffer, NotFullAfterCreation)
    unity/CircularBuffer/CircularBufferTest.c:23:FAIL: Expected FALSE Was TRUE

-----------------------
5 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now it's time to hard-code:
#+BEGIN_SRC C
bool IsFull(CircularBuffer *buf)
{
    return false;
}
#+END_SRC

Then,
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.....
-----------------------
5 Tests 0 Failures 0 Ignored
OK
#+end_example

Now it's time to refactor the test code since we have encountered with
duplication:
#+BEGIN_SRC C
TEST_GROUP(CircularBuffer);

static CircularBuffer *buf;

TEST_SETUP(CircularBuffer)
{
    buf = CircularBuffer_Create();
}

TEST_TEAR_DOWN(CircularBuffer)
{
    CircularBuffer_Destroy(buf);
}

TEST(CircularBuffer, EmptyAfterCreation)
{
    TEST_ASSERT_TRUE(IsEmpty(buf));
}

TEST(CircularBuffer, NotFullAfterCreation)
{
    TEST_ASSERT_FALSE(IsFull(buf));
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling CircularBufferTest.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: .....
: -----------------------
: 5 Tests 0 Failures 0 Ignored
: OK

Now let's rename the =CircularBuffer= as pointer:
#+BEGIN_SRC C
typedef struct CircularBufferStructure *CircularBuffer;
#+END_SRC

Since this is really the type buffer variable would have. With the subsequent
change, let's check whether it works as it is:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.....
-----------------------
5 Tests 0 Failures 0 Ignored
OK
#+end_example

We could stop the coding for this section at this point, but actually we can
pass more tests as outlined in preceding test list:
#+BEGIN_SRC C
TEST(CircularBuffer, NotEmptyAfterPush)
{
    CircularBuffer_Push(48);
    TEST_ASSERT_FALSE(CircularBuffer_IsEmpty(buf));
}
#+END_SRC

Then the minimum code:
#+BEGIN_SRC C
/* Mutators */
void CircularBuffer_Push(int val)
{
}
#+END_SRC

Then the compiler spits:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
......
TEST(CircularBuffer, NotEmptyAfterPush)
    unity/CircularBuffer/CircularBufferTest.c:31:FAIL: Expected FALSE Was TRUE

-----------------------
6 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

No longer fake out with =NULL= pointer; here we need another fake, =flag=:
#+BEGIN_SRC C
enum {EMPTY = 1, FULL = 2};
/* Implementation of type */
struct CircularBufferStructure {
    int going_to_be_implemented;
    int flag;
};

/* Constructor */
CircularBuffer CircularBuffer_Create(void)
{
    CircularBuffer buf = malloc(sizeof(struct CircularBufferStructure));
    buf->flag = EMPTY;
    return buf;
}

/* Destructor */
void CircularBuffer_Destroy(CircularBuffer buf)
{
    free(buf);
}

/* Predicates */
bool CircularBuffer_IsEmpty(CircularBuffer buf)
{
    return buf->flag & EMPTY;
}

bool CircularBuffer_IsFull(CircularBuffer buf)
{
    return buf->flag & FULL;
}

/* Mutators */
void CircularBuffer_Push(int val, CircularBuffer buf)
{
    buf->flag = 0;
}
#+END_SRC

Then let's check the test:
#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
......
-----------------------
6 Tests 0 Failures 0 Ignored
OK
#+end_example

Then now retrieve test:
#+BEGIN_SRC C
TEST(CircularBuffer, OnePopShouldSameAsOnePushed)
{
    int pushed = 48;
    CircularBuffer_Push(pushed, buf);
    TEST_ASSERT_EQUAL(pushed, (CircularBuffer_Pop(buf)));
}
#+END_SRC

Then let's make compiler happy:
#+BEGIN_SRC C
int CircularBuffer_Pop(CircularBuffer buf)
{
    return 0;
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.......
TEST(CircularBuffer, OnePopShouldSameAsOnePushed)
    unity/CircularBuffer/CircularBufferTest.c:38: FAIL:
    Expected 48 Was 0

-----------------------
7 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

And here is the hard coding:
#+BEGIN_SRC C
int CircularBuffer_Pop(CircularBuffer buf)
{
    return 48;
}
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports both
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.......
-----------------------
7 Tests 0 Failures 0 Ignored
OK
#+end_example

Good to go.
*** Testing Your Way to Done
**** Grow the Solution from Simple Beginnings
Let us follows the books contents of this section within the =Sandbox= folder.

First add the next test case that would lead to get rid of all the fake codes:
#+BEGIN_SRC C
TEST(LedDriver, TurnOnMultiplesLeds)
{
    LedDriver_TurnOn(9);
    LedDriver_TurnOn(8);
    TEST_ASSERT_EQUAL_HEX16(0x180, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
Running SandBox_Unity_tests
Unity test run 1 of 1
....
TEST(LedDriver, TurnOnMultiplesLeds)
    unity/LedDriver/LedDriverTest.c:67: FAIL:
    Expected 0x0180 Was 0x0001
....
-----------------------
8 Tests 1 Failures 0 Ignored
FAIL
#+end_example

Then code:
#+BEGIN_SRC C
void LedDriver_TurnOn(int ledNumber)
{
    *ledsAddress |= 1 << (ledNumber - 1);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
........
-----------------------
8 Tests 0 Failures 0 Ignored
OK
#+end_example

And refactor on green:
#+BEGIN_SRC C
static uint16_t convertedLedNumberToBit(int ledNumber)
{
    return 1 << (ledNumber - 1);
}

void LedDriver_TurnOn(int ledNumber)
{
    *ledsAddress |= convertedLedNumberToBit(ledNumber);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
........
-----------------------
8 Tests 0 Failures 0 Ignored
OK
#+end_example

And move to next -- get rid of the next fake code:
#+BEGIN_SRC C
TEST(LedDriver, TurnOffAnyLed)
{
    LedDriver_TurnOn(9);
    LedDriver_TurnOn(8);
    LedDriver_TurnOff(8);
    TEST_ASSERT_EQUAL_HEX16(0x100, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.....
TEST(LedDriver, TurnOffAnyLed)
    unity/LedDriver/LedDriverTest.c:75: FAIL:
    Expected 0x0100 Was 0x0000
....
-----------------------
9 Tests 1 Failures 0 Ignored
FAIL
#+end_example

Before doing that, we would be better to test the other case first to flow
naturally:
#+BEGIN_SRC C
TEST(LedDriver, AllOn)
{
    LedDriver_TurnAllOn();
    TEST_ASSERT_EQUAL_HEX16(0xffff, virtualLeds);
}
#+END_SRC

And implementation:
#+BEGIN_SRC C
void LedDriver_TurnAllOn(void)
{
    *ledsAddress = 0xffff;
}
#+END_SRC

We've commented out the previous failing test:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling LedDriverTestRunner.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: .........
: -----------------------
: 9 Tests 0 Failures 0 Ignored
: OK

And now refactor on green:
#+BEGIN_SRC C
enum {ALL_LEDS_ON = ~0, ALL_LEDS_OFF = ~ALL_LEDS_ON};

void LedDriver_TurnAllOn(void)
{
    ,*ledsAddress = ALL_LEDS_ON;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.........
-----------------------
9 Tests 0 Failures 0 Ignored
OK
#+end_example

Then the previous test got
#+BEGIN_SRC C
TEST(LedDriver, TurnOffAnyLed)
{
    LedDriver_TurnAllOn();
    LedDriver_TurnOff(8);
    TEST_ASSERT_EQUAL_HEX16(0xff7f, virtualLeds);
}
#+END_SRC

Then implementation:
#+BEGIN_SRC C
void LedDriver_TurnOff(int ledNumber)
{
    *ledsAddress &= ~(convertedLedNumberToBit(ledNumber));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..........
-----------------------
10 Tests 0 Failures 0 Ignored
OK
#+end_example

Now let's turn to the hardware's limitation:
#+BEGIN_SRC C
TEST(LedDriver, LedMemoryIsNotReadable)
{
    virtualLeds = 0xffff;
    LedDriver_TurnOn(8);
    TEST_ASSERT_EQUAL_HEX16(0x80, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.......
TEST(LedDriver, LedMemoryIsNotReadable)
    unity/LedDriver/LedDriverTest.c:87: FAIL:
    Expected 0x0080 Was 0xFFFF
....
-----------------------
11 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

We can fix this by preserving the LEDs state:
#+BEGIN_SRC C
static uint16_t *ledsAddress;
static uint16_t ledsImage;

void LedDriver_Create(uint16_t *address)
{
    ledsAddress = address;
    ledsImage = ALL_LEDS_OFF;
    ,*ledsAddress = ledsImage;
}

void LedDriver_TurnOn(int ledNumber)
{
    ledsImage|= convertedLedNumberToBit(ledNumber);
    ,*ledsAddress = ledsImage;
}

void LedDriver_TurnOff(int ledNumber)
{
    ledsImage &= ~(convertedLedNumberToBit(ledNumber));
    ,*ledsAddress = ledsImage;
}

void LedDriver_TurnAllOn(void)
{
    ledsImage = ALL_LEDS_ON;
    ,*ledsAddress = ledsImage;
}
#+END_SRC

That is, change the virtual image of LEDs and then update the actual LEDs to be
consistent with that image.

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...........
-----------------------
11 Tests 0 Failures 0 Ignored
OK
#+end_example

Refactor on green. Let's capture that meaning into code:
#+BEGIN_SRC C
static void updateHardware(void)
{
    ,*ledsAddress = ledsImage;
}

void LedDriver_Create(uint16_t *address)
{
    ledsAddress = address;
    ledsImage = ALL_LEDS_OFF;
    updateHardware();
}
...
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...........
-----------------------
11 Tests 0 Failures 0 Ignored
OK
#+end_example

Now we turn to the boundary conditions:
#+BEGIN_SRC C
TEST(LedDriver, UpperAndLowerBounds)
{
    LedDriver_TurnOn(1);
    LedDriver_TurnOn(16);
    TEST_ASSERT_EQUAL_HEX16(0x8001, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
............
-----------------------
12 Tests 0 Failures 0 Ignored
OK
#+end_example

Which is expected.

Now we ensure that the mutation over the range does not cause any harm to LEDs:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsChangesNothing)
{
    LedDriver_TurnOn(-1);
    LedDriver_TurnOn(0);
    LedDriver_TurnOn(17);
    LedDriver_TurnOn(3141);

    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.........
TEST(LedDriver, OutOfBoundsChangesNothing)
    unity/LedDriver/LedDriverTest.c:104: FAIL:
    Expected 0x0000 Was 0x0010
....
-----------------------
13 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Is what you expected? I have no prior guess, so let's find out what happend to
each of calling.

#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsChangesNothing)
{
    LedDriver_TurnOn(-1);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(0);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(17);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(3141);

    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.........
TEST(LedDriver, OutOfBoundsChangesNothing)
    unity/LedDriver/LedDriverTest.c:107: FAIL:
    Expected 0x0000 Was 0x0010
....
-----------------------
13 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

It still complains about the line number 107. Then let's try out this:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsChangesNothing)
{
    LedDriver_TurnOn(-1);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(0);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(17);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(3141);

    /* TEST_ASSERT_EQUAL_HEX16(0, virtualLeds); */
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling LedDriverTest.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: .............
: -----------------------
: 13 Tests 0 Failures 0 Ignored
: OK

So only the last case was the problem. Why is that? If we flip over one page, we
got the answer -- shifting is rotated around the 32-bit =int=, in other machines
I guess it would be the default =int= size.

What means we can experiment that by testing the boundary cases like the text
book did.
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsChangesNothing)
{
    LedDriver_TurnOn(-1);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(0);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(17);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(33);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(3141);

    /* TEST_ASSERT_EQUAL_HEX16(0, virtualLeds); */
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.........
TEST(LedDriver, OutOfBoundsChangesNothing)
    unity/LedDriver/LedDriverTest.c:106: FAIL:
    Expected 0x0000 Was 0x0001
....
-----------------------
13 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

And we can also verify that any additional bits over the 16-bit, just truncated
from 17 case or more explicitly:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsChangesNothing)
{
    LedDriver_TurnOn(-1);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(0);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(17);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(32);
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
    LedDriver_TurnOn(3141);

    /* TEST_ASSERT_EQUAL_HEX16(0, virtualLeds); */
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling LedDriverTest.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: .............
: -----------------------
: 13 Tests 0 Failures 0 Ignored
: OK

Now we know the origin of abnormality. Let's make the test pass by adding guard
clauses to =LedDriver_TurnOn()=:
#+BEGIN_SRC C
void LedDriver_TurnOn(int ledNumber)
{
    if (ledNumber <= 0 || ledNumber > 16)
        return;                 /* silently ignore */

    ledsImage |= convertedLedNumberToBit(ledNumber);
    updateHardware();
}
#+END_SRC

And revert the last test case and then make:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.............
-----------------------
13 Tests 0 Failures 0 Ignored
OK
#+end_example

Actually, our last test case does not involve the =TurnOff= executions. Let's
reflect this fact to the test name:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsTurnOnDoesNoHarm)
{
    LedDriver_TurnOn(-1);
    LedDriver_TurnOn(0);
    LedDriver_TurnOn(17);
    LedDriver_TurnOn(3141);

    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.............
-----------------------
13 Tests 0 Failures 0 Ignored
OK
#+end_example

Now it's time to =TurnOff= cases:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsTurnOffDoesNoHarm)
{
    LedDriver_TurnAllOn();
    LedDriver_TurnOff(-1);
    LedDriver_TurnOff(0);
    LedDriver_TurnOff(17);
    LedDriver_TurnOff(3141);

    TEST_ASSERT_EQUAL_HEX16(0xffff, virtualLeds);
}
#+END_SRC

Then run:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..........
TEST(LedDriver, OutOfBoundsTurnOffDoesNoHarm)
    unity/LedDriver/LedDriverTest.c:115: FAIL:
    Expected 0xFFFF Was 0xFFEF
....
-----------------------
14 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now let's add the guard clause to =TurnOff= operation:
#+BEGIN_SRC C
void LedDriver_TurnOff(int ledNumber)
{
    if (ledNumber <= 0 || ledNumber > 16)
        return;                 /* silently ignore */

    ledsImage &= ~(convertedLedNumberToBit(ledNumber));
    updateHardware();
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..............
-----------------------
14 Tests 0 Failures 0 Ignored
OK
#+end_example

So far, we have ignored the out-of-bound cases silently; but it would be better
to inform this error to the user of this driver. To do this, let us first assume
that we have macro called =RUNTIME_ERROR=, which alert the user that error. In
production code, it will be logged into the event log.

And here is the declaration:
#+BEGIN_SRC C
#define RUNTIME_ERROR(description, parameter)   \
    RuntimeError(description, parameter, __FILE__, __LINE__)

void RuntimeError(const char *message, int parameter,
                  const char *file, int line);
#+END_SRC

During test, we should mock the event log system; it will be linked only during
the test. Here we also used the macros =__FILE__= and =__LINE__=, which can be
found in the [[https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html][reference manual]].

#+BEGIN_SRC C
void RuntimeErrorStub_Reset(void);
const char *RuntimeErrorStub_GetLastError(void);
int RuntimeErrorStub_GetLastParameter(void);
#+END_SRC

Then the mock code:
#+BEGIN_SRC C
#include "RunTimeErrorStub.h"

static const char *message = "No Error";
static int parameter = -1;
static const char *file = 0;
static int line = -1;

void RuntimeErrorStub_Reset(void)
{
    message = "No Error";
    parameter = -1;
}

const char *RuntimeErrorStub_GetLastError(void)
{
    return message;
}

void RuntimeError(const char *m, int p, const char *f, int l)
{
    message = m;
    parameter = p;
    file = f;
    line = l;
}

int RuntimeErrorStub_GetLastParameter(void)
{
    return parameter;
}
#+END_SRC

Our stub version just capture the error information raised at last.

Now we can code the test:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsProducesRuntimeError)
{
    LedDriver_TurnOn(-1);
    TEST_ASSERT_EQUAL_STRING("LED Driver: out-of-bounds LED",
                             RuntimeErrorStub_GetLastError());
    TEST_ASSERT_EQUAL(-1, RuntimeErrorStub_GetLastParameter());
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...........
TEST(LedDriver, OutOfBoundsProducesRuntimeError)
    unity/LedDriver/LedDriverTest.c:123: FAIL:
    Expected 'LED Driver: out-of-bounds LED' Was 'No Error'
....
-----------------------
15 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now it's time to add the =RUNTIME_ERROR()= call to replace the ignored guidance:
#+BEGIN_SRC C
void LedDriver_TurnOn(int ledNumber)
{
    if (ledNumber <= 0 || ledNumber > 16)
        return RUNTIME_ERROR("LED Driver: out-of-bounds LED", ledNumber);

    ledsImage |= convertedLedNumberToBit(ledNumber);
    updateHardware();
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
r - objs/./src/mocks/RunTimeErrorStub.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...............
-----------------------
15 Tests 0 Failures 0 Ignored
OK
#+end_example

As you might notice, our current test is for the =TurnOn= operation; we could
provide separate test case for =TurnOff= but I've thought it would be more
natural to combine those into one test case:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsProducesRuntimeError)
{
    LedDriver_TurnOn(-1);
    TEST_ASSERT_EQUAL_STRING("LED Driver: out-of-bounds LED",
                             RuntimeErrorStub_GetLastError());
    TEST_ASSERT_EQUAL(-1, RuntimeErrorStub_GetLastParameter());
    RuntimeErrorStub_Reset();
    LedDriver_TurnOff(17);
    TEST_ASSERT_EQUAL_STRING("LED Driver: out-of-bounds LED",
                             RuntimeErrorStub_GetLastError());
    TEST_ASSERT_EQUAL(17, RuntimeErrorStub_GetLastParameter());
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
r - objs/./src/mocks/RunTimeErrorStub.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...........
TEST(LedDriver, OutOfBoundsProducesRuntimeError)
    unity/LedDriver/LedDriverTest.c:128: FAIL:
    Expected 'LED Driver: out-of-bounds LED' Was 'No Error'
....
-----------------------
15 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now it's time to change =TurnOff= also accordingly:
#+BEGIN_SRC C
void LedDriver_TurnOff(int ledNumber)
{
    if (ledNumber <= 0 || ledNumber > 16)
    {
        RUNTIME_ERROR("LED Driver: out-of-bounds LED", ledNumber);
        return;
    }

    ledsImage &= ~(convertedLedNumberToBit(ledNumber));
    updateHardware();
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
r - objs/./src/mocks/RunTimeErrorStub.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...............
-----------------------
15 Tests 0 Failures 0 Ignored
OK
#+end_example

If we could have decided what to do in runtime when it comes to out-of-bound,
and it requires another meeting that can not be done immediately, we don't need
to wait until then; let the unit test harnesses reminds ourself it should be
done someday:
#+BEGIN_SRC C
IGNORE_TEST(LedDriver, OutOfBoundsToDo)
{
    /* TODO: what should we do during runtime? */
}
#+END_SRC

***** Testing about the =static= qualifier
The question:
#+BEGIN_QUOTE
=Static= qualifier pointer should be allocated to static memory section also?
#+END_QUOTE

We can verify this with following experiments:
#+BEGIN_SRC C :main no :exports both :results verbatim
#include <stdio.h>

void StaticTest(int x)
{
    static int *test = 5;
    printf("%p has value %p, which has value %d\n", &test, test, *test);
    ,*test = x;                  /* update the test value */
}

int main(void)
{
    int i = 5;
    while (--i > 0)
        StaticTest(i);
    return 0;
}
#+END_SRC

#+RESULTS:

Unfortunately, this causes segmentation fault. Why? The compiler warns
#+BEGIN_QUOTE
StaticTest.c:5:17: warning: incompatible integer to pointer conversion initializing 'int *' with an expression of type 'int' [-Wint-conversion]
    static int *test = 5;
                ^      ~
#+END_QUOTE

Actually this is due to the fact that we are defining the =test= not =*test=; so
to the compiler consider that we are trying to assign =5= to =static int *=.
I've confused with the assignment with definition.

Can we solve our problem using this observation?
#+BEGIN_SRC C :main no :exports both :results verbatim
#include <stdio.h>

void StaticTest(int x)
{
    static int *test;
    *test = 5;
    printf("%p has value %p, which has value %d\n", &test, test, *test);
    ,*test = x;                  /* update the test value */
}

int main(void)
{
    int i = 5;
    while (--i > 0)
        StaticTest(i);
    return 0;
}
#+END_SRC

#+RESULTS:

No! We should better to define the value of =test= explicitly:
#+BEGIN_SRC C :main no :exports both :results verbatim
#include <stdio.h>

void StaticTest(int x)
{
    static int testVal = 5;
    static int *test = &testVal;
    printf("%p has value %p, which has value %d\n", &test, test, *test);
    ,*test = x;                  /* update the test value */
}

int main(void)
{
    int i = 5;
    while (--i > 0)
        StaticTest(i);
    return 0;
}
#+END_SRC

#+RESULTS:
: 0x100d3d020 has value 0x100d3d018, which has value 5
: 0x100d3d020 has value 0x100d3d018, which has value 4
: 0x100d3d020 has value 0x100d3d018, which has value 3
: 0x100d3d020 has value 0x100d3d018, which has value 2

So we come to the conclusion: =Static= qualifier to pointer variable, allocated
to static section except "also" part; the value of that initialization /should/
be static to make compiler happy with that since the initialization of =static=
variable should be compile time constant!

And also we can reason the other attempts turns out to fail; the uninitialized
=static= variable initialized with =0=. In the pointer case, it would be =NULL=;
let's verify that:

#+BEGIN_SRC C :main no :exports both :results verbatim
#include <stdio.h>

void StaticTest(void)
{
    static int *test;
    printf("%p has value %p; is that value NULL? %d\n", &test, test, test == NULL);
}

int main(void)
{
    StaticTest();
    return 0;
}
#+END_SRC

#+RESULTS:
: 0x105198018 has value 0x0; is that value NULL? 1

Now we can verify the our conclusion explicitly:
#+BEGIN_SRC C :main no :exports both :results verbatim
#include <stdio.h>

void StaticTest(int x)
{
    static int *test;
    test = &a;
    printf("%p has value %p, which has value %d\n", &test, test, *test);
    test = &x;                  /* update the test value */
    printf("%p has value %p, which has value %d\n", &test, test, *test);
}

int main(void)
{
    int i = 5;
    while (--i > 0)
        StaticTest(i);
    return 0;
}
#+END_SRC

#+RESULTS:
: 0x10f29c018 has value 0x7ffee0963f28, which has value 5
: 0x10f29c018 has value 0x7ffee0963f2c, which has value 4
: 0x10f29c018 has value 0x7ffee0963f28, which has value 5
: 0x10f29c018 has value 0x7ffee0963f2c, which has value 3
: 0x10f29c018 has value 0x7ffee0963f28, which has value 5
: 0x10f29c018 has value 0x7ffee0963f2c, which has value 2
: 0x10f29c018 has value 0x7ffee0963f28, which has value 5
: 0x10f29c018 has value 0x7ffee0963f2c, which has value 1

Here we initialized =test= with the value =NULL= implicitly and then assigned it
to automatic variable's address. It complements the conclusion: There is no
restriction at all to the value part except the initialization time.

Also from this series of experiments we came to know that static variables
are allocated to =0x10....=; whereas automatic variables to =0x7ff....=.

Using this knowledge, we can also resolve another intrigued mind:
#+BEGIN_QUOTE
We know that static external variable is private to file scope; then, there is
any difference it from non-static external variable? That is, the static
qualification to external variable make it allocated to static memory session?
#+END_QUOTE

Let's verify:
#+BEGIN_SRC C :main no :exports both :results verbatim
int nonStaticVal = 5;
static int staticVal = 5;

int main(void)
{
    printf("non-static external variable has %p as its address\n", &nonStaticVal);
    printf("static external variable has %p as its address\n", &staticVal);
    return 0;
}
#+END_SRC

#+RESULTS:
: non-static external variable has 0x1057dc018 as its address
: static external variable has 0x1057dc01c as its address

Turned out there is no difference than the scope.
**** Keep the Code Clean -- Refactor as You Go
Now all the tests are passed, it's time to refactor. First, we extract the
duplicate code into new function via /copying/.
#+BEGIN_SRC C
enum {FIRST_LED = 1, LAST_LED = 16};

static BOOL IsLedOutOfBounds(int ledNumber)
{
    return ledNumber < FIRST_LED || ledNumber > LAST_LED;
}
#+END_SRC

And see whether it compiles:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
src/LedDriver/LedDriver.c:31:8: error: unknown type name 'BOOL'
static BOOL IsLedOutOfBounds(int ledNumber)
       ^
1 error generated.
make[1]: [objs/./src/LedDriver/LedDriver.o] Error 1 (ignored)
Building archive lib/libSandBox_Unity.a
ar: objs/./src/LedDriver/LedDriver.o: No such file or directory
r - objs/./src/CircularBuffer/CircularBuffer.o
r - objs/./src/mocks/RunTimeErrorStub.o
make[1]: [lib/libSandBox_Unity.a] Error 1 (ignored)
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...............
-----------------------
15 Tests 0 Failures 0 Ignored
OK
#+end_example

Oops we should have included boolean library first:
#+BEGIN_SRC C
#include <stdbool.h>            /* boolean */
#+END_SRC

Then,
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
src/LedDriver/LedDriver.c:31:8: error: unknown type name 'BOOL'
static BOOL IsLedOutOfBounds(int ledNumber)
       ^
1 error generated.
make[1]: [objs/./src/LedDriver/LedDriver.o] Error 1 (ignored)
Building archive lib/libSandBox_Unity.a
ar: objs/./src/LedDriver/LedDriver.o: No such file or directory
r - objs/./src/CircularBuffer/CircularBuffer.o
r - objs/./src/mocks/RunTimeErrorStub.o
make[1]: [lib/libSandBox_Unity.a] Error 1 (ignored)
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...............
-----------------------
15 Tests 0 Failures 0 Ignored
OK
#+end_example

Still complains! Let's try the lower case:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
src/LedDriver/LedDriver.c:31:13: error: unused function 'IsLedOutOfBounds' [-Werror,-Wunused-function]
static bool IsLedOutOfBounds(int ledNumber)
            ^
1 error generated.
make[1]: [objs/./src/LedDriver/LedDriver.o] Error 1 (ignored)
Building archive lib/libSandBox_Unity.a
ar: objs/./src/LedDriver/LedDriver.o: No such file or directory
r - objs/./src/CircularBuffer/CircularBuffer.o
r - objs/./src/mocks/RunTimeErrorStub.o
make[1]: [lib/libSandBox_Unity.a] Error 1 (ignored)
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...............
-----------------------
15 Tests 0 Failures 0 Ignored
OK
#+end_example

Now it runs expected; let's replace the previous working code in an easy-to-undo
fashion -- comment:
#+BEGIN_SRC C
void LedDriver_TurnOn(int ledNumber)
{
    /* if (ledNumber <= 0 || ledNumber > 16) */
    if (IsLedOutOfBounds(ledNumber))
    {
        RUNTIME_ERROR("LED Driver: out-of-bounds LED", ledNumber);
        return;
    }

    ledsImage |= convertedLedNumberToBit(ledNumber);
    updateHardware();
}

void LedDriver_TurnOff(int ledNumber)
{
    /* if (ledNumber <= 0 || ledNumber > 16) */
    if (IsLedOutOfBounds(ledNumber))
    {
        RUNTIME_ERROR("LED Driver: out-of-bounds LED", ledNumber);
        return;
    }

    ledsImage &= ~(convertedLedNumberToBit(ledNumber));
    updateHardware();
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
r - objs/./src/mocks/RunTimeErrorStub.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...............
-----------------------
15 Tests 0 Failures 0 Ignored
OK
#+end_example

Now we can safely remove the commented code; after that, we came to realize our
bit manipulation code are not suitable to current abstract level. Let's extract
that out as helper function:
#+BEGIN_SRC C
static void setLedImageBit(int ledNumber)
{
    ledsImage |= convertedLedNumberToBit(ledNumber);
}

void LedDriver_TurnOn(int ledNumber)
{
    if (IsLedOutOfBounds(ledNumber))
    {
        RUNTIME_ERROR("LED Driver: out-of-bounds LED", ledNumber);
        return;
    }

    setLedImageBit(ledNumber);
    updateHardware();
}

static void clearLedImageBit(int ledNumber)
{
    ledsImage &= ~(convertedLedNumberToBit(ledNumber));
}

void LedDriver_TurnOff(int ledNumber)
{
    if (IsLedOutOfBounds(ledNumber))
    {
        RUNTIME_ERROR("LED Driver: out-of-bounds LED", ledNumber);
        return;
    }

    clearLedImageBit(ledNumber);
    updateHardware();
}

#+END_SRC

We've batched the changes -- you should do one at a time.

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: ...............
: -----------------------
: 15 Tests 0 Failures 0 Ignored
: OK
**** Repeat Until Done
Let's move on next test clause: Query LED state.
#+BEGIN_SRC C
TEST(LedDriver, IsOn)
{
    TEST_ASSERT_FALSE(LedDriver_IsOn(11));
    LedDriver_TurnOn(11);
    TEST_ASSERT_TRUE(LedDriver_IsOn(11));
}
#+END_SRC

And hard code to make the compiler happy:
#+BEGIN_SRC C
bool LedDriver_IsOn(int ledNumber)
{
    return true;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
............
TEST(LedDriver, IsOn)
    unity/LedDriver/LedDriverTest.c:139:FAIL: Expected FALSE Was TRUE
....
-----------------------
16 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now let's get it right:
#+BEGIN_SRC C
bool LedDriver_IsOn(int ledNumber)
{
    return ledsImage & (convertedLedNumberToBit(ledNumber));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
................
-----------------------
16 Tests 0 Failures 0 Ignored
OK
#+end_example

Now we have to think about the out-of-bound case of query. Since the query is
predicate, it would be reasonable to assume /closed-world/ assumption -- if the
query is not known to the driver, it is false:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsLedsAreAlwaysOff)
{
    LedDriver_TurnAllOn();
    TEST_ASSERT_FALSE(LedDriver_IsOn(0));
    TEST_ASSERT_FALSE(LedDriver_IsOn(17));
    TEST_ASSERT_FALSE(LedDriver_IsOn(33));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.............
TEST(LedDriver, OutOfBoundsLedsAreAlwaysOff)
    unity/LedDriver/LedDriverTest.c:149:FAIL: Expected FALSE Was TRUE
....
-----------------------
17 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now it's time to add guard:
#+BEGIN_SRC C
bool LedDriver_IsOn(int ledNumber)
{
    if (IsLedOutOfBounds(ledNumber))
        return false;
    return ledsImage & (convertedLedNumberToBit(ledNumber));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.................
-----------------------
17 Tests 0 Failures 0 Ignored
OK
#+end_example

Now it's time to query about the off:
#+BEGIN_SRC C
TEST(LedDriver, IsOff)
{
    TEST_ASSERT_TRUE(LedDriver_IsOff(12));
    LedDriver_TurnOn(12);
    TEST_ASSERT_FALSE(LedDriver_IsOff(12));
}
#+END_SRC

And the minimum code -- hard-code to false:
#+BEGIN_SRC C
bool LedDriver_IsOff(int ledNumber)
{
    return false;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriverTest.c
compiling LedDriverTestRunner.c
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.............
TEST(LedDriver, IsOff)
    unity/LedDriver/LedDriverTest.c:154:FAIL: Expected TRUE Was FALSE
.....
-----------------------
18 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Then code!
#+BEGIN_SRC C
bool LedDriver_IsOff(int ledNumber)
{
    return !LedDriver_IsOn(ledNumber);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..................
-----------------------
18 Tests 0 Failures 0 Ignored
OK
#+end_example

To wrap up, we need to check the out-of-bounds case for =IsOff=:
#+BEGIN_SRC C
TEST(LedDriver, OutOfBoundsLedsAreAlwaysOff)
{
    LedDriver_TurnAllOn();
    TEST_ASSERT_FALSE(LedDriver_IsOn(0));
    TEST_ASSERT_FALSE(LedDriver_IsOn(17));
    TEST_ASSERT_FALSE(LedDriver_IsOn(33));
    TEST_ASSERT_TRUE(LedDriver_IsOff(0));
    TEST_ASSERT_TRUE(LedDriver_IsOff(17));
    TEST_ASSERT_TRUE(LedDriver_IsOff(33));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling LedDriverTest.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: ..................
: -----------------------
: 18 Tests 0 Failures 0 Ignored
: OK

Now all we need to do in the test list is turn off multiples and turn all off.

Here is the multiple off test:
#+BEGIN_SRC C
TEST(LedDriver, TurnOffMultiplesLeds)
{
    LedDriver_TurnAllOn();
    LedDriver_TurnOff(9);
    LedDriver_TurnOff(8);
    TEST_ASSERT_EQUAL_HEX16((~0x180)&0xffff, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling LedDriverTestRunner.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: ...................
: -----------------------
: 19 Tests 0 Failures 0 Ignored
: OK

Works as expected.

And the final test from the test list:
#+BEGIN_SRC C
TEST(LedDriver, AllOff)
{
    LedDriver_TurnAllOn();
    LedDriver_TurnAllOff();
    TEST_ASSERT_EQUAL_HEX16(0, virtualLeds);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
........
TEST(LedDriver, AllOff)
    unity/LedDriver/LedDriverTest.c:96: FAIL:
    Expected 0x0000 Was 0xFFFF
............
-----------------------
20 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now final implementation:
#+BEGIN_SRC C
void LedDriver_TurnAllOff(void)
{
    ledsImage = ALL_LEDS_OFF;
    updateHardware();
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling LedDriver.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
....................
-----------------------
20 Tests 0 Failures 0 Ignored
OK
#+end_example
**** Take a Step Back Before Claiming /Done/
**** Put the Knowledge to Work
***** DONE Do the LED driver example from start to finish on our own
CLOSED: [2019-11-20 Wed 13:42]
***** DONE Finish the =CircularBuffer= that we started at the end of the previous chapter.
CLOSED: [2019-11-20 Wed 20:15]
Previously, we slipped the check emptiness after one push and pop -- actually we
need to make that evolve to be more general; after same number of push and pop,
it should be empty.

Let's continue with that:
#+BEGIN_SRC C
TEST(CircularBuffer, SameNumberPushPopEmpty)
{
    int pushed = 48;
    CircularBuffer_Push(pushed, buf);
    CircularBuffer_Pop(buf);
    TEST_ASSERT_TRUE(CircularBuffer_IsEmpty(buf));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.....................
TEST(CircularBuffer, SameNumberPushPopEmpty)
    unity/CircularBuffer/CircularBufferTest.c:46:FAIL: Expected TRUE Was FALSE

-----------------------
21 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now hard-code:
#+BEGIN_SRC C
int CircularBuffer_Pop(CircularBuffer buf)
{
    buf->flag |= EMPTY;
    return 48;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.....................
-----------------------
21 Tests 0 Failures 0 Ignored
OK
#+end_example

Now we move on to the multiple push & pop case; with this test pass, it will get
the FIFO property:
#+BEGIN_SRC C
TEST(CircularBuffer, MultiplePushPop)
{
    int pushed[3] = {234, -123, 6};
    int i;
    for (i = 0; i < 3; ++i)
        CircularBuffer_Push(pushed[i], buf);
    for (i = 0; i < 3; ++i)
        TEST_ASSERT_EQUAL(pushed[i], CircularBuffer_Pop(buf));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
......................
TEST(CircularBuffer, MultiplePushPop)
    unity/CircularBuffer/CircularBufferTest.c:56: FAIL:
    Expected 234 Was 48

-----------------------
22 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now it fails. Time to implement; not fake out:
#+BEGIN_SRC C
#define SIZE 10
/* enum {EMPTY = 1, FULL = 2}; */

/* Implementation of type */
struct CircularBufferStructure {
    /* int going_to_be_implemented; */
    /* int flag; */
    int *endp;
    int *startp;
    int *frontp;
    int *rearp;
};

/* Constructor */
CircularBuffer CircularBuffer_Create(void)
{
    CircularBuffer buf = malloc(sizeof(struct CircularBufferStructure));
    /* buf->flag = EMPTY; */
    buf->startp = buf->frontp = buf->rearp = calloc(SIZE, sizeof(int));
    buf->endp = buf->startp + SIZE;
    return buf;
}

/* Destructor */
void CircularBuffer_Destroy(CircularBuffer buf)
{
    free(buf->startp);
    free(buf);
}

/* Predicates */
bool CircularBuffer_IsEmpty(CircularBuffer buf)
{
    return buf->frontp == buf->rearp;
}

bool CircularBuffer_IsFull(CircularBuffer buf)
{
    return buf->rearp == buf->endp;
}

/* Mutators */
void CircularBuffer_Push(int val, CircularBuffer buf)
{
    *buf->rearp++ = val;
}

int CircularBuffer_Pop(CircularBuffer buf)
{
    return *buf->frontp++;
}
#+END_SRC

The simplest implementation. Let's check.

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
......................
-----------------------
22 Tests 0 Failures 0 Ignored
OK
#+end_example

Since all the test so far passed, it's safe to remove all the fake code.

Now it's time to refactor on green; =SIZE= should be placed in header rather
than source. It's also the preparation next test.

Next test is to augment the existing test case: =SameNumberPushPopEmpty=:
#+BEGIN_SRC C
TEST(CircularBuffer, SameNumberPushPopEmpty)
{
    CircularBuffer_Push(48, buf);
    CircularBuffer_Pop(buf);
    TEST_ASSERT_TRUE(CircularBuffer_IsEmpty(buf));

    int pushed[3] = {234, -123, 6};
    int i;
    for (i = 0; i < 3; ++i)
        CircularBuffer_Push(pushed[i], buf);
    for (i = 0; i < 3; ++i)
        CircularBuffer_Pop(buf);
    TEST_ASSERT_TRUE(CircularBuffer_IsEmpty(buf));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
......................
-----------------------
22 Tests 0 Failures 0 Ignored
OK
#+end_example

Which test should be next? Since we are going to make /softward vice/, it would
be better for us to go off the tests for interface rather than for the
implementation details: Full case test.
#+BEGIN_SRC C
TEST(CircularBuffer, IsFull)
{
    int pushed[SIZE] = {234, -123, 6,};
    int i;
    for (i = 0; i < SIZE; ++i)
        CircularBuffer_Push(pushed[i], buf);
    TEST_ASSERT_TRUE(CircularBuffer_IsFull(buf));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.......................
-----------------------
23 Tests 0 Failures 0 Ignored
OK
#+end_example

Our full cases doesn't count the wrapping case; it's natural since our program
does not have any test that checks the wrapped around case.

This time we will try to implement the overflow, underflow cases. We have to
decide what to do in those cases; since those are the unexpected usage, it would
be reasonable to raise that error appropriately. Already we have that mechanism
in our code base -- =RUNTIME_ERROR=; also the mocked version.

#+BEGIN_SRC C
TEST(CircularBuffer, PushToFullProducesOverflow)
{
    int pushed[SIZE] = {234, -123, 6,};
    int i;
    for (i = 0; i < SIZE; ++i)
        CircularBuffer_Push(pushed[i], buf);
    TEST_ASSERT_TRUE(CircularBuffer_IsFull(buf));
    CircularBuffer_Push(21, buf);
    TEST_ASSERT_EQUAL_STRING("CircularBuffer: buffer is overflowed",
                             RuntimeErrorStub_GetLastError());
    TEST_ASSERT_EQUAL(21, RuntimeErrorStub_GetLastParameter());
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
........................
TEST(CircularBuffer, PushToFullProducesOverflow)
    unity/CircularBuffer/CircularBufferTest.c:85: FAIL:
    Expected 'CircularBuffer: buffer is overflowed' Was 'LED Driver: out-of-bounds LED'

-----------------------
24 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Now add the implementation (we have changed the description part more
appropriately):
#+BEGIN_SRC C
void CircularBuffer_Push(int val, CircularBuffer buf)
{
    if (CircularBuffer_IsFull(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: push is attempted to buffer that is already full",
            val);
        return;
    }
    *buf->rearp++ = val;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling CircularBufferTestRunner.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: ........................
: -----------------------
: 24 Tests 0 Failures 0 Ignored
: OK

Next is the underflow case. Before that, let's refactor the test case since the
duplicate code floating around the test code:
#+BEGIN_SRC C
static void FillWith(int numberOfElements, int startingNumber)
{
    for (; numberOfElements-- > 0; ++startingNumber)
        CircularBuffer_Push(startingNumber, buf);
}

TEST(CircularBuffer, IsFull)
{
    FillWith(SIZE, 21);
    TEST_ASSERT_TRUE(CircularBuffer_IsFull(buf));
}

TEST(CircularBuffer, PushToFullProducesRuntimeError)
{
    FillWith(SIZE, 5235);
    TEST_ASSERT_TRUE(CircularBuffer_IsFull(buf));
    CircularBuffer_Push(21, buf);
    TEST_ASSERT_EQUAL_STRING(
        "CircularBuffer: push is attempted to buffer that is already full",
        RuntimeErrorStub_GetLastError());
    TEST_ASSERT_EQUAL(21, RuntimeErrorStub_GetLastParameter());
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
: make -i -f MakefileUnity.mk
: compiling CircularBufferTest.c
: Linking SandBox_Unity_tests
: Running SandBox_Unity_tests
: Unity test run 1 of 1
: ........................
: -----------------------
: 24 Tests 0 Failures 0 Ignored
: OK

Now underflow case:
#+BEGIN_SRC C
TEST(CircularBuffer, PopToEmptyBufferProducesRuntimeError)
{
    TEST_ASSERT_TRUE(CircularBuffer_IsEmpty(buf));
    RuntimeErrorStub_Reset();
    CircularBuffer_Pop(buf);
    TEST_ASSERT_EQUAL_STRING(
        "CircularBuffer: pop is attempted to buffer that is empty",
        RuntimeErrorStub_GetLastError());
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.........................
TEST(CircularBuffer, PopToEmptyBufferProducesRuntimeError)
    unity/CircularBuffer/CircularBufferTest.c:97: FAIL:
    Expected 'CircularBuffer: pop is attempted to buffer that is empty' Was 'No Error'

-----------------------
25 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Then code:
#+BEGIN_SRC C
int CircularBuffer_Pop(CircularBuffer buf)
{
    if (CircularBuffer_IsEmpty(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: pop is attempted to buffer that is empty",
            0);
        return 0;               /* Need to consider what is appropriate number to return */
    }
    return *buf->frontp++;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.........................
-----------------------
25 Tests 0 Failures 0 Ignored
OK
#+end_example

It's time to handle the wrapping case:
#+BEGIN_SRC C
TEST(CircularBuffer, PushWrappedAroundShouldNotProduceOverflow)
{
    RuntimeErrorStub_Reset();
    FillWith(SIZE, 52);
    CircularBuffer_Pop(buf);
    CircularBuffer_Push(2341, buf);
    TEST_ASSERT_EQUAL_STRING(
        "No Error",
        RuntimeErrorStub_GetLastError());
    TEST_ASSERT_EQUAL(-1, RuntimeErrorStub_GetLastParameter());
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..........................
TEST(CircularBuffer, PushWrappedAroundShouldNotProduceOverflow)
    unity/CircularBuffer/CircularBufferTest.c:108: FAIL:
    Expected 'No Error' Was 'CircularBuffer: push is attempted to buffer that is already full'

-----------------------
26 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Then code:
#+BEGIN_SRC C
void CircularBuffer_Push(int val, CircularBuffer buf)
{
    if (CircularBuffer_IsFull(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: push is attempted to buffer that is already full",
            val);
        return;
    }
    *buf->rearp++ = val;
    if (buf->rearp == buf->endp) /* wrapped around */
        buf->rearp = buf->startp;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
Running SandBox_Unity_tests
Unity test run 1 of 1
.......................
TEST(CircularBuffer, IsFull)
    unity/CircularBuffer/CircularBufferTest.c:75:FAIL: Expected TRUE Was FALSE
.
TEST(CircularBuffer, PushToFullProducesRuntimeError)
    unity/CircularBuffer/CircularBufferTest.c:81:FAIL: Expected TRUE Was FALSE
..
TEST(CircularBuffer, PushWrappedAroundShouldNotProduceOverflow)
    unity/CircularBuffer/CircularBufferTest.c:108: FAIL:
    Expected 'No Error' Was 'CircularBuffer: pop is attempted to buffer that is empty'

-----------------------
26 Tests 3 Failures 0 Ignored
FAIL
make[1]: [all] Error 3 (ignored)
#+end_example

Oops, let's revert and retry:
#+BEGIN_SRC C
void CircularBuffer_Push(int val, CircularBuffer buf)
{
    if (CircularBuffer_IsFull(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: push is attempted to buffer that is already full",
            val);
        return;
    }

    if (buf->rearp == buf->endp) /* wrapped around */
        buf->rearp = buf->startp;
    *buf->rearp++ = val;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..........................
TEST(CircularBuffer, PushWrappedAroundShouldNotProduceOverflow)
    unity/CircularBuffer/CircularBufferTest.c:108: FAIL:
    Expected 'No Error' Was 'CircularBuffer: push is attempted to buffer that is already full'

-----------------------
26 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

It got better. We need to modify the =IsFull=, which does not account the wrapping:
#+BEGIN_SRC C
bool CircularBuffer_IsFull(CircularBuffer buf)
{
    return buf->frontp > buf->rearp
        ? buf->rearp + SIZE - buf->frontp >= SIZE
        : buf->rearp - buf->frontp >=SIZE;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..........................
-----------------------
26 Tests 0 Failures 0 Ignored
OK
#+end_example

Next we ensure the wrapped pop case:
#+BEGIN_SRC C
TEST(CircularBuffer, PopWrappedAroundShouldNotProduceRuntimeError)
{
    RuntimeErrorStub_Reset();
    FillWith(SIZE, 52);
    int i = SIZE;
    while (i-- > 0)
        CircularBuffer_Pop(buf);
    CircularBuffer_Push(2341, buf);
    CircularBuffer_Pop(buf);
    TEST_ASSERT_EQUAL_STRING(
        "No Error",
        RuntimeErrorStub_GetLastError());
    TEST_ASSERT_EQUAL(-1, RuntimeErrorStub_GetLastParameter());
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
...........................
-----------------------
27 Tests 0 Failures 0 Ignored
OK
#+end_example

We expected the test to fail but it passed by an accident; let's rethink what we
should do. We have tested that =push= handles wrapping without runtime error. We
tried to do same thing to =pop=; however, while =push= write memory with given
value, =pop= just read memory. Actually we don't have to worry about the
harm =pop= would cause. All we should do is =pop= follows the FIFO
specification.

So above test is good as it is. Next we test the FIFO property while wrapping:
#+BEGIN_SRC C
TEST(CircularBuffer, FIFOWhileWrappedAround)
{
    int i;
    int start = 52;
    FillWith(SIZE, start);
    for (i = SIZE; i > 0; i--)
        TEST_ASSERT_EQUAL(start++, CircularBuffer_Pop(buf));
    FillWith(SIZE, start);
    for (i = SIZE; i > 0; i--)
        TEST_ASSERT_EQUAL(start++, CircularBuffer_Pop(buf));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
............................
TEST(CircularBuffer, FIFOWhileWrappedAround)
    unity/CircularBuffer/CircularBufferTest.c:149: FAIL:
    Expected 62 Was 0

-----------------------
28 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Time to code the =pop= to handle wrapping case:
#+BEGIN_SRC C
int CircularBuffer_Pop(CircularBuffer buf)
{
    if (CircularBuffer_IsEmpty(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: pop is attempted to buffer that is empty",
            0);
        return 0;               /* Need to consider what is appropriate number to return */
    }

    if (buf->frontp == buf->endp) /* wrapped around */
        buf->frontp = buf->startp;

    return *buf->frontp++;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
............................
TEST(CircularBuffer, FIFOWhileWrappedAround)
    unity/CircularBuffer/CircularBufferTest.c:149: FAIL:
    Expected 62 Was 0

-----------------------
28 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

This naive implementation doesn't work. Would it change if we change the order?
#+BEGIN_SRC C
int CircularBuffer_Pop(CircularBuffer buf)
{
    if (buf->frontp == buf->endp) /* wrapped around */
        buf->frontp = buf->startp;

    if (CircularBuffer_IsEmpty(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: pop is attempted to buffer that is empty",
            0);
        return 0;               /* Need to consider what is appropriate number to return */
    }

    return *buf->frontp++;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
............................
-----------------------
28 Tests 0 Failures 0 Ignored
OK
#+end_example

Yes it solves. Actually this particular order is crucial -- if we change these
order in either =pop= or =push=, it won't work:
#+BEGIN_SRC C
/* Mutators */
void CircularBuffer_Push(int val, CircularBuffer buf)
{
    if (buf->rearp == buf->endp) /* wrapped around */
        buf->rearp = buf->startp;

    if (CircularBuffer_IsFull(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: push is attempted to buffer that is already full",
            val);
        return;
    }

    *buf->rearp++ = val;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
........................
TEST(CircularBuffer, PushToFullProducesRuntimeError)
    unity/CircularBuffer/CircularBufferTest.c:87: FAIL:
    Expected 'CircularBuffer: push is attempted to buffer that is already full' Was 'No Error'
....
-----------------------
28 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

Finally, we test the full and empty test with wrapping:
#+BEGIN_SRC C
TEST(CircularBuffer, EmptyFullEmptyWrapped)
{
    int i;
    int start = 52;
    TEST_ASSERT_TRUE(CircularBuffer_IsEmpty(buf));
    FillWith(SIZE, start);
    TEST_ASSERT_TRUE(CircularBuffer_IsFull(buf));
    for (i = SIZE; i > 0; i--)
        TEST_ASSERT_EQUAL(start++, CircularBuffer_Pop(buf));
    TEST_ASSERT_TRUE(CircularBuffer_IsEmpty(buf));
    FillWith(SIZE, start);
    TEST_ASSERT_TRUE(CircularBuffer_IsFull(buf));
    for (i = SIZE; i > 0; i--)
        TEST_ASSERT_EQUAL(start++, CircularBuffer_Pop(buf));
    TEST_ASSERT_TRUE(CircularBuffer_IsEmpty(buf));
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.............................
TEST(CircularBuffer, EmptyFullEmptyWrapped)
    unity/CircularBuffer/CircularBufferTest.c:163:FAIL: Expected TRUE Was FALSE

-----------------------
29 Tests 1 Failures 0 Ignored
FAIL
make[1]: [all] Error 1 (ignored)
#+end_example

This test detect error we have not noticed; after some experiment with our
implementation model, we can not cope with the full state from empty state just
with the current state variables. It would be natural to keep track of the
current number of elements in the structure:
#+BEGIN_SRC C
/* Implementation of type */
struct CircularBufferStructure {
    int *endp;
    int *startp;
    int *frontp;
    int *rearp;
    int nelem;
};

/* Constructor */
CircularBuffer CircularBuffer_Create(void)
{
    CircularBuffer buf = malloc(sizeof(struct CircularBufferStructure));
    buf->startp = buf->frontp = buf->rearp = calloc(SIZE, sizeof(int));
    buf->endp = buf->startp + SIZE;
    buf->nelem = 0;
    return buf;
}

/* Predicates */
bool CircularBuffer_IsEmpty(CircularBuffer buf)
{
    return !buf->nelem;
}

bool CircularBuffer_IsFull(CircularBuffer buf)
{
    return buf->nelem == SIZE;
}

/* Mutators */
void CircularBuffer_Push(int val, CircularBuffer buf)
{
    if (CircularBuffer_IsFull(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: push is attempted to buffer that is already full",
            val);
        return;
    }

    if (buf->rearp == buf->endp) /* wrapped around */
        buf->rearp = buf->startp;

    buf->nelem++;
    ,*buf->rearp++ = val;
}

int CircularBuffer_Pop(CircularBuffer buf)
{
    if (buf->frontp == buf->endp) /* wrapped around */
        buf->frontp = buf->startp;

    if (CircularBuffer_IsEmpty(buf))
    {
        RUNTIME_ERROR(
            "CircularBuffer: pop is attempted to buffer that is empty",
            0);
        return 0;               /* Need to consider what is appropriate number to return */
    }

    buf->nelem--;
    return *buf->frontp++;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.............................
-----------------------
29 Tests 0 Failures 0 Ignored
OK
#+end_example

It's time to get rid of the =SIZE=; let user specify the size of buffer:
#+BEGIN_SRC C
/* Implementation of type */
struct CircularBufferStructure {
    int *endp;
    int *startp;
    int *frontp;
    int *rearp;
    int nelem;
    int capacity;
};

/* Constructor */
CircularBuffer CircularBuffer_Create(int capacity)
{
    CircularBuffer buf = malloc(sizeof(struct CircularBufferStructure));
    buf->startp = buf->frontp = buf->rearp = calloc(capacity, sizeof(int));
    buf->endp = buf->startp + capacity;
    buf->nelem = 0;
    buf->capacity = capacity;
    return buf;
}

/* Selector */
int CircularBuffer_Capacity(CircularBuffer buf)
{
    return buf->capacity;
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
.............................
-----------------------
29 Tests 0 Failures 0 Ignored
OK
#+end_example

Now add creation test:
#+BEGIN_SRC C
TEST(CircularBuffer, UserCanSpecifyCapacity)
{
    CircularBuffer userSpecifiedBuf = CircularBuffer_Create(582);
    TEST_ASSERT_EQUAL(582, CircularBuffer_Capacity(userSpecifiedBuf));
    CircularBuffer_Destroy(userSpecifiedBuf);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBufferTestRunner.c
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..............................
-----------------------
30 Tests 0 Failures 0 Ignored
OK
#+end_example

Here we used the fact that ANSI C assure that the pointer arithmetic using just
past the end of array is legal -- relying on =calloc=. If we want to be really
conservative about that, we could add the additional guard to the end of the
pointer; using that we could also test the integrity of memory just before
destruction. Via that method, we can come to believe that our =push= method does
not mutate the memory in out-of-range explicitly.

Let's try that. All we need to change is just
#+BEGIN_SRC C
#define BUF_GUARD 0x341         /* for check integrity */

/* Constructor */
CircularBuffer CircularBuffer_Create(int capacity)
{
    CircularBuffer buf = malloc(sizeof(struct CircularBufferStructure));
    buf->startp = buf->frontp = buf->rearp = calloc(capacity + 1, sizeof(int));
    buf->endp = buf->startp + capacity;
    buf->nelem = 0;
    buf->capacity = capacity;
    ,*buf->endp = BUF_GUARD;
    return buf;
}
#+END_SRC

And
#+BEGIN_SRC C
bool CircularBuffer_VerifyIntegrity(CircularBuffer buf)
{
    return *buf->endp == BUF_GUARD;
}
#+END_SRC

Now we can test the integrity by
#+BEGIN_SRC C
TEST_TEAR_DOWN(CircularBuffer)
{
    CircularBuffer_VerifyIntegrity(buf);
    CircularBuffer_Destroy(buf);
}
#+END_SRC

#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..............................
-----------------------
30 Tests 0 Failures 0 Ignored
OK
#+end_example

But we should notice that this verifying function sneaked into the source code
not only in test code; it is hard to imagine the user of =CircularBuffer= would
ever need to use =VerifyIntegrity= function -- it should be ensured by
whom implemented. So I myself think it would be reverted to the previous one and
let the one implementing reason about the integrity of memory since it can be
easily deduced from the code structure.

And final verification:
#+BEGIN_SRC sh :exports both :results verbatim
cd C_codes/TDD/code/SandBox
make codeUnity 2>&1
#+END_SRC

#+RESULTS:
#+begin_example
make -i -f MakefileUnity.mk
compiling CircularBufferTest.c
compiling CircularBuffer.c
Building archive lib/libSandBox_Unity.a
r - objs/./src/LedDriver/LedDriver.o
r - objs/./src/CircularBuffer/CircularBuffer.o
Linking SandBox_Unity_tests
Running SandBox_Unity_tests
Unity test run 1 of 1
..............................
-----------------------
30 Tests 0 Failures 0 Ignored
OK
#+end_example

***** TODO Modify the =LedDriver= and its tests to use inverted logic.
***** TODO Encompass both version in our =LedDriver=.
***** TODO Deal with the reversed address of LEDs.

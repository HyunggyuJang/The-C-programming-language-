#+TITLE: Hacking Notebook
* The programming language C
:PROPERTIES:
:NOTER_DOCUMENT: ../Documents/CS/C/Brian W. Kernighan, Dennis M. Ritchie-The ANSI C Programming Language-Prentice Hall (1988).pdf
:END:
** Chapter 1 - A Tutorial Introduction
:PROPERTIES:
:NOTER_PAGE: 9
:END:

*** Getting Started
:PROPERTIES:
:NOTER_PAGE: 9
:END:
We can start the typical hello world program by
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n");
}
#+END_SRC

#+RESULTS:
| hello | world |
**** Exercise 1-1
:PROPERTIES:
:NOTER_PAGE: 11
:END:
- Without semicolon:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n")
        }
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:10:5: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
    main(){
    ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:11:33: error: expected ';' after expression
        printf("hello, world\n")
                                ^
                                ;
1 warning and 1 error generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-2QhFQd: Permission denied
    #+END_SRC

  And replacing the escape sequence, which representing /newline/, with the
  what that representing:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world
");
}
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
main(){
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: warning: missing terminating '"' character [-Winvalid-pp-token]
    printf("hello, world
           ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: error: expected expression
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:12:1: warning: missing terminating '"' character [-Winvalid-pp-token]
");
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:14:1: error: expected '}'
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:7: note: to match this '{'
main(){
      ^
3 warnings and 2 errors generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-qJOtkX: Permission denied
  #+END_SRC

  Now it got quite cryptic -- compiler got spit outs all the errors not the one
  that causes all subsequent errors.
**** Exercise 1-2
:PROPERTIES:
:NOTER_PAGE: 11
:END:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("\c\b\d\f\e");
}
#+END_SRC

#+RESULTS:
: cd

If the character is not on the mentioned list, it just ignore the backslash --
just return the following character.
*** Variables and Arithmetic Expressions
:PROPERTIES:
:NOTER_PAGE: 11
:END:
**** Output formatting function -- =printf=
:PROPERTIES:
:NOTER_PAGE: 14
:END:
#+BEGIN_SRC C
printf("%d\t%d\n", fahr, celsius);
#+END_SRC
output the first argument -- formatted string -- substituted with second and
third arguemnt in the place of each =%d=, respectively.

I guess it use =%= as expression to be substituted since this character seems
like describing the situation where one element being replaced by another.
**** Exercise 1-3
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 300;                /* upper limit */
    step = 20;                  /* step size */

    fahr = lower;
    printf("%3s %6s\n", "Fahrenheit", "Celsius");
    while (fahr <= upper) {
        celsius = (5.0/9.0) * (fahr - 32.0);
        printf("%3.0f %6.1f\n", fahr, celsius);
        fahr = fahr + step;
    }
}
#+END_SRC

#+RESULTS:
| Fahrenheit | Celsius |
|          0 |   -17.8 |
|         20 |    -6.7 |
|         40 |     4.4 |
|         60 |    15.6 |
|         80 |    26.7 |
|        100 |    37.8 |
|        120 |    48.9 |
|        140 |    60.0 |
|        160 |    71.1 |
|        180 |    82.2 |
|        200 |    93.3 |
|        220 |   104.4 |
|        240 |   115.6 |
|        260 |   126.7 |
|        280 |   137.8 |
|        300 |   148.9 |
**** Exercise 1-4
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 120;                /* upper limit */
    step = 10;                  /* step size */

    celsius = lower;
    printf("%3s %6s\n", "Celsius", "Fahrenheit");
    while (celsius <= upper) {
        fahr = (9.0/5.0) * celsius + 32.0;
        printf("%3.0f %6.1f\n", celsius, fahr);
        celsius = celsius + step;
    }
}
#+END_SRC

#+RESULTS:
| Celsius | Fahrenheit |
|       0 |       32.0 |
|      10 |       50.0 |
|      20 |       68.0 |
|      30 |       86.0 |
|      40 |      104.0 |
|      50 |      122.0 |
|      60 |      140.0 |
|      70 |      158.0 |
|      80 |      176.0 |
|      90 |      194.0 |
|     100 |      212.0 |
|     110 |      230.0 |
|     120 |      248.0 |
*** The for statement
:PROPERTIES:
:NOTER_PAGE: 16
:END:
**** Exercise 1-5
:PROPERTIES:
:NOTER_PAGE: 17
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 300, 280, ..., 0; floating-point version*/

main(){
    int fahr;
    for (fahr = 300; fahr >= 0; fahr = fahr - 20) {
        printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32.0));
    }
}

#+END_SRC

#+RESULTS:
| 300 | 148.9 |
| 280 | 137.8 |
| 260 | 126.7 |
| 240 | 115.6 |
| 220 | 104.4 |
| 200 |  93.3 |
| 180 |  82.2 |
| 160 |  71.1 |
| 140 |  60.0 |
| 120 |  48.9 |
| 100 |  37.8 |
|  80 |  26.7 |
|  60 |  15.6 |
|  40 |   4.4 |
|  20 |  -6.7 |
|   0 | -17.8 |
*** Symbolic Constants
:PROPERTIES:
:NOTER_PAGE: 17
:END:
I think symbolic constants, defined by =#define=, would be open-coded when it compiled.
#+BEGIN_SRC C :includes <stdio.h> :exports both :defines LOWER 0 UPPER 300 STEP 20
int fahr;
for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
    printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32));
#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
*** Character Input and Output
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C :includes <stdio.h>
int c;
c = 50;
printf("\ninteger number %d got translated with putchar into %c\n", c, putchar(c));
#+END_SRC

#+RESULTS:
|       2 |        |    |     |            |      |         |      |   |
| integer | number | 50 | got | translated | with | putchar | into | 2 |
**** File Copying
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C
/* copy input to output; 1st version */
int c;

c = getchar();
while (c != EOF) {
    putchar(c);
    c = getchar();
}
#+END_SRC

More concisely, experienced C programmer would write above program as
#+BEGIN_SRC C
/* copy input to output; 2nd version */
int c;

while ((c = getchar ()) != EOF)
    putchar(c);
#+END_SRC

This exploited the fact that the assignment statement -- ~=~ -- has the value
evaluating the right hand side as its return value. Here also we should note
that =EOF= is just one of pre =define= d variable macro that would be replaced
any integer number that would not appear in the real character code.

Using this /trick/, we should be alerted that now we should be considerate on
the /precedence/ issue -- ~!=~ has higher precedence than ~=~.
***** Exercise 1-6
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
getchar() != EOF;
#+END_SRC

#+RESULTS:
#+BEGIN_SRC sh
~/org ÃŽÂ» ./C_codes/a.out
5
The input character 5 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character
 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character Ã¿ return 0 via "getchar() != EOF"
#+END_SRC

From this exercise, we know that character ~^D~ represent =EOF= (also apparently
0 means the test is false and 1 for the true).
***** Exercise 1-7
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
putchar(EOF);
#+END_SRC

#+RESULTS:
: Ã¿

What we discovered in preceding exercise got verified explicitly.
**** Character Counting
:PROPERTIES:
:NOTER_PAGE: 20
:END:
New operator, which is the mascot expression in C, =++=:
#+BEGIN_SRC C
++nc;
#+END_SRC

Although we have shown in the above example /prefix/ operator =++=, there is
also /postfix/ operator =++=; those have different values in expressions.

As introduced in preceding section, the =for= control structure is just
syntactic sugar for =while=, we could express the word counting program as
#+BEGIN_SRC C :includes <stdio.h> :exports both
double nc;

for (nc = 0; getchar () != EOF; ++nc);
printf("%.0f\n", nc);
#+END_SRC

#+RESULTS:
: 0
***** Exercise 1-8
:PROPERTIES:
:NOTER_PAGE: 22
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
long ns, nt, nl;
int c;

ns = 0;
nt = 0;
nl = 0;

while ((c = getchar ()) != EOF) {
    if (c == ' ')
        ++ns;
    if (c == '\t')
        ++nt;
    if (c == '\n')
        ++nl;
}
printf("The number of blanks, tabs, lines are %ld, %ld, %ld, respectively\n", ns, nt, nl);
#+END_SRC

#+RESULTS:
| The number of blanks | tabs | lines are 0 | 0 | 0 | respectively |
***** Exercise 1-9
:PROPERTIES:
:NOTER_PAGE: 22
:END:
Here is the algorithm that solves our task:
1. If the input character stream is not =EOF=,
2. if taken character stream is blank, print single blank and then
3. consume all the successive blanks;
4. else, print that input stream and then update character stream.
5. go to *1.*

Since we haven't yet learned the =else= control structure -- only =if=-then
structure -- we need to mimic the =if-else= structure:

#+BEGIN_SRC C :exports both
int c;
int flag;
c = getchar();
while (c != EOF) {
    flag = 0;               /* mimic if else control structure */
    if (c == ' ') {
        putchar(c);         /* print single blank */
        flag = 1;           /* signal that the entry character was blank */
        while ((c = getchar()) == ' ') /* comsume the successive blanks */
            ;
    }
    if (flag == 0) {        /* if the entry point was non-blank character */
        putchar(c);
        c = getchar();      /* update the c to be consist with comsumption of blanks */
    }
}
#+END_SRC

Then it works as expected:
#+BEGIN_SRC sh
~/org/C_codes [master] Î» ./a.out
asdfsd   sdf   d
asdfsd sdf d
Hi Test thsi    tis   d
Hi Test thsi tis d

#+END_SRC
***** Exercise 1-10
:PROPERTIES:
:NOTER_PAGE: 22
:END:
This program is analogous that of [[*Exercise 1-8][Exercise 1-8]], mimicking the =else= structure:
#+BEGIN_SRC C :includes <stdio.h> :exports both

int c, flag;


while ((c = getchar ()) != EOF) {
    flag = 1;
    if (c == '\b') {
        flag = 0;
        printf("\\b");
    }
    if (c == '\t') {
        flag = 0;
        printf("\\t");
    }
    if (c == '\n') {
        flag = 0;
        printf("\\n");
    }
    if (c == '\\') {
        flag = 0;
        printf("\\\\");
    }
    if (flag)
        putchar(c);
}
#+END_SRC

#+BEGIN_SRC sh
~/org/C_codes [master] Î» echo "tab	\	" | ./a.out
tab\t\\\t\n
#+END_SRC
**** Word Counting
:PROPERTIES:
:NOTER_PAGE: 22
:END:

#+BEGIN_SRC C :tangle C_codes/current.c :includes <stdio.h> :defines IN 1 OUT 0
int c, nl, nw, nc, state;

state = OUT;
nl = nw = nc = 0;
while ((c = getchar()) != EOF) {
    ++nc;
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
}
printf("%d %d %d\n", nl, nw, nc);
#+END_SRC

#+RESULTS:
: 0 0 0
***** Exercise 1-11
:PROPERTIES:
:NOTER_PAGE: 23
:END:

In Org mode, we can use session whenever the language supports ~REPL~; but since
C is the language should involve compiler to produce program, we can not use
them.

So we have to fall back to alternative approach: Use tangle feature.

Then let's test this code:
#+BEGIN_SRC sh
cd C_codes
cc current.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
echo "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
: 1 5 28

We've setup the environment where we integrated the Org babel with the testing C code.

To test this kind of program, we can take two different approaches:
1. Path complete test;
2. black box test -- test the specifications.


The former one tests all the branches the code implemented; in above case, it
has 2 branches in it: First only has consequent clause, second has also
alternative in addition to consequence:
#+BEGIN_SRC C
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
#+END_SRC

First, let's try the path complete test:
#+BEGIN_SRC sh :exports both
# Test first branch
echo | ./C_codes/current        # echo append '\n' by default
printf | ./C_codes/current      # printf do not append '\n'
# Test second branch
# just pass through first path of second branch
printf "\n\n\n   \t\t\t" | ./C_codes/current
# pass though the second path also
printf "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
| 1 | 0 |  1 |
| 0 | 0 |  0 |
| 3 | 0 |  9 |
| 0 | 5 | 27 |

Then let's do the latter one; it tests all the boundary cases:
#+BEGIN_SRC sh :exports both
# 0 0 0
printf | ./C_codes/current
# 1 0 1
echo | ./C_codes/current
# 0 0 1
printf " " | ./C_codes/current  # space
printf "\t" | ./C_codes/current  # tab
# 0 1 1
printf "c" | ./C_codes/current
# Compound cases
printf "This is \n compound case.\t" | ./C_codes/current
#+END_SRC

#+RESULTS:
| 0 | 0 |  0 |
| 1 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 1 |  1 |
| 1 | 4 | 25 |
***** Exercise 1-12
:PROPERTIES:
:NOTER_PAGE: 23
:END:
All we need to do is
- just copying the input if it were transition of state from
  =IN= to =IN= or =OUT= to =IN=;
- ignore if it were from =OUT= to =OUT=;
- replace it as =\n= if it were from =IN= to =OUT=;


#+BEGIN_SRC C :tangle C_codes/ex1_12.c :includes <stdio.h> :defines IN 1 OUT 0
int c, state;

state = OUT;
while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == OUT)
            ;                   /* ignore the input character */
        else {
            state = OUT;
            putchar('\n');
        }
    }
    else {
        state = IN;
        putchar(c);
    }
}
#+END_SRC

Then test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_12.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
printf "Test words\n\n\n\t\t\t   One Two     Three" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Test  |
| words |
| One   |
| Two   |
| Three |
*** Arrays
:PROPERTIES:
:NOTER_PAGE: 25
:END:
***** Exercise 1-13
:PROPERTIES:
:NOTER_PAGE: 25
:END:
The most canonical way to implement this program would be
1. Assume that we have data structure, table that contains entries which
   consist of key and value;
2. modifying the word counting program, which we implemented in preceding
   section, implement program that counts the length of first word from the
   input stream;
3. for each word in the input stream, insert newly calculated word length into
   the predefined table that contains word length - frequency entries;
4. print the entries in that table using histogram.


But, only with what we've learned so far, we can not implement the assumed data
structure, so we need to approach this exercise in more naive manner.

We are going to use array as table like structure but that table possibly be
very scarce -- inefficient; moreover, as we are not allowed to allocates the
input stream into some temporary file or on memory to use more than once, we can
not cope with extreme cases where maximum word length is enormous.


Here is the resulting code, which approximately implement above algorithm naively:
#+BEGIN_SRC C :tangle C_codes/ex1_13.c :includes <stdio.h> :defines IN 1 OUT 0 MAX_LENG 100

int c, i, j, wl, state;
int nwords[MAX_LENG];

state = OUT;
wl = 0;
for (i = 0; i < MAX_LENG; ++i)
    nwords[i] = 0;

while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == IN)        /* IN -> OUT transition */
            ++nwords[wl];

        state = OUT;
    }
    else {
        if (state == OUT)       /* OUT -> IN transition */
            wl = 0;             /* initialize word length counter */
        state = IN;
        ++wl;
    }
}

if (state == IN)                /* EOF is also delimiter */
    ++nwords[wl];

printf("%s\t%s\n", "Word length", "Frequency");
for (i = 0; i < MAX_LENG; ++i) {
    if (nwords[i] != 0) {       /* print only non zero frequency entries */
        printf("%d\t", i);
        for (j = 0; j < nwords[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_13.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_13.c | ./C_codes/current
# printf "test\nMy-test test" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Word length | Frequency                                          |
|           1 | **********************************                 |
|           2 | ************************************************** |
|           3 | ******************                                 |
|           4 | *************                                      |
|           5 | **********                                         |
|           6 | *******                                            |
|           7 | *****                                              |
|           8 | ***                                                |
|           9 | *********                                          |
|          10 | ******                                             |
|          13 | ****                                               |
|          14 | **                                                 |
|          17 | *                                                  |
|          18 | *                                                  |
***** Exercise 1-14
:PROPERTIES:
:NOTER_PAGE: 25
:END:
This is an analogous program of preceding exercise. The maximum length becomes
='z' - 'a'= and the others are obvious relations:

#+BEGIN_SRC C :tangle C_codes/ex1_14.c :includes <stdio.h>
int c, i, j;
int length = 'z' - 'a' + 1;
int nchars[length];

for (i = 0; i < length; ++i)
    nchars[i] = 0;

while ((c = getchar()) != EOF) {
    if ('a' <= c && c <= 'z')
        ++nchars[c - 'a'];
}

printf("%s\t%s\n", "Character", "Frequency");
for (i = 0; i < length; ++i) {
    if (nchars[i] != 0) {       /* print only non zero frequency entries */
        printf("%c\t", i + 'a');
        for (j = 0; j < nchars[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_14.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_14.c | ./C_codes/current
# printf "zzzz AAA aaaa" | ./C_codes/current # only count lowercase character
#+END_SRC

#+RESULTS:
| Character | Frequency                      |
| a         | ****************               |
| c         | ********************           |
| d         | **                             |
| e         | *********************          |
| f         | *********                      |
| g         | ******                         |
| h         | ******************             |
| i         | ****************************   |
| j         | ****                           |
| l         | *******                        |
| m         | **                             |
| n         | ****************************** |
| o         | ********                       |
| p         | *******                        |
| q         | ***                            |
| r         | ***************************    |
| s         | ***********                    |
| t         | ***********************        |
| u         | *******                        |
| w         | **                             |
| y         | ****                           |
| z         | ***                            |
*** Functions
:PROPERTIES:
:NOTER_PAGE: 26
:END:
Let's test recursive definition of =power=:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>
int power(int m, int n);

main()
{
    int i;

    printf("power(2,5) is %d", power(2, 5));
}

/* recursive definition of exponentiation */
int power(int base, int n)
{
    if (n == 0)
        return 1;
    else
        return base * power(base, n - 1);
}
#+END_SRC

#+RESULTS:
| power(2 | 5) is 32 |

Yes it works as expected.
***** Exercise 1-15
#+BEGIN_SRC C :main no :tangle C_codes/ex1_15.c :exports both
#include <stdio.h>

#define LOWER 0
#define UPPER 300
#define STEP 20

float fahr2cels(float fahr);
/* test temperature conversion function */
main () {
    float fahr;
    for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf("%3.0f %6.1f\n", fahr, fahr2cels(fahr));
    return 0;
}
/* temperature conversion function from fahrenheit to celsius*/
float fahr2cels(float fahr) {
    return (5.0/9.0) * (fahr - 32.0);
}

#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
*** Call by value
*** Character array
***** Exercise 1-16
:PROPERTIES:
:NOTER_PAGE: 31
:END:
Since C is strictly typed language, if the specific task does not require, we
usually do not code in dynamic manner -- recursive function definition and so on.

However in this exercise, we can not cope with this task without using
dynamically evolving program since we are dealing with unknown input stream --
it is inheritly dynamic one.

To cope with this task, we will try to use the recursive function definition to
accommodate sufficient memory for given input stream.

We are going to define =printOverflowed= that print longest input line. It takes
=maxline=, =impending[]= (if any):
#+BEGIN_SRC C :main no :tangle C_codes/ex1_16.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    int len;
    int max;
    int overflow = 0;
    char line[INITIALMAX];
    char longest[INITIALMAX];

    max = 0;
    while ((len = getlineFrom(0, line, INITIALMAX)) > 0)
        if (isOverflowed(line, len, INITIALMAX)) {
            overflow = 1;
            printOverflowed(INITIALMAX, line);
        }
        else if (len > max) {
            max = len;
            copy(longest, line);
        }
    if (overflow != 1 && max > 0)
        printf("%s", longest);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[])
{
    int len, max;
    int overflow = 0;
    int lim = 2 * oldLim;
    char line[lim];
    char longest[lim];

    copy(line, impending);
    max = len = getlineFrom(oldLim - 1, line, lim);
    if (isOverflowed(line, len, lim))
        printOverflowed(lim, line);
    else {
        copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (overflow != 1)
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

We've handled the overflowed condition explicitly using the =printOverflowed=
function. It is almost same as the entry point function, =main= except it
handles allocates the current line and longest line with extended limit array indice.

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
***** Exercise 1-17
:PROPERTIES:
:NOTER_PAGE: 31
:END:
We can achieve what we want by modifying the preceding example. That is,
whenever we encounters input line that is longer than threadhold length.

Before doing modification of code of [[*Exercise 1-16][Exercise 1-16]], let us first refactor that
code to encompass the entry point case into the =printOverflowed= so that we can
easily change the behavior of that program by making them modular.

We used following experiment to refactor our code:

#+NAME: Test logical not
#+BEGIN_SRC C :exports both
printf("%d", !0);
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC C :main no :tangle C_codes/ex1_16_refactored.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len, max;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];
    char longest[lim];

    if (isentry) {
        max = 0;
    }
    else {
        copy(line, impending);
        max = len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (!overflow && (!isentry || (isentry && max > 0)))
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Our =main= routine got simplified just calling the subroutines appropriately.
Let's test this refactored code:


Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16_refactored.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |

It works as expected.

Now we turn to the our original task; it actually simpler than preceding
exercise. All we need to do is just print given line if it is longer than the
threadhold length.

#+BEGIN_SRC C :main no :tangle C_codes/ex1_17.c
#include <stdio.h>
#define INITIALMAX 10
#define TREADHOLD 8

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
void copy(char to[], char from[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            if (len >= TREADHOLD)
                printf("%s", line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len >= TREADHOLD)
                printf("%s", line);

    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_17.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "threadhold\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| threadhold |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
| like       | this |      |        |      |        |

Seems like works well.
***** Exercise 1-18
:PROPERTIES:
:NOTER_PAGE: 31
:END:
What we need is function that removes trailing blanks and tabs from given line;
if we implement that function, all the left is to apply that function to each of
input line that is allowed to be arbitrary length.

So here we are going to design remove trailing blanks and tabs from given
argument character array. It needs to take character array with the length of
that to detect the last element; it will mutate the argument array if it has
trailing white spaces. And finally it will return the truncated length to make
the caller to take action with that information -- for this specific case, not
to print the zero length line.

#+BEGIN_SRC C :main no :results verbatim :exports both
#include <stdio.h>

int removeTrailings(int length, char line[]);
int isWhite(char character);
int stringLength(char line[]);
void copy(char to[], char from[]);

/* Test remove trailings */
int main()
{
    char test[] = "Test trailings     		  \n";
    int len = stringLength(test);
    char testCopy[len];
    copy(testCopy, test);       /* copy the test into the testCopy */
    removeTrailings(len, test); /* remove trailings of test */
    printf("%s, which has length %d, got truncated as \n%s, which now has length %d",
           testCopy,
           stringLength(testCopy),
           test,
           stringLength(test));
    return 0;
}

int removeTrailings(int len, char s[])
{
    int i = len - 2;
    int newlen;
    if (isWhite(s[i])) {
        s[i+1] = '\0';          /* make the newline character to be null */
        while(i >= 0 && isWhite(s[i])) { /* make sure not to be underflow */
            s[i] = '\0';        /* remove trailing white spaces */
            --i;
        }
        if (i >= 0) {
            ++i;
            s[i] = '\n';      /* restore newline character to be end of new result */
            newlen = i;         /* new length */
        } else
            newlen = 0;
    } else
        newlen = len;
    return newlen;
}

int isWhite(char c) {
    return c == '\t' || c == ' ';
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int stringLength(char s[]) {
    int len;
    for (len = 0; s[len] != '\0'; ++len)
        ;
    return len;
}
#+END_SRC

#+RESULTS:
: Test trailings
: , which has length 24, got truncated as
: Test trailings
: , which now has length 15

Seems works well.

Now we can integrate all of the pieces:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_18.c
#include <stdio.h>
#define INITIALMAX 10
#define TRUE 1

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);
int removeTrailings(int length, char line[]);
int isWhite(char character);
void copy(char to[], char from[]);

int main()
{
    printOverflowed(INITIALMAX, "", TRUE);
    return 0;
}

int removeTrailings(int len, char s[])
{
    int i = len - 2;
    int newlen;
    if (isWhite(s[i])) {
        s[i+1] = '\0';          /* make the newline character to be null */
        while(i >= 0 && isWhite(s[i])) { /* make sure not to be underflow */
            s[i] = '\0';        /* remove trailing white spaces */
            --i;
        }
        if (i >= 0) {
            ++i;
            s[i] = '\n';      /* restore newline character to be end of new result */
            newlen = i;         /* new length */
        } else
            newlen = 0;
    } else
        newlen = len;
    return newlen;
}

int isWhite(char c) {
    return c == '\t' || c == ' ';
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            if ((len = removeTrailings(len, line)) > 0)
                printf("%s", line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                printOverflowed(lim, line, 0);
            }
            else if ((len = removeTrailings(len, line)) > 0)
                printf("%s", line);

    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_18.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "trailings        	\nsimple\nones\n" | ./C_codes/current
printf "test empty line\n     	\nlike this" | ./C_codes/current
# printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
: trailings
: simple
: ones
: test empty line
: like this

Works as expected.
***** Exercise 1-19
:PROPERTIES:
:NOTER_PAGE: 31
:END:
I've designed this problem -- the algorithm behind this -- in my digital paper.
It is way more easy to describe in image rather than text; briefly, we are going
to reverse given array in place -- looping through half of the index and
interchange front half part with rear half part.

#+BEGIN_SRC C :main no :results verbatim :exports both
#include <stdio.h>

void reverse(int length, char line[]);
int stringLength(char line[]);
void copy(char to[], char from[]);

/* Test remove trailings */
int main()
{
    char test[] = "Reverse test  \t HiiH \n";
    int len = stringLength(test);
    char testCopy[len];
    copy(testCopy, test);       /* copy the test into the testCopy */
    reverse(len, test); /* reverse the test */
    printf("%s got reversed as \n%s",
           testCopy,
           test);
    return 0;
}

void reverse(int len, char s[])
{
    int lastIndex = len - 2;    /* lastIndex except the newline character */
    int halfIndex = (lastIndex - 1) / 2; /* use integer division to be used in loop */
    char temp;                           /* temporary storage to interchange */
    int i;                               /* loop index */
    for (i = 0; i <= halfIndex; ++i) {
        temp = s[i];
        s[i] = s[lastIndex - i];
        s[lastIndex - i] = temp;
    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int stringLength(char s[]) {
    int len;
    for (len = 0; s[len] != '\0'; ++len)
        ;
    return len;
}
#+END_SRC

#+RESULTS:
: Reverse test  	 HiiH
:  got reversed as
:  HiiH 	  tset esreveR

It works as expected.

Let's finish our works as usual:

#+BEGIN_SRC C :main no :tangle C_codes/ex1_19.c
#include <stdio.h>
#define INITIALMAX 10
#define TRUE 1

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);
void reverse(int length, char line[]);
void copy(char to[], char from[]);

int main()
{
    printOverflowed(INITIALMAX, "", TRUE);
    return 0;
}

void reverse(int len, char s[])
{
    int lastIndex = len - 2;    /* lastIndex except the newline character */
    int halfIndex = (lastIndex - 1) / 2; /* use integer division to be used in loop */
    char temp;                           /* temporary storage to interchange */
    int i;                               /* loop index */
    for (i = 0; i <= halfIndex; ++i) {
        temp = s[i];
        s[i] = s[lastIndex - i];
        s[lastIndex - i] = temp;
    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry) {
            reverse(len, line);
            printf("%s", line);
        }
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                printOverflowed(lim, line, 0);
            }
            else {
                reverse(len, line);
                printf("%s", line);
            }

    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_19.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "trailings        	\nsimple\nones\n" | ./C_codes/current
printf "test empty line\n     	\nlike this\n" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this\n" | ./C_codes/current
#+END_SRC

#+RESULTS:
: 	        sgniliart
: elpmis
: seno
: enil ytpme tset
:
: siht ekil
: tseT
: !eciwt naht regnol esac tset dewolfrevo
: siht ekil
*** External Variables and Scope
:PROPERTIES:
:NOTER_PAGE: 32
:END:
***** Exercise 1-20
:PROPERTIES:
:NOTER_PAGE: 34
:END:


Since we assume that =n= does not change during program execution, it's better
to use symbolic parameter than variable for =n=.

For the designing the behavior, as we don't know prior how many length of line
would it results when we =detab= the given input, we need to dynamic expand the
output string like we did in =printOverflowed=; and we will produce the output
stream by mutating the output string like we did in =copy=.

Or we could achieve the behavior we want by using the strategy used in [[*Exercise 1-9][Exercise
1-9]].

That is, if the input character is tab, then we expand tab as blanks; otherwise,
just copy that input into output. Here is the pseudocode:
#+BEGIN_SRC C
while (input character is not end of file)  {
    if (input eqauls to tab)
        put blanks until (current columns % n) equals to 0;
    else copy the input character into the output;
}

#+END_SRC
So, our program keep track of the current column index as state variable. Here
is the implementation:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_20.c
#include <stdio.h>
#define TABSTOP 4                     /* Tab stop */

int expandtab(int columnIndex);

int main() {
    int c;
    int ncolumn = 0;

    while ((c = getchar()) != EOF) {
        if (c == '\t')
            ncolumn = expandtab(ncolumn); /* update column number */
        else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;    /* initialize column number */
            else ++ncolumn;     /* increase column number */
        }
    }
}

int expandtab(int nc) {
    if ((nc % TABSTOP) == 0) {
        putchar(' ');
        ++nc;
    }
    while((nc % TABSTOP) != 0) {
        putchar(' ');
        ++nc;
    }
    return nc;
}
#+END_SRC

We reasoned the next column line number in =expandtab= by observing that it
should be product of =TABSTOP=; since if the given column index is already
product of =TABSTOP=, it means we should expand the =tab= until next tabstop in
this case, we handled this case explicitly.

Or the we can think =ncolumn= as if the cursor's column number and the input
character stream as user typing in the text editor like now.

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_20.c -o detab
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "sf	a" | ./C_codes/detab
#+END_SRC

#+RESULTS:
: sf  a

***** Exercise 1-21
We can assume the input stream of =entab= to have no tab characters in it -- if
it were, we can eliminate those with the =detab=, which we implemented previously.

Here we also approach to this problem that is analogous to previous one. The
following pseudocode describes our wishful thinking:
#+BEGIN_SRC C
while (the input character is not end of file)  {
    if (input eqauls to blank) {
        consume blanks until it encounters with either next tabstop
            or non-blank character with updating the column line number
            appropriately;
        if (column line is next tabstop)
            print tab character;
        else barfage all the currently consumed blanks /* current input character consumed */
                 }
    else {                      /* non-blanck character */
        copy the input character into the output;
        if (the input character is newline character)
            initialize the column line number -- start with next line;
        else increase column line number by one;
        consume one input character to agree with above if branch;
    }
}

#+END_SRC

#+BEGIN_SRC C :main no :tangle C_codes/ex1_21.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */

int main() {
    int c;
    int ncolumn = 0;
    int nexttabstop;
    int nentry;

    c = getchar();
    while (c != EOF) {
        if (c == ' ') {
            nentry = ncolumn;
            ++ncolumn;
            nexttabstop = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
            while (ncolumn != nexttabstop && (c = getchar()) == ' ') {
                ++ncolumn;
            }
            if (ncolumn == nexttabstop) {
                putchar('\t');
                c = getchar();  /* to agree with next branch */
            } else {
                while(nentry != ncolumn) {
                    putchar(' ');
                    ++nentry;
                }
            }
        } else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;
            else ++ncolumn;
            c = getchar();      /* to agree with above if branch */
        }
    }
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_21.c -o entab
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
# printf "sf		sdfd	d  a" | ./C_codes/detab  | ./C_codes/entab
# printf "sfd a\n" | ./C_codes/entab
printf "sfd     a" | ./C_codes/entab
#+END_SRC
#+RESULTS:
: sfd	a

It agree with my text editor -- Emacs; actually in this environment, we can not
face with the case posed in the statement -- when either a tab or a single blank
would suffice to reach a tab stop -- since in that case, the tab stop character
should reach one more tabstop than next tabstop. We accomplished this by
choosing carefully next tab stop -- ~nexttabstop = ncolumn + (TABSTOP - (ncolumn
% TABSTOP));~, which do the right thing.
***** Exercise 1-22
Before go into designing any code or implementation the requested task, first,
we should make concrete the abstract specification -- it can be seen as part of
designing in a more large scale.

Here is the summary:
+-------+-------------------------+------------------------------------------------+
| Cases |        Situation        |                      Want                      |
+-------+-------------------------+------------------------------------------------+
|     1 | Line contains no blanks |        Fold at n; continue from there.         |
+-------+-------------------------+------------------------------------------------+
|     2 |    Line less than n     |    No fold; just copy that input to output.    |
+-------+-------------------------+------------------------------------------------+
|     3 |  Line with only blanks  | Replace current line with line that has first  |
|       |                         |    non-blank character as its first column     |
|       |                         |                   character.                   |
+-------+-------------------------+------------------------------------------------+
|     4 |   Line has word being   | Fold current line so as the next line to start |
|       |    constructed at n     |   with current word and continue from that.    |
+-------+-------------------------+------------------------------------------------+
|     5 |  Line has blank being   |Consume all consecutive blanks and then initiate|
|       |      consumed at n      | next line & if current input is newline, take  |
|       |                         |      one more character, else do nothing.      |
+-------+-------------------------+------------------------------------------------+

From this, we can observe that to accomplish all of those specifications at the
same time, we need to keep track of the deferred blanks and deferred non-blank
character array separately.

Here is the pseudo state transition diagram to implement:

#+BEGIN_SRC dot :exports results :file C_codes/ex1_22.png
digraph G {
    subgraph cluster0 {
        node [shape = doublecircle, label="newline"] newline
        node [shape = circle, label="IN"] IN
        node [shape = circle, label="OUT"] OUT
        IN -> OUT [label = "has deferred blanks?\nflush blanks", constraint = false]
        OUT -> IN [label = "has deferred non-blanks?\nflush non-blanks", constraint = false]
        IN -> IN [label = "Case 1:"]
        OUT -> OUT [label = "Case 3:"]
        {IN, OUT} -> newline [label = "Case 2:"]
        label = "for column line number < n"
    }
    subgraph cluster1 {
        node [shape = circle, label="IN"] in
        node [shape = circle, label="OUT"] out
        in -> out [label = "Case 4:
                   handover the current deferred non-blanks to next line processor
                   destroy all the deferred blanks"]
        out -> in [label = "Case 5:
                   destory all the defered blanks
                   continue in next line"]
        label = "for column line number >= n"
    }
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_22.png]]

Now we are going to implement this design. First, we are going to cope with for
column line number < n case. Let us first code the pseudocode:
#+BEGIN_SRC C
while (the input character is not end of file character) {
    if (the input character is blank) { /* entry point of white spaces */
        flush deferred blanks if any;
        initialize the deferred blanks;
        defer all the consecutive blanks;
    }
    else if (the input character is newline) { /* Here we only consider the column line number < n */
        if (current state is in the word) {
            flush deferred blanks if any;
            flush deferred word;
        } else {                /* current state is out of the word */
            flush deferred word if any;
            flush deferred blanks;
        }
        initialize the deferred blanks;
        initialize the deferred word;
        initialize the column line number;
    }
    else {                      /* the input character is non-blank character */
        /* this is the entry point of non-blank characters */
        flush deferred word if any;
        initialize the deferred word;
        defer all the consecutive word characters;
    }
}
#+END_SRC

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0

int updateWhenBlank(char c, int ncolumn) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
    return ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

int main() {
    int c;
    int ncolumn = 0;
    char blanks[FOLD] = "";
    int bInd = 0;
    char word[FOLD] = "";
    int wInd = 0;
    int state = OUT;

    c = getchar();
    while (c != EOF) {
        if (isBlankCharacter(c)) {
            ncolumn = updateWhenBlank(c, ncolumn);
            if (bInd > 0) {     /* flush the blanks if any */
                printf("%s", blanks);
                bInd = 0;
            }
            blanks[bInd] = c;   /* defer input character */
            ++bInd;             /* update next Index of blanks */
            while (isBlankCharacter(c = getchar())) { /* consume one more character */
                ncolumn = updateWhenBlank(c, ncolumn);
                blanks[bInd] = c;   /* defer input character */
                ++bInd;             /* update next Index of blanks */
            }
            blanks[bInd] = '\0'; /* the end of string character */
            state = OUT;         /* update state */
        } else if (c == '\n') {
            if (state == IN) {
                if (bInd > 0)
                    printf("%s", blanks);
                if (wInd > 0)
                    printf("%s", word);
            } else {
                if (wInd > 0)
                    printf("%s", word);
                if (bInd > 0)
                    printf("%s", blanks);
            }
            bInd = 0;
            wInd = 0;
            ncolumn = 0;
            putchar('\n');         /* print newline */
            state = OUT;           /* update state */
            c = getchar();         /* consume one character */
        } else {                   /* input character is non-blank character */
            ++ncolumn;             /* update column line number */
            if (wInd > 0) {        /* flush word */
                printf("%s", word);
                wInd = 0;
            }
            word[wInd] = c;     /* defer current character */
            ++wInd;             /* update the word Index */
            while (isWordCharacter(c = getchar())) {
                ++ncolumn;      /* update column line number */
                word[wInd] = c;     /* defer current character */
                ++wInd;             /* update the word Index */
            }
            word[wInd] = '\0';  /* end of string */
            state = IN;             /* update state */
        }
    }
    if (state == IN) {
        if (bInd > 0)
            printf("%s", blanks);
        if (wInd > 0)
            printf("%s", word);
    } else {
        if (wInd > 0)
            printf("%s", word);
        if (bInd > 0)
            printf("%s", blanks);
    }
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be

It works as expected. Now we are going to refactor above code using the external
variable -- it would actually make the code more modular:

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22_refactored.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0

/* external variables */
int ncolumn = 0;
char blanks[FOLD] = "";
int bInd = 0;
char word[FOLD] = "";
int wInd = 0;
int state = OUT;

void updateColumnWhenBlank(char c) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
}

void updateColumnWhenWord(char c) {
    ++ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

void flushBlanksIfAny(void) {
    if (bInd > 0)      /* flush the blanks if any */
        printf("%s", blanks);
}

void flushWordIfAny(void) {
    if (wInd > 0)      /* flush the word if any */
        printf("%s", word);
}

void flushAll(void) {
    if (state == IN) {
        flushBlanksIfAny();
        flushWordIfAny();
    } else {
        flushWordIfAny();
        flushBlanksIfAny();
    }
}

void deferBlank(char c) {
    blanks[bInd] = c;
    ++bInd;
}

void deferWord(char c) {
    word[wInd] = c;
    ++wInd;
}

void initializeBlanks(void) {
    bInd = 0;
}

void initializeWord(void) {
    wInd = 0;
}

void initializeColumn(void) {
    ncolumn = 0;
}

void endOfBlanks(void) {
    blanks[bInd] = '\0';
}

void endOfWord(void) {
    word[wInd] = '\0';
}

int main() {
    int c;

    c = getchar();
    while (c != EOF) {
        if (isBlankCharacter(c)) {
            updateColumnWhenBlank(c);
            flushBlanksIfAny();
            initializeBlanks();
            deferBlank(c);
            while (isBlankCharacter(c = getchar())) { /* consume one more character */
                updateColumnWhenBlank(c);
                deferBlank(c);
            }
            endOfBlanks();
            state = OUT;         /* update state */
        } else if (c == '\n') {
            flushAll();
            initializeBlanks();
            initializeWord();
            initializeColumn();
            putchar('\n');         /* print newline */
            state = OUT;           /* update state */
            c = getchar();         /* consume one character */
        } else {                   /* input character is non-blank character */
            updateColumnWhenWord(c);
            flushWordIfAny();
            initializeWord();
            deferWord(c);
            while (isWordCharacter(c = getchar())) {
                updateColumnWhenWord(c);
                deferWord(c);
            }
            endOfWord();
            state = IN;             /* update state */
        }
    }
    flushAll();
    printf("\nThe current column line number is %d", ncolumn);
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22_refactored.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be
: The current column line number is 18

The column line number also agree with this. With current tool kit, the external
variable effects in a good way since we aren't allowed to use any higher order function.

Now let's turn into another side -- the case where column line number >= n.

#+BEGIN_SRC C
while (the input character is not end of file character) {
    if (the column line number is greater than or equals to n) {
        if (current state is in the word) { /* the current column line number should eqaul to n */
            if (input character is non-word character) { /* actually the actions are same as newline clause's */
                flush all;
                initialize deferred blanks;
                initialize deferred word;
                print new line character;
                initialize column line number;
                set the state OUT;
            }
            else if (have flushed in current line) {
                initialize deferred blanks;
                print new line character;
                set the column line number to the current deferred word index;
            } else {            /* current line densed with all the word character */
                flush deferred word;
                print character that signal this is the folded line;
                print new line character;
                initialize the column line number;
            }
        } else {                /* reached via consuming all the blank characters */
            initialize deferred blanks;
            if (have flushed in current line) {
                flush deferred word;
                if (the input character is new line) /* ensure the current input character is word character */
                    consume until it gets word character;
                print new line character;
                initialize column line number;
            } else {            /* current line has no word character */
                initialize column line number; /* reuse current line */
            }
        }
    }
    else if (the input character is newline) { /* Here we only consider the column line number < n */
        if (current state is in the word) {
            flush deferred blanks if any;
            flush deferred word;
        } else {                /* current state is out of the word */
            flush deferred word if any;
            flush deferred blanks;
        }
        initialize the deferred blanks;
        initialize the deferred word;
        initialize the column line number;
    }
    else if (the input character is blank) { /* entry point of white spaces */
        flush deferred blanks if any;
        initialize the deferred blanks;
        defer all the consecutive blanks;
        set state OUT;
    }
    else {                      /* the input character is non-blank character */
        /* this is the entry point of non-blank characters */
        flush deferred word if any;
        initialize the deferred word;
        defer all the consecutive word characters until column line number less than n; /* changed from before */
        set state IN;
    }
}
#+END_SRC

You should convince yourself above algorithm cope with all the cases we
specified above. Then let's code it

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22_complete.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0
#define TRUE 1
#define FALSE 0

/* external variables */
int ncolumn = 0;
char blanks[FOLD + 1] = "";
int bInd = 0;
char word[FOLD + 1] = "";
int wInd = 0;
int state = OUT;
int hasFlushed =  FALSE;
int c;

void updateColumnWhenBlank(char c) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
}

void updateColumnWhenWord(char c) {
    ++ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

void flushBlanksIfAny(void) {
    if (bInd > 0) {    /* flush the blanks if any */
        hasFlushed = TRUE;
        printf("%s", blanks);
    }
}

void flushWordIfAny(void) {
    if (wInd > 0) {    /* flush the word if any */
        hasFlushed = TRUE;
        printf("%s", word);
    }
}

void flushAll(void) {
    if (state == IN) {
        flushBlanksIfAny();
        flushWordIfAny();
    } else {
        flushWordIfAny();
        flushBlanksIfAny();
    }
}

void deferBlank(char c) {
    blanks[bInd] = c;
    ++bInd;
}

void deferWord(char c) {
    word[wInd] = c;
    ++wInd;
}

void initializeBlanks(void) {
    bInd = 0;
}

void initializeWord(void) {
    wInd = 0;
}

void initializeColumn(void) {
    initializeBlanks();
    initializeWord();
    hasFlushed = FALSE;
    state = OUT;           /* update state */
    ncolumn = 0;
}

void endOfBlanks(void) {
    blanks[bInd] = '\0';
}

void endOfWord(void) {
    word[wInd] = '\0';
}

void flushAndContinueInNext(void) {
    flushAll();
    initializeColumn();
    putchar('\n');         /* print newline */
    c = getchar();         /* consume one character */
}

void signalFolded(void) {
    putchar('-');
}


int main() {

    c = getchar();
    while (c != EOF) {
        if (ncolumn >= FOLD) {
            if (state == IN) {
                if (!isWordCharacter(c))
                    flushAndContinueInNext();
                else if (hasFlushed) {
                    initializeBlanks();
                    putchar('\n');
                    ncolumn = wInd;
                    hasFlushed = FALSE;
                } else {
                    flushWordIfAny();
                    signalFolded();
                    putchar('\n');
                    initializeColumn();
                }
            } else {
                if (hasFlushed) {
                    flushWordIfAny();
                    if (c == '\n')
                        while (!isWordCharacter(c = getchar()))
                            ;
                    putchar('\n');
                    initializeColumn();
                } else {
                    initializeColumn();
                }
            }
        }
        else if (isBlankCharacter(c)) {
            updateColumnWhenBlank(c);
            flushBlanksIfAny();
            initializeBlanks();
            deferBlank(c);
            while (isBlankCharacter(c = getchar()) && ncolumn < FOLD) { /* consume one more character */
                updateColumnWhenBlank(c);
                deferBlank(c);
            }
            endOfBlanks();
            while (isBlankCharacter(c)) { /* consume overflowed blanks */
                c = getchar();
                updateColumnWhenBlank(c);
            }
            state = OUT;         /* update state */
        } else if (c == '\n') {
            flushAndContinueInNext();
        } else {                   /* input character is non-blank character */
            updateColumnWhenWord(c);
            flushWordIfAny();
            initializeWord();
            deferWord(c);
            while (isWordCharacter(c = getchar()) && ncolumn < FOLD) {
                updateColumnWhenWord(c);
                deferWord(c);
            }
            endOfWord();
            state = IN;             /* update state */
        }
    }
    flushAll();
    printf("\nThe current column line number is %d", ncolumn);
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22_complete.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "This line is really long enough                to overflow the fold limit!!" | ./C_codes/current
#+END_SRC

#+RESULTS:
: This line is really
: long enough
: to overflow the fold
: limit!!
: The current column line number is 7

The above test case was just general case, case 4 and 5, let's try other cases we specified
above:
First, the case 2:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be
: The current column line number is 18

Works as expected.

Now case 3:
#+BEGIN_SRC sh :exports both :results verbatim
printf "         	           this line replaced" | ./C_codes/current
#+END_SRC

#+RESULTS:
: this line replaced
: The current column line number is 18

If the line is all blanks and has no word it should be what?

#+BEGIN_SRC sh :exports both :results verbatim
printf "                          " | ./C_codes/current
#+END_SRC

#+RESULTS:
:                         "
: The current column line number is 26

The above one is not what we expected ever. Why such abnormal result happend? If
we reason through carefully, we came to realize it is due to the overflow of our
=blanks= character array -- its length limited to =FOLD= but this one obviously
overflowed that. As we did in =word= case, we should handle the overflow case
explicitly.

But the behavior that we wanted in this case implies that we have to dynamically
expand the =blanks= to cope with just that case; this can be achieved using the
same strategy with =printOverflowed=; but since this involve dramatic changes in
current code -- we can't use external variables any more since =blanks= should
grow dynamically, so external declarations can not cope with that -- so for now
let us just make informal contraction that blank line ends with end of file
character should not overflow the given fold point.

However, we should handle the overflow case explicitly as noted but in different
perspective. That is, the current version modifies invalid memory -- the
overflowed index -- which can cause unexpected result. I've reflected those
changes in above code (for whom having curiosity about that change, see the git
diff for that). Now the above test case return only 20 blanks no more unexpected one.

#+BEGIN_SRC sh :exports both :results verbatim
printf "                          " | ./C_codes/current
#+END_SRC

#+RESULTS:
:
: The current column line number is 26

Let us continue the rest of cases. The last case -- case 1:
#+BEGIN_SRC sh :exports both :results verbatim
printf "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" | ./C_codes/current
#+END_SRC

#+RESULTS:
: aaaaaaaaaaaaaaaaaaaa-
: aaaaaaaaaaaaaaaaaaaa-
: aaaaaa
: The current column line number is 6

Actually our original implementation couldn't cope with this case; from this
test case, we realized that the =blanks= and =word= string should have length
=FOLD + 1= not exactly =FOLD= to afford the end of string character.
***** Exercise 1-23
#+BEGIN_SRC C
printf("This is test for the response of C compiler about the ill-typed comment syntax");
/* like this
#+END_SRC

So it consume all the subsequent characters after opening comment syntax; all we
need to do is just discard all the subsequent input characters until the closing
comment syntax is matched -- =*/=. This is way more simpler task than the one
just before it.

In state diagram, we can draw what we should implement as follows:
#+BEGIN_SRC dot :file C_codes/ex1_23.png :exports results
digraph G {
    rankdir = LR;
    node [shape = doublecircle] "normal" "in comment";
    node [shape = circle];
    "normal" -> "normal" [label = "copy to output\nother than / character"]
    "normal" -> "/" [label = "consume /"]
    "/" -> "normal" [label = "barfage / and copy to output\nother than * character"]
    "/" -> "in comment" [label = "consume *"]
    "in comment" -> "in comment" [label = "consume other than * character"]
    "in comment" -> "*" [label = "consume *"]
    "*" -> "in comment" [label = "barfage * and copy to output\nother than / character"]
    "*" -> "normal" [label = "consume /"]
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_23.png]]

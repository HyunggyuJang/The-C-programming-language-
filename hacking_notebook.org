#+TITLE: Hacking Notebook
* The programming language C
:PROPERTIES:
:NOTER_DOCUMENT: ../Documents/CS/C/Brian W. Kernighan, Dennis M. Ritchie-The ANSI C Programming Language-Prentice Hall (1988).pdf
:END:
** Chapter 1 - A Tutorial Introduction
:PROPERTIES:
:NOTER_PAGE: 9
:END:

*** Getting Started
:PROPERTIES:
:NOTER_PAGE: 9
:END:
We can start the typical hello world program by
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n");
}
#+END_SRC

#+RESULTS:
| hello | world |
**** Exercise 1-1
:PROPERTIES:
:NOTER_PAGE: 11
:END:
- Without semicolon:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world\n")
        }
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:10:5: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
    main(){
    ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-323rOQ.c:11:33: error: expected ';' after expression
        printf("hello, world\n")
                                ^
                                ;
1 warning and 1 error generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-2QhFQd: Permission denied
    #+END_SRC

  And replacing the escape sequence, which representing /newline/, with the
  what that representing:
  #+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("hello, world
");
}
  #+END_SRC

  Results in
  #+BEGIN_SRC C
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
main(){
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: warning: missing terminating '"' character [-Winvalid-pp-token]
    printf("hello, world
           ^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:11:12: error: expected expression
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:12:1: warning: missing terminating '"' character [-Winvalid-pp-token]
");
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:14:1: error: expected '}'
^
/var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-src-zMTuoP.c:10:7: note: to match this '{'
main(){
      ^
3 warnings and 2 errors generated.
/bin/bash: /var/folders/2g/yh1q856s0vl6td_twhv6v5g40000gn/T/babel-73iYaS/C-bin-qJOtkX: Permission denied
  #+END_SRC

  Now it got quite cryptic -- compiler got spit outs all the errors not the one
  that causes all subsequent errors.
**** Exercise 1-2
:PROPERTIES:
:NOTER_PAGE: 11
:END:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

main(){
    printf("\c\b\d\f\e");
}
#+END_SRC

#+RESULTS:
: cd

If the character is not on the mentioned list, it just ignore the backslash --
just return the following character.
*** Variables and Arithmetic Expressions
:PROPERTIES:
:NOTER_PAGE: 11
:END:
**** Output formatting function -- =printf=
:PROPERTIES:
:NOTER_PAGE: 14
:END:
#+BEGIN_SRC C
printf("%d\t%d\n", fahr, celsius);
#+END_SRC
output the first argument -- formatted string -- substituted with second and
third arguemnt in the place of each =%d=, respectively.

I guess it use =%= as expression to be substituted since this character seems
like describing the situation where one element being replaced by another.
**** Exercise 1-3
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 300;                /* upper limit */
    step = 20;                  /* step size */

    fahr = lower;
    printf("%3s %6s\n", "Fahrenheit", "Celsius");
    while (fahr <= upper) {
        celsius = (5.0/9.0) * (fahr - 32.0);
        printf("%3.0f %6.1f\n", fahr, celsius);
        fahr = fahr + step;
    }
}
#+END_SRC

#+RESULTS:
| Fahrenheit | Celsius |
|          0 |   -17.8 |
|         20 |    -6.7 |
|         40 |     4.4 |
|         60 |    15.6 |
|         80 |    26.7 |
|        100 |    37.8 |
|        120 |    48.9 |
|        140 |    60.0 |
|        160 |    71.1 |
|        180 |    82.2 |
|        200 |    93.3 |
|        220 |   104.4 |
|        240 |   115.6 |
|        260 |   126.7 |
|        280 |   137.8 |
|        300 |   148.9 |
**** Exercise 1-4
:PROPERTIES:
:NOTER_PAGE: 16
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version*/

main(){
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;                  /* lower limit of temperature scale */
    upper = 120;                /* upper limit */
    step = 10;                  /* step size */

    celsius = lower;
    printf("%3s %6s\n", "Celsius", "Fahrenheit");
    while (celsius <= upper) {
        fahr = (9.0/5.0) * celsius + 32.0;
        printf("%3.0f %6.1f\n", celsius, fahr);
        celsius = celsius + step;
    }
}
#+END_SRC

#+RESULTS:
| Celsius | Fahrenheit |
|       0 |       32.0 |
|      10 |       50.0 |
|      20 |       68.0 |
|      30 |       86.0 |
|      40 |      104.0 |
|      50 |      122.0 |
|      60 |      140.0 |
|      70 |      158.0 |
|      80 |      176.0 |
|      90 |      194.0 |
|     100 |      212.0 |
|     110 |      230.0 |
|     120 |      248.0 |
*** The for statement
:PROPERTIES:
:NOTER_PAGE: 16
:END:
**** Exercise 1-5
:PROPERTIES:
:NOTER_PAGE: 17
:END:

#+BEGIN_SRC C :main no :exports both
#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 300, 280, ..., 0; floating-point version*/

main(){
    int fahr;
    for (fahr = 300; fahr >= 0; fahr = fahr - 20) {
        printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32.0));
    }
}

#+END_SRC

#+RESULTS:
| 300 | 148.9 |
| 280 | 137.8 |
| 260 | 126.7 |
| 240 | 115.6 |
| 220 | 104.4 |
| 200 |  93.3 |
| 180 |  82.2 |
| 160 |  71.1 |
| 140 |  60.0 |
| 120 |  48.9 |
| 100 |  37.8 |
|  80 |  26.7 |
|  60 |  15.6 |
|  40 |   4.4 |
|  20 |  -6.7 |
|   0 | -17.8 |
*** Symbolic Constants
:PROPERTIES:
:NOTER_PAGE: 17
:END:
I think symbolic constants, defined by =#define=, would be open-coded when it compiled.
#+BEGIN_SRC C :includes <stdio.h> :exports both :defines LOWER 0 UPPER 300 STEP 20
int fahr;
for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
    printf("%3d %6.1f\n", fahr, (5.0/9.0) * (fahr - 32));
#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
*** Character Input and Output
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C :includes <stdio.h>
int c;
c = 50;
printf("\ninteger number %d got translated with putchar into %c\n", c, putchar(c));
#+END_SRC

#+RESULTS:
|       2 |        |    |     |            |      |         |      |   |
| integer | number | 50 | got | translated | with | putchar | into | 2 |
**** File Copying
:PROPERTIES:
:NOTER_PAGE: 18
:END:
#+BEGIN_SRC C
/* copy input to output; 1st version */
int c;

c = getchar();
while (c != EOF) {
    putchar(c);
    c = getchar();
}
#+END_SRC

More concisely, experienced C programmer would write above program as
#+BEGIN_SRC C
/* copy input to output; 2nd version */
int c;

while ((c = getchar ()) != EOF)
    putchar(c);
#+END_SRC

This exploited the fact that the assignment statement -- ~=~ -- has the value
evaluating the right hand side as its return value. Here also we should note
that =EOF= is just one of pre =define= d variable macro that would be replaced
any integer number that would not appear in the real character code.

Using this /trick/, we should be alerted that now we should be considerate on
the /precedence/ issue -- ~!=~ has higher precedence than ~=~.
***** Exercise 1-6
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
getchar() != EOF;
#+END_SRC

#+RESULTS:
#+BEGIN_SRC sh
~/org ÃŽÂ» ./C_codes/a.out
5
The input character 5 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character
 return 1 via "getchar() != EOF"

~/org ÃŽÂ» ./C_codes/a.out

The input character Ã¿ return 0 via "getchar() != EOF"
#+END_SRC

From this exercise, we know that character ~^D~ represent =EOF= (also apparently
0 means the test is false and 1 for the true).
***** Exercise 1-7
:PROPERTIES:
:NOTER_PAGE: 20
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
putchar(EOF);
#+END_SRC

#+RESULTS:
: Ã¿

What we discovered in preceding exercise got verified explicitly.
**** Character Counting
:PROPERTIES:
:NOTER_PAGE: 20
:END:
New operator, which is the mascot expression in C, =++=:
#+BEGIN_SRC C
++nc;
#+END_SRC

Although we have shown in the above example /prefix/ operator =++=, there is
also /postfix/ operator =++=; those have different values in expressions.

As introduced in preceding section, the =for= control structure is just
syntactic sugar for =while=, we could express the word counting program as
#+BEGIN_SRC C :includes <stdio.h> :exports both
double nc;

for (nc = 0; getchar () != EOF; ++nc);
printf("%.0f\n", nc);
#+END_SRC

#+RESULTS:
: 0
***** Exercise 1-8
:PROPERTIES:
:NOTER_PAGE: 22
:END:
#+BEGIN_SRC C :includes <stdio.h> :exports both
long ns, nt, nl;
int c;

ns = 0;
nt = 0;
nl = 0;

while ((c = getchar ()) != EOF) {
    if (c == ' ')
        ++ns;
    if (c == '\t')
        ++nt;
    if (c == '\n')
        ++nl;
}
printf("The number of blanks, tabs, lines are %ld, %ld, %ld, respectively\n", ns, nt, nl);
#+END_SRC

#+RESULTS:
| The number of blanks | tabs | lines are 0 | 0 | 0 | respectively |
***** Exercise 1-9
:PROPERTIES:
:NOTER_PAGE: 22
:END:
Here is the algorithm that solves our task:
1. If the input character stream is not =EOF=,
2. if taken character stream is blank, print single blank and then
3. consume all the successive blanks;
4. else, print that input stream and then update character stream.
5. go to *1.*

Since we haven't yet learned the =else= control structure -- only =if=-then
structure -- we need to mimic the =if-else= structure:

#+BEGIN_SRC C :exports both
int c;
int flag;
c = getchar();
while (c != EOF) {
    flag = 0;               /* mimic if else control structure */
    if (c == ' ') {
        putchar(c);         /* print single blank */
        flag = 1;           /* signal that the entry character was blank */
        while ((c = getchar()) == ' ') /* comsume the successive blanks */
            ;
    }
    if (flag == 0) {        /* if the entry point was non-blank character */
        putchar(c);
        c = getchar();      /* update the c to be consist with comsumption of blanks */
    }
}
#+END_SRC

Then it works as expected:
#+BEGIN_SRC sh
~/org/C_codes [master] Î» ./a.out
asdfsd   sdf   d
asdfsd sdf d
Hi Test thsi    tis   d
Hi Test thsi tis d

#+END_SRC
***** Exercise 1-10
:PROPERTIES:
:NOTER_PAGE: 22
:END:
This program is analogous that of [[*Exercise 1-8][Exercise 1-8]], mimicking the =else= structure:
#+BEGIN_SRC C :includes <stdio.h> :exports both

int c, flag;


while ((c = getchar ()) != EOF) {
    flag = 1;
    if (c == '\b') {
        flag = 0;
        printf("\\b");
    }
    if (c == '\t') {
        flag = 0;
        printf("\\t");
    }
    if (c == '\n') {
        flag = 0;
        printf("\\n");
    }
    if (c == '\\') {
        flag = 0;
        printf("\\\\");
    }
    if (flag)
        putchar(c);
}
#+END_SRC

#+BEGIN_SRC sh
~/org/C_codes [master] Î» echo "tab	\	" | ./a.out
tab\t\\\t\n
#+END_SRC
**** Word Counting
:PROPERTIES:
:NOTER_PAGE: 22
:END:

#+BEGIN_SRC C :tangle C_codes/current.c :includes <stdio.h> :defines IN 1 OUT 0
int c, nl, nw, nc, state;

state = OUT;
nl = nw = nc = 0;
while ((c = getchar()) != EOF) {
    ++nc;
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
}
printf("%d %d %d\n", nl, nw, nc);
#+END_SRC

#+RESULTS:
: 0 0 0
***** Exercise 1-11
:PROPERTIES:
:NOTER_PAGE: 23
:END:

In Org mode, we can use session whenever the language supports ~REPL~; but since
C is the language should involve compiler to produce program, we can not use
them.

So we have to fall back to alternative approach: Use tangle feature.

Then let's test this code:
#+BEGIN_SRC sh
cd C_codes
cc current.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
echo "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
: 1 5 28

We've setup the environment where we integrated the Org babel with the testing C code.

To test this kind of program, we can take two different approaches:
1. Path complete test;
2. black box test -- test the specifications.


The former one tests all the branches the code implemented; in above case, it
has 2 branches in it: First only has consequent clause, second has also
alternative in addition to consequence:
#+BEGIN_SRC C
    if (c == '\n')
        ++nl;
    if (c == ' ' || c == '\n' || c == '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
#+END_SRC

First, let's try the path complete test:
#+BEGIN_SRC sh :exports both
# Test first branch
echo | ./C_codes/current        # echo append '\n' by default
printf | ./C_codes/current      # printf do not append '\n'
# Test second branch
# just pass through first path of second branch
printf "\n\n\n   \t\t\t" | ./C_codes/current
# pass though the second path also
printf "This text contains 5 words." | ./C_codes/current
#+END_SRC

#+RESULTS:
| 1 | 0 |  1 |
| 0 | 0 |  0 |
| 3 | 0 |  9 |
| 0 | 5 | 27 |

Then let's do the latter one; it tests all the boundary cases:
#+BEGIN_SRC sh :exports both
# 0 0 0
printf | ./C_codes/current
# 1 0 1
echo | ./C_codes/current
# 0 0 1
printf " " | ./C_codes/current  # space
printf "\t" | ./C_codes/current  # tab
# 0 1 1
printf "c" | ./C_codes/current
# Compound cases
printf "This is \n compound case.\t" | ./C_codes/current
#+END_SRC

#+RESULTS:
| 0 | 0 |  0 |
| 1 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 0 |  1 |
| 0 | 1 |  1 |
| 1 | 4 | 25 |
***** Exercise 1-12
:PROPERTIES:
:NOTER_PAGE: 23
:END:
All we need to do is
- just copying the input if it were transition of state from
  =IN= to =IN= or =OUT= to =IN=;
- ignore if it were from =OUT= to =OUT=;
- replace it as =\n= if it were from =IN= to =OUT=;


#+BEGIN_SRC C :tangle C_codes/ex1_12.c :includes <stdio.h> :defines IN 1 OUT 0
int c, state;

state = OUT;
while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == OUT)
            ;                   /* ignore the input character */
        else {
            state = OUT;
            putchar('\n');
        }
    }
    else {
        state = IN;
        putchar(c);
    }
}
#+END_SRC

Then test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_12.c -o current
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :exports both
printf "Test words\n\n\n\t\t\t   One Two     Three" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Test  |
| words |
| One   |
| Two   |
| Three |
*** Arrays
:PROPERTIES:
:NOTER_PAGE: 25
:END:
***** Exercise 1-13
:PROPERTIES:
:NOTER_PAGE: 25
:END:
The most canonical way to implement this program would be
1. Assume that we have data structure, table that contains entries which
   consist of key and value;
2. modifying the word counting program, which we implemented in preceding
   section, implement program that counts the length of first word from the
   input stream;
3. for each word in the input stream, insert newly calculated word length into
   the predefined table that contains word length - frequency entries;
4. print the entries in that table using histogram.


But, only with what we've learned so far, we can not implement the assumed data
structure, so we need to approach this exercise in more naive manner.

We are going to use array as table like structure but that table possibly be
very scarce -- inefficient; moreover, as we are not allowed to allocates the
input stream into some temporary file or on memory to use more than once, we can
not cope with extreme cases where maximum word length is enormous.


Here is the resulting code, which approximately implement above algorithm naively:
#+BEGIN_SRC C :tangle C_codes/ex1_13.c :includes <stdio.h> :defines IN 1 OUT 0 MAX_LENG 100

int c, i, j, wl, state;
int nwords[MAX_LENG];

state = OUT;
wl = 0;
for (i = 0; i < MAX_LENG; ++i)
    nwords[i] = 0;

while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\n' || c == '\t') {
        if (state == IN)        /* IN -> OUT transition */
            ++nwords[wl];

        state = OUT;
    }
    else {
        if (state == OUT)       /* OUT -> IN transition */
            wl = 0;             /* initialize word length counter */
        state = IN;
        ++wl;
    }
}

if (state == IN)                /* EOF is also delimiter */
    ++nwords[wl];

printf("%s\t%s\n", "Word length", "Frequency");
for (i = 0; i < MAX_LENG; ++i) {
    if (nwords[i] != 0) {       /* print only non zero frequency entries */
        printf("%d\t", i);
        for (j = 0; j < nwords[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_13.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_13.c | ./C_codes/current
# printf "test\nMy-test test" | ./C_codes/current
#+END_SRC

#+RESULTS:
| Word length | Frequency                                          |
|           1 | **********************************                 |
|           2 | ************************************************** |
|           3 | ******************                                 |
|           4 | *************                                      |
|           5 | **********                                         |
|           6 | *******                                            |
|           7 | *****                                              |
|           8 | ***                                                |
|           9 | *********                                          |
|          10 | ******                                             |
|          13 | ****                                               |
|          14 | **                                                 |
|          17 | *                                                  |
|          18 | *                                                  |
***** Exercise 1-14
:PROPERTIES:
:NOTER_PAGE: 25
:END:
This is an analogous program of preceding exercise. The maximum length becomes
='z' - 'a'= and the others are obvious relations:

#+BEGIN_SRC C :tangle C_codes/ex1_14.c :includes <stdio.h>
int c, i, j;
int length = 'z' - 'a' + 1;
int nchars[length];

for (i = 0; i < length; ++i)
    nchars[i] = 0;

while ((c = getchar()) != EOF) {
    if ('a' <= c && c <= 'z')
        ++nchars[c - 'a'];
}

printf("%s\t%s\n", "Character", "Frequency");
for (i = 0; i < length; ++i) {
    if (nchars[i] != 0) {       /* print only non zero frequency entries */
        printf("%c\t", i + 'a');
        for (j = 0; j < nchars[i]; ++j) /* print histogram which represent frequency */
            putchar('*');
        putchar('\n');
    }
}
#+END_SRC

Then setup
#+BEGIN_SRC sh
cd C_codes
cc ex1_14.c -o current
#+END_SRC

#+RESULTS:

Then test by feeding the source program itself to the compiled program:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_14.c | ./C_codes/current
# printf "zzzz AAA aaaa" | ./C_codes/current # only count lowercase character
#+END_SRC

#+RESULTS:
| Character | Frequency                      |
| a         | ****************               |
| c         | ********************           |
| d         | **                             |
| e         | *********************          |
| f         | *********                      |
| g         | ******                         |
| h         | ******************             |
| i         | ****************************   |
| j         | ****                           |
| l         | *******                        |
| m         | **                             |
| n         | ****************************** |
| o         | ********                       |
| p         | *******                        |
| q         | ***                            |
| r         | ***************************    |
| s         | ***********                    |
| t         | ***********************        |
| u         | *******                        |
| w         | **                             |
| y         | ****                           |
| z         | ***                            |
*** Functions
:PROPERTIES:
:NOTER_PAGE: 26
:END:
Let's test recursive definition of =power=:
#+BEGIN_SRC C :main no :exports both
#include <stdio.h>
int power(int m, int n);

main()
{
    int i;

    printf("power(2,5) is %d", power(2, 5));
}

/* recursive definition of exponentiation */
int power(int base, int n)
{
    if (n == 0)
        return 1;
    else
        return base * power(base, n - 1);
}
#+END_SRC

#+RESULTS:
| power(2 | 5) is 32 |

Yes it works as expected.
***** Exercise 1-15
#+BEGIN_SRC C :main no :tangle C_codes/ex1_15.c :exports both
#include <stdio.h>

#define LOWER 0
#define UPPER 300
#define STEP 20

float fahr2cels(float fahr);
/* test temperature conversion function */
main () {
    float fahr;
    for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf("%3.0f %6.1f\n", fahr, fahr2cels(fahr));
    return 0;
}
/* temperature conversion function from fahrenheit to celsius*/
float fahr2cels(float fahr) {
    return (5.0/9.0) * (fahr - 32.0);
}

#+END_SRC

#+RESULTS:
|   0 | -17.8 |
|  20 |  -6.7 |
|  40 |   4.4 |
|  60 |  15.6 |
|  80 |  26.7 |
| 100 |  37.8 |
| 120 |  48.9 |
| 140 |  60.0 |
| 160 |  71.1 |
| 180 |  82.2 |
| 200 |  93.3 |
| 220 | 104.4 |
| 240 | 115.6 |
| 260 | 126.7 |
| 280 | 137.8 |
| 300 | 148.9 |
*** Call by value
*** Character array
***** Exercise 1-16
:PROPERTIES:
:NOTER_PAGE: 31
:END:
Since C is strictly typed language, if the specific task does not require, we
usually do not code in dynamic manner -- recursive function definition and so on.

However in this exercise, we can not cope with this task without using
dynamically evolving program since we are dealing with unknown input stream --
it is inheritly dynamic one.

To cope with this task, we will try to use the recursive function definition to
accommodate sufficient memory for given input stream.

We are going to define =printOverflowed= that print longest input line. It takes
=maxline=, =impending[]= (if any):
#+BEGIN_SRC C :main no :tangle C_codes/ex1_16.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    int len;
    int max;
    int overflow = 0;
    char line[INITIALMAX];
    char longest[INITIALMAX];

    max = 0;
    while ((len = getlineFrom(0, line, INITIALMAX)) > 0)
        if (isOverflowed(line, len, INITIALMAX)) {
            overflow = 1;
            printOverflowed(INITIALMAX, line);
        }
        else if (len > max) {
            max = len;
            copy(longest, line);
        }
    if (overflow != 1 && max > 0)
        printf("%s", longest);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[])
{
    int len, max;
    int overflow = 0;
    int lim = 2 * oldLim;
    char line[lim];
    char longest[lim];

    copy(line, impending);
    max = len = getlineFrom(oldLim - 1, line, lim);
    if (isOverflowed(line, len, lim))
        printOverflowed(lim, line);
    else {
        copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (overflow != 1)
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

We've handled the overflowed condition explicitly using the =printOverflowed=
function. It is almost same as the entry point function, =main= except it
handles allocates the current line and longest line with extended limit array indice.

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
***** Exercise 1-17
:PROPERTIES:
:NOTER_PAGE: 31
:END:
We can achieve what we want by modifying the preceding example. That is,
whenever we encounters input line that is longer than threadhold length.

Before doing modification of code of [[*Exercise 1-16][Exercise 1-16]], let us first refactor that
code to encompass the entry point case into the =printOverflowed= so that we can
easily change the behavior of that program by making them modular.

We used following experiment to refactor our code:

#+NAME: Test logical not
#+BEGIN_SRC C :exports both
printf("%d", !0);
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC C :main no :tangle C_codes/ex1_16_refactored.c
#include <stdio.h>
#define INITIALMAX 10

int getlineFrom(int fromIndex, char line[], int maxline);
void copy(char to[], char from[]);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len, max;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];
    char longest[lim];

    if (isentry) {
        max = 0;
    }
    else {
        copy(line, impending);
        max = len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            copy(longest, line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len > max) {
                max = len;
                copy(longest, line);
            }
        if (!overflow && (!isentry || (isentry && max > 0)))
            printf("%s", longest);
    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Our =main= routine got simplified just calling the subroutines appropriately.
Let's test this refactored code:


Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_16_refactored.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "test\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| simple     |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |

It works as expected.

Now we turn to the our original task; it actually simpler than preceding
exercise. All we need to do is just print given line if it is longer than the
threadhold length.

#+BEGIN_SRC C :main no :tangle C_codes/ex1_17.c
#include <stdio.h>
#define INITIALMAX 10
#define TREADHOLD 8

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
void copy(char to[], char from[]);
int isOverflowed(char line[], int lineLength, int maxline);

main()
{
    printOverflowed(INITIALMAX, "", 1);
    return 0;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int overflow = 0;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            if (len >= TREADHOLD)
                printf("%s", line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                overflow = 1;
                printOverflowed(lim, line, 0);
            }
            else if (len >= TREADHOLD)
                printf("%s", line);

    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_17.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both
printf "threadhold\nsimple\nones" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
| threadhold |      |      |        |      |        |
| overflowed | test | case | longer | than | twice! |
| like       | this |      |        |      |        |

Seems like works well.
***** Exercise 1-18
:PROPERTIES:
:NOTER_PAGE: 31
:END:
What we need is function that removes trailing blanks and tabs from given line;
if we implement that function, all the left is to apply that function to each of
input line that is allowed to be arbitrary length.

So here we are going to design remove trailing blanks and tabs from given
argument character array. It needs to take character array with the length of
that to detect the last element; it will mutate the argument array if it has
trailing white spaces. And finally it will return the truncated length to make
the caller to take action with that information -- for this specific case, not
to print the zero length line.

#+BEGIN_SRC C :main no :results verbatim :exports both
#include <stdio.h>

int removeTrailings(int length, char line[]);
int isWhite(char character);
int stringLength(char line[]);
void copy(char to[], char from[]);

/* Test remove trailings */
int main()
{
    char test[] = "Test trailings     		  \n";
    int len = stringLength(test);
    char testCopy[len];
    copy(testCopy, test);       /* copy the test into the testCopy */
    removeTrailings(len, test); /* remove trailings of test */
    printf("%s, which has length %d, got truncated as \n%s, which now has length %d",
           testCopy,
           stringLength(testCopy),
           test,
           stringLength(test));
    return 0;
}

int removeTrailings(int len, char s[])
{
    int i = len - 2;
    int newlen;
    if (isWhite(s[i])) {
        s[i+1] = '\0';          /* make the newline character to be null */
        while(i >= 0 && isWhite(s[i])) { /* make sure not to be underflow */
            s[i] = '\0';        /* remove trailing white spaces */
            --i;
        }
        if (i >= 0) {
            ++i;
            s[i] = '\n';      /* restore newline character to be end of new result */
            newlen = i;         /* new length */
        } else
            newlen = 0;
    } else
        newlen = len;
    return newlen;
}

int isWhite(char c) {
    return c == '\t' || c == ' ';
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int stringLength(char s[]) {
    int len;
    for (len = 0; s[len] != '\0'; ++len)
        ;
    return len;
}
#+END_SRC

#+RESULTS:
: Test trailings
: , which has length 24, got truncated as
: Test trailings
: , which now has length 15

Seems works well.

Now we can integrate all of the pieces:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_18.c
#include <stdio.h>
#define INITIALMAX 10
#define TRUE 1

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);
int removeTrailings(int length, char line[]);
int isWhite(char character);
void copy(char to[], char from[]);

int main()
{
    printOverflowed(INITIALMAX, "", TRUE);
    return 0;
}

int removeTrailings(int len, char s[])
{
    int i = len - 2;
    int newlen;
    if (isWhite(s[i])) {
        s[i+1] = '\0';          /* make the newline character to be null */
        while(i >= 0 && isWhite(s[i])) { /* make sure not to be underflow */
            s[i] = '\0';        /* remove trailing white spaces */
            --i;
        }
        if (i >= 0) {
            ++i;
            s[i] = '\n';      /* restore newline character to be end of new result */
            newlen = i;         /* new length */
        } else
            newlen = 0;
    } else
        newlen = len;
    return newlen;
}

int isWhite(char c) {
    return c == '\t' || c == ' ';
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry)
            if ((len = removeTrailings(len, line)) > 0)
                printf("%s", line);
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                printOverflowed(lim, line, 0);
            }
            else if ((len = removeTrailings(len, line)) > 0)
                printf("%s", line);

    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_18.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "trailings        	\nsimple\nones\n" | ./C_codes/current
printf "test empty line\n     	\nlike this" | ./C_codes/current
# printf "Test\noverflowed test case longer than twice!\nlike this" | ./C_codes/current
#+END_SRC

#+RESULTS:
: trailings
: simple
: ones
: test empty line
: like this

Works as expected.
***** Exercise 1-19
:PROPERTIES:
:NOTER_PAGE: 31
:END:
I've designed this problem -- the algorithm behind this -- in my digital paper.
It is way more easy to describe in image rather than text; briefly, we are going
to reverse given array in place -- looping through half of the index and
interchange front half part with rear half part.

#+BEGIN_SRC C :main no :results verbatim :exports both
#include <stdio.h>

void reverse(int length, char line[]);
int stringLength(char line[]);
void copy(char to[], char from[]);

/* Test remove trailings */
int main()
{
    char test[] = "Reverse test  \t HiiH \n";
    int len = stringLength(test);
    char testCopy[len];
    copy(testCopy, test);       /* copy the test into the testCopy */
    reverse(len, test); /* reverse the test */
    printf("%s got reversed as \n%s",
           testCopy,
           test);
    return 0;
}

void reverse(int len, char s[])
{
    int lastIndex = len - 2;    /* lastIndex except the newline character */
    int halfIndex = (lastIndex - 1) / 2; /* use integer division to be used in loop */
    char temp;                           /* temporary storage to interchange */
    int i;                               /* loop index */
    for (i = 0; i <= halfIndex; ++i) {
        temp = s[i];
        s[i] = s[lastIndex - i];
        s[lastIndex - i] = temp;
    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int stringLength(char s[]) {
    int len;
    for (len = 0; s[len] != '\0'; ++len)
        ;
    return len;
}
#+END_SRC

#+RESULTS:
: Reverse test  	 HiiH
:  got reversed as
:  HiiH 	  tset esreveR

It works as expected.

Let's finish our works as usual:

#+BEGIN_SRC C :main no :tangle C_codes/ex1_19.c
#include <stdio.h>
#define INITIALMAX 10
#define TRUE 1

int getlineFrom(int fromIndex, char line[], int maxline);
void printOverflowed(int maxline, char impending[], int isentrypoint);
int isOverflowed(char line[], int lineLength, int maxline);
void reverse(int length, char line[]);
void copy(char to[], char from[]);

int main()
{
    printOverflowed(INITIALMAX, "", TRUE);
    return 0;
}

void reverse(int len, char s[])
{
    int lastIndex = len - 2;    /* lastIndex except the newline character */
    int halfIndex = (lastIndex - 1) / 2; /* use integer division to be used in loop */
    char temp;                           /* temporary storage to interchange */
    int i;                               /* loop index */
    for (i = 0; i <= halfIndex; ++i) {
        temp = s[i];
        s[i] = s[lastIndex - i];
        s[lastIndex - i] = temp;
    }
}

void copy(char to[], char from[])
{
    int i;
    for (i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}

int getlineFrom(int from, char s[], int lim)
{
    int c, i;
    for (i = from; i < lim-1 && (c=getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void printOverflowed(int oldLim, char impending[], int isentry)
{
    int len;
    int lim;

    if (isentry)
        lim = oldLim;
    else lim = 2 * oldLim;

    char line[lim];

    if (!isentry) {
        copy(line, impending);
        len = getlineFrom(oldLim - 1, line, lim);
    }

    if (!isentry && isOverflowed(line, len, lim))
        printOverflowed(lim, line, 0);
    else {
        if (!isentry) {
            reverse(len, line);
            printf("%s", line);
        }
        while ((len = getlineFrom(0, line, lim)) > 0)
            if (isOverflowed(line, len, lim)) {
                printOverflowed(lim, line, 0);
            }
            else {
                reverse(len, line);
                printf("%s", line);
            }

    }
}

int isOverflowed(char s[], int len, int lim) {
    return (len == lim - 1) && (s[lim - 2] != '\n');
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_19.c -o current
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "trailings        	\nsimple\nones\n" | ./C_codes/current
printf "test empty line\n     	\nlike this\n" | ./C_codes/current
printf "Test\noverflowed test case longer than twice!\nlike this\n" | ./C_codes/current
#+END_SRC

#+RESULTS:
: 	        sgniliart
: elpmis
: seno
: enil ytpme tset
:
: siht ekil
: tseT
: !eciwt naht regnol esac tset dewolfrevo
: siht ekil
*** External Variables and Scope
:PROPERTIES:
:NOTER_PAGE: 32
:END:
***** Exercise 1-20
:PROPERTIES:
:NOTER_PAGE: 34
:END:


Since we assume that =n= does not change during program execution, it's better
to use symbolic parameter than variable for =n=.

For the designing the behavior, as we don't know prior how many length of line
would it results when we =detab= the given input, we need to dynamic expand the
output string like we did in =printOverflowed=; and we will produce the output
stream by mutating the output string like we did in =copy=.

Or we could achieve the behavior we want by using the strategy used in [[*Exercise 1-9][Exercise
1-9]].

That is, if the input character is tab, then we expand tab as blanks; otherwise,
just copy that input into output. Here is the pseudocode:
#+BEGIN_SRC C
while (input character is not end of file)  {
    if (input eqauls to tab)
        put blanks until (current columns % n) equals to 0;
    else copy the input character into the output;
}

#+END_SRC
So, our program keep track of the current column index as state variable. Here
is the implementation:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_20.c
#include <stdio.h>
#define TABSTOP 4                     /* Tab stop */

int expandtab(int columnIndex);

int main() {
    int c;
    int ncolumn = 0;

    while ((c = getchar()) != EOF) {
        if (c == '\t')
            ncolumn = expandtab(ncolumn); /* update column number */
        else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;    /* initialize column number */
            else ++ncolumn;     /* increase column number */
        }
    }
}

int expandtab(int nc) {
    if ((nc % TABSTOP) == 0) {
        putchar(' ');
        ++nc;
    }
    while((nc % TABSTOP) != 0) {
        putchar(' ');
        ++nc;
    }
    return nc;
}
#+END_SRC

We reasoned the next column line number in =expandtab= by observing that it
should be product of =TABSTOP=; since if the given column index is already
product of =TABSTOP=, it means we should expand the =tab= until next tabstop in
this case, we handled this case explicitly.

Or the we can think =ncolumn= as if the cursor's column number and the input
character stream as user typing in the text editor like now.

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_20.c -o detab
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "sf	a" | ./C_codes/detab
#+END_SRC

#+RESULTS:
: sf  a
***** Exercise 1-21
We can assume the input stream of =entab= to have no tab characters in it -- if
it were, we can eliminate those with the =detab=, which we implemented previously.

Here we also approach to this problem that is analogous to previous one. The
following pseudocode describes our wishful thinking:
#+BEGIN_SRC C
while (the input character is not end of file)  {
    if (input eqauls to blank) {
        consume blanks until it encounters with either next tabstop
            or non-blank character with updating the column line number
            appropriately;
        if (column line is next tabstop)
            print tab character;
        else barfage all the currently consumed blanks /* current input character consumed */
                 }
    else {                      /* non-blanck character */
        copy the input character into the output;
        if (the input character is newline character)
            initialize the column line number -- start with next line;
        else increase column line number by one;
        consume one input character to agree with above if branch;
    }
}

#+END_SRC

#+BEGIN_SRC C :main no :tangle C_codes/ex1_21.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */

int main() {
    int c;
    int ncolumn = 0;
    int nexttabstop;
    int nentry;

    c = getchar();
    while (c != EOF) {
        if (c == ' ') {
            nentry = ncolumn;
            ++ncolumn;
            nexttabstop = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
            while (ncolumn != nexttabstop && (c = getchar()) == ' ') {
                ++ncolumn;
            }
            if (ncolumn == nexttabstop) {
                putchar('\t');
                c = getchar();  /* to agree with next branch */
            } else {
                while(nentry != ncolumn) {
                    putchar(' ');
                    ++nentry;
                }
            }
        } else {
            putchar(c);
            if (c == '\n')
                ncolumn = 0;
            else ++ncolumn;
            c = getchar();      /* to agree with above if branch */
        }
    }
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_21.c -o entab
#+END_SRC

#+RESULTS:

Test:
#+BEGIN_SRC sh :exports both :results verbatim
# printf "sf		sdfd	d  a" | ./C_codes/detab  | ./C_codes/entab
# printf "sfd a\n" | ./C_codes/entab
printf "sfd     a" | ./C_codes/entab
#+END_SRC
#+RESULTS:
: sfd	a

It agree with my text editor -- Emacs; actually in this environment, we can not
face with the case posed in the statement -- when either a tab or a single blank
would suffice to reach a tab stop -- since in that case, the tab stop character
should reach one more tabstop than next tabstop. We accomplished this by
choosing carefully next tab stop -- ~nexttabstop = ncolumn + (TABSTOP - (ncolumn
% TABSTOP));~, which do the right thing.
***** Exercise 1-22
Before go into designing any code or implementation the requested task, first,
we should make concrete the abstract specification -- it can be seen as part of
designing in a more large scale.

Here is the summary:
+-------+-------------------------+------------------------------------------------+
| Cases |        Situation        |                      Want                      |
+-------+-------------------------+------------------------------------------------+
|     1 | Line contains no blanks |        Fold at n; continue from there.         |
+-------+-------------------------+------------------------------------------------+
|     2 |    Line less than n     |    No fold; just copy that input to output.    |
+-------+-------------------------+------------------------------------------------+
|     3 |  Line with only blanks  | Replace current line with line that has first  |
|       |                         |    non-blank character as its first column     |
|       |                         |                   character.                   |
+-------+-------------------------+------------------------------------------------+
|     4 |   Line has word being   | Fold current line so as the next line to start |
|       |    constructed at n     |   with current word and continue from that.    |
+-------+-------------------------+------------------------------------------------+
|     5 |  Line has blank being   |Consume all consecutive blanks and then initiate|
|       |      consumed at n      | next line & if current input is newline, take  |
|       |                         |      one more character, else do nothing.      |
+-------+-------------------------+------------------------------------------------+

From this, we can observe that to accomplish all of those specifications at the
same time, we need to keep track of the deferred blanks and deferred non-blank
character array separately.

Here is the pseudo state transition diagram to implement:

#+BEGIN_SRC dot :exports results :file C_codes/ex1_22.png
digraph G {
    rankdir = LR;
    subgraph cluster1 {
        style = filled
        color = lightgrey
        node [shape = circle, label="IN"] in
        node [shape = circle, label="OUT"] out
        in -> out [label = "Case 4:
                   handover the current deferred non-blanks to next line processor
                   destroy all the deferred blanks"]
        out -> in [label = "Case 5:
                   destory all the defered blanks
                   continue in next line"]
        label = "for column line number >= n"
    }
    subgraph cluster0 {
        color = white
        node [shape = doublecircle, label="newline"] newline
        node [shape = circle, label="IN"] IN
        node [shape = circle, label="OUT"] OUT
        IN -> OUT [label = "consume blank character\nflush blanks"]
        OUT -> IN [label = "consume word character\nflush word"]
        IN -> in [label = "Case 1:"]
        OUT -> out [label = "Case 3:"]
        {IN, OUT} -> newline [label = "Case 2:"]
        label = "for column line number < n"
    }
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_22.png]]

Now we are going to implement this design. First, we are going to cope with for
column line number < n case. Let us first code the pseudocode:
#+BEGIN_SRC C
while (the input character is not end of file character) {
    if (the input character is blank) { /* entry point of white spaces */
        flush deferred blanks if any;
        initialize the deferred blanks;
        defer all the consecutive blanks;
    }
    else if (the input character is newline) { /* Here we only consider the column line number < n */
        if (current state is in the word) {
            flush deferred blanks if any;
            flush deferred word;
        } else {                /* current state is out of the word */
            flush deferred word if any;
            flush deferred blanks;
        }
        initialize the deferred blanks;
        initialize the deferred word;
        initialize the column line number;
    }
    else {                      /* the input character is non-blank character */
        /* this is the entry point of non-blank characters */
        flush deferred word if any;
        initialize the deferred word;
        defer all the consecutive word characters;
    }
}
#+END_SRC

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0

int updateWhenBlank(char c, int ncolumn) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
    return ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

int main() {
    int c;
    int ncolumn = 0;
    char blanks[FOLD] = "";
    int bInd = 0;
    char word[FOLD] = "";
    int wInd = 0;
    int state = OUT;

    c = getchar();
    while (c != EOF) {
        if (isBlankCharacter(c)) {
            ncolumn = updateWhenBlank(c, ncolumn);
            if (bInd > 0) {     /* flush the blanks if any */
                printf("%s", blanks);
                bInd = 0;
            }
            blanks[bInd] = c;   /* defer input character */
            ++bInd;             /* update next Index of blanks */
            while (isBlankCharacter(c = getchar())) { /* consume one more character */
                ncolumn = updateWhenBlank(c, ncolumn);
                blanks[bInd] = c;   /* defer input character */
                ++bInd;             /* update next Index of blanks */
            }
            blanks[bInd] = '\0'; /* the end of string character */
            state = OUT;         /* update state */
        } else if (c == '\n') {
            if (state == IN) {
                if (bInd > 0)
                    printf("%s", blanks);
                if (wInd > 0)
                    printf("%s", word);
            } else {
                if (wInd > 0)
                    printf("%s", word);
                if (bInd > 0)
                    printf("%s", blanks);
            }
            bInd = 0;
            wInd = 0;
            ncolumn = 0;
            putchar('\n');         /* print newline */
            state = OUT;           /* update state */
            c = getchar();         /* consume one character */
        } else {                   /* input character is non-blank character */
            ++ncolumn;             /* update column line number */
            if (wInd > 0) {        /* flush word */
                printf("%s", word);
                wInd = 0;
            }
            word[wInd] = c;     /* defer current character */
            ++wInd;             /* update the word Index */
            while (isWordCharacter(c = getchar())) {
                ++ncolumn;      /* update column line number */
                word[wInd] = c;     /* defer current character */
                ++wInd;             /* update the word Index */
            }
            word[wInd] = '\0';  /* end of string */
            state = IN;             /* update state */
        }
    }
    if (state == IN) {
        if (bInd > 0)
            printf("%s", blanks);
        if (wInd > 0)
            printf("%s", word);
    } else {
        if (wInd > 0)
            printf("%s", word);
        if (bInd > 0)
            printf("%s", blanks);
    }
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be

It works as expected. Now we are going to refactor above code using the external
variable -- it would actually make the code more modular:

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22_refactored.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0

/* external variables */
int ncolumn = 0;
char blanks[FOLD] = "";
int bInd = 0;
char word[FOLD] = "";
int wInd = 0;
int state = OUT;

void updateColumnWhenBlank(char c) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
}

void updateColumnWhenWord(char c) {
    ++ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

void flushBlanksIfAny(void) {
    if (bInd > 0)      /* flush the blanks if any */
        printf("%s", blanks);
}

void flushWordIfAny(void) {
    if (wInd > 0)      /* flush the word if any */
        printf("%s", word);
}

void flushAll(void) {
    if (state == IN) {
        flushBlanksIfAny();
        flushWordIfAny();
    } else {
        flushWordIfAny();
        flushBlanksIfAny();
    }
}

void deferBlank(char c) {
    blanks[bInd] = c;
    ++bInd;
}

void deferWord(char c) {
    word[wInd] = c;
    ++wInd;
}

void initializeBlanks(void) {
    bInd = 0;
}

void initializeWord(void) {
    wInd = 0;
}

void initializeColumn(void) {
    ncolumn = 0;
}

void endOfBlanks(void) {
    blanks[bInd] = '\0';
}

void endOfWord(void) {
    word[wInd] = '\0';
}

int main() {
    int c;

    c = getchar();
    while (c != EOF) {
        if (isBlankCharacter(c)) {
            updateColumnWhenBlank(c);
            flushBlanksIfAny();
            initializeBlanks();
            deferBlank(c);
            while (isBlankCharacter(c = getchar())) { /* consume one more character */
                updateColumnWhenBlank(c);
                deferBlank(c);
            }
            endOfBlanks();
            state = OUT;         /* update state */
        } else if (c == '\n') {
            flushAll();
            initializeBlanks();
            initializeWord();
            initializeColumn();
            putchar('\n');         /* print newline */
            state = OUT;           /* update state */
            c = getchar();         /* consume one character */
        } else {                   /* input character is non-blank character */
            updateColumnWhenWord(c);
            flushWordIfAny();
            initializeWord();
            deferWord(c);
            while (isWordCharacter(c = getchar())) {
                updateColumnWhenWord(c);
                deferWord(c);
            }
            endOfWord();
            state = IN;             /* update state */
        }
    }
    flushAll();
    printf("\nThe current column line number is %d", ncolumn);
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22_refactored.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be
: The current column line number is 18

The column line number also agree with this. With current tool kit, the external
variable effects in a good way since we aren't allowed to use any higher order function.

Now let's turn into another side -- the case where column line number >= n.

#+BEGIN_SRC C
while (the input character is not end of file character) {
    if (the column line number is greater than or equals to n) {
        if (current state is in the word) { /* the current column line number should eqaul to n */
            if (input character is non-word character) { /* actually the actions are same as newline clause's */
                flush all;
                initialize deferred blanks;
                initialize deferred word;
                print new line character;
                initialize column line number;
                set the state OUT;
            }
            else if (have flushed in current line) {
                initialize deferred blanks;
                print new line character;
                set the column line number to the current deferred word index;
            } else {            /* current line densed with all the word character */
                flush deferred word;
                print character that signal this is the folded line;
                print new line character;
                initialize the column line number;
            }
        } else {                /* reached via consuming all the blank characters */
            initialize deferred blanks;
            if (have flushed in current line) {
                flush deferred word;
                if (the input character is new line) /* ensure the current input character is word character */
                    consume until it gets word character;
                print new line character;
                initialize column line number;
            } else {            /* current line has no word character */
                initialize column line number; /* reuse current line */
            }
        }
    }
    else if (the input character is newline) { /* Here we only consider the column line number < n */
        if (current state is in the word) {
            flush deferred blanks if any;
            flush deferred word;
        } else {                /* current state is out of the word */
            flush deferred word if any;
            flush deferred blanks;
        }
        initialize the deferred blanks;
        initialize the deferred word;
        initialize the column line number;
    }
    else if (the input character is blank) { /* entry point of white spaces */
        flush deferred blanks if any;
        initialize the deferred blanks;
        defer all the consecutive blanks;
        set state OUT;
    }
    else {                      /* the input character is non-blank character */
        /* this is the entry point of non-blank characters */
        flush deferred word if any;
        initialize the deferred word;
        defer all the consecutive word characters until column line number less than n; /* changed from before */
        set state IN;
    }
}
#+END_SRC

You should convince yourself above algorithm cope with all the cases we
specified above. Then let's code it

#+BEGIN_SRC C :main no :tangle C_codes/ex1_22_complete.c
#include <stdio.h>
#define TABSTOP 4               /* Tab stop */
#define FOLD 20                 /* fold point */
#define IN 1
#define OUT 0
#define TRUE 1
#define FALSE 0

/* external variables */
int ncolumn = 0;
char blanks[FOLD + 1] = "";
int bInd = 0;
char word[FOLD + 1] = "";
int wInd = 0;
int state = OUT;
int hasFlushed =  FALSE;
int c;

void updateColumnWhenBlank(char c) {
    if (c == '\t')      /* update ncolumn */
        ncolumn = ncolumn + (TABSTOP - (ncolumn % TABSTOP));
    else ++ncolumn;
}

void updateColumnWhenWord(char c) {
    ++ncolumn;
}

int isWordCharacter(char c) {
    return !(c == ' ' || c == '\t' || c == '\n' || c == EOF);
}

int isBlankCharacter(char c) {
    return (c == ' ' || c == '\t');
}

void flushBlanksIfAny(void) {
    if (bInd > 0) {    /* flush the blanks if any */
        hasFlushed = TRUE;
        printf("%s", blanks);
    }
}

void flushWordIfAny(void) {
    if (wInd > 0) {    /* flush the word if any */
        hasFlushed = TRUE;
        printf("%s", word);
    }
}

void flushAll(void) {
    if (state == IN) {
        flushBlanksIfAny();
        flushWordIfAny();
    } else {
        flushWordIfAny();
        flushBlanksIfAny();
    }
}

void deferBlank(char c) {
    blanks[bInd] = c;
    ++bInd;
}

void deferWord(char c) {
    word[wInd] = c;
    ++wInd;
}

void initializeBlanks(void) {
    bInd = 0;
}

void initializeWord(void) {
    wInd = 0;
}

void initializeColumn(void) {
    initializeBlanks();
    initializeWord();
    hasFlushed = FALSE;
    state = OUT;           /* update state */
    ncolumn = 0;
}

void endOfBlanks(void) {
    blanks[bInd] = '\0';
}

void endOfWord(void) {
    word[wInd] = '\0';
}

void flushAndContinueInNext(void) {
    flushAll();
    initializeColumn();
    putchar('\n');         /* print newline */
    c = getchar();         /* consume one character */
}

void signalFolded(void) {
    putchar('-');
}


int main() {

    c = getchar();
    while (c != EOF) {
        if (ncolumn >= FOLD) {
            if (state == IN) {
                if (!isWordCharacter(c))
                    flushAndContinueInNext();
                else if (hasFlushed) {
                    initializeBlanks();
                    putchar('\n');
                    ncolumn = wInd;
                    hasFlushed = FALSE;
                } else {
                    flushWordIfAny();
                    signalFolded();
                    putchar('\n');
                    initializeColumn();
                }
            } else {
                if (hasFlushed) {
                    flushWordIfAny();
                    if (c == '\n')
                        while (!isWordCharacter(c = getchar()))
                            ;
                    putchar('\n');
                    initializeColumn();
                } else {
                    initializeColumn();
                }
            }
        }
        else if (isBlankCharacter(c)) {
            updateColumnWhenBlank(c);
            flushBlanksIfAny();
            initializeBlanks();
            deferBlank(c);
            while (isBlankCharacter(c = getchar()) && ncolumn < FOLD) { /* consume one more character */
                updateColumnWhenBlank(c);
                deferBlank(c);
            }
            endOfBlanks();
            while (isBlankCharacter(c)) { /* consume overflowed blanks */
                c = getchar();
                updateColumnWhenBlank(c);
            }
            state = OUT;         /* update state */
        } else if (c == '\n') {
            flushAndContinueInNext();
        } else {                   /* input character is non-blank character */
            updateColumnWhenWord(c);
            flushWordIfAny();
            initializeWord();
            deferWord(c);
            while (isWordCharacter(c = getchar()) && ncolumn < FOLD) {
                updateColumnWhenWord(c);
                deferWord(c);
            }
            endOfWord();
            state = IN;             /* update state */
        }
    }
    flushAll();
    printf("\nThe current column line number is %d", ncolumn);
    return 0;
}
#+END_SRC

Setup test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_22_complete.c -o current
#+END_SRC

#+RESULTS:
Test:
#+BEGIN_SRC sh :exports both :results verbatim
printf "This line is really long enough                to overflow the fold limit!!" | ./C_codes/current
#+END_SRC

#+RESULTS:
: This line is really
: long enough
: to overflow the fold
: limit!!
: The current column line number is 7

The above test case was just general case, case 4 and 5, let's try other cases we specified
above:
First, the case 2:
#+BEGIN_SRC sh :exports both :results verbatim
printf "current should	be" | ./C_codes/current
#+END_SRC
#+RESULTS:
: current should	be
: The current column line number is 18

Works as expected.

Now case 3:
#+BEGIN_SRC sh :exports both :results verbatim
printf "         	           this line replaced" | ./C_codes/current
#+END_SRC

#+RESULTS:
: this line replaced
: The current column line number is 18

If the line is all blanks and has no word it should be what?

#+BEGIN_SRC sh :exports both :results verbatim
printf "                          " | ./C_codes/current
#+END_SRC

#+RESULTS:
:                         "
: The current column line number is 26

The above one is not what we expected ever. Why such abnormal result happend? If
we reason through carefully, we came to realize it is due to the overflow of our
=blanks= character array -- its length limited to =FOLD= but this one obviously
overflowed that. As we did in =word= case, we should handle the overflow case
explicitly.

But the behavior that we wanted in this case implies that we have to dynamically
expand the =blanks= to cope with just that case; this can be achieved using the
same strategy with =printOverflowed=; but since this involve dramatic changes in
current code -- we can't use external variables any more since =blanks= should
grow dynamically, so external declarations can not cope with that -- so for now
let us just make informal contraction that blank line ends with end of file
character should not overflow the given fold point.

However, we should handle the overflow case explicitly as noted but in different
perspective. That is, the current version modifies invalid memory -- the
overflowed index -- which can cause unexpected result. I've reflected those
changes in above code (for whom having curiosity about that change, see the git
diff for that). Now the above test case return only 20 blanks no more unexpected one.

Now here is the final state diagram we have implemented:
#+BEGIN_SRC dot :exports results :file C_codes/ex1_22_final.png
digraph G {
    rankdir = LR;
    label = "for input character is not end of file"
    color = black
    subgraph cluster1 {
        style = filled
        color = lightgrey
        node [style=filled, color = white]
        node [shape = circle, label="IN"] in
        node [shape = circle, label="OUT"] out
        in -> out [label = "/handover the current deferred non-blanks to next line processor\ndestroy all the deferred blanks"]
        in -> in [label = "has not flushed\n/flush word in current line\nsiganl this line folded\ncontinue in next line"]
        out -> in [label = "/destory all the defered blanks\ncontinue in next line"]
        label = "for column line number >= n"
    }
    subgraph cluster0 {
        color = white
        node [shape = doublecircle, label="newline"] newline
        node [shape = circle, label="IN"] IN
        node [shape = circle, label="OUT"] OUT
        IN -> OUT [label = "consume blank character\n/flush blanks"]
        OUT -> IN [label = "consume word character\n/flush word"]
        IN -> in [label = "column number >= n\n/hand over the control"]
        OUT -> out [label = "column number >= n\n/consume all the consecutive blanks -- do not defer"]
        {IN, OUT} -> newline [label = "/flush all deferred string;setup next line"]
        label = "for column line number < n"
    }
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_22_final.png]]

#+BEGIN_SRC sh :exports both :results verbatim
printf "                          " | ./C_codes/current
#+END_SRC

#+RESULTS:
:
: The current column line number is 26

Let us continue the rest of cases. The last case -- case 1:
#+BEGIN_SRC sh :exports both :results verbatim
printf "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" | ./C_codes/current
#+END_SRC

#+RESULTS:
: aaaaaaaaaaaaaaaaaaaa-
: aaaaaaaaaaaaaaaaaaaa-
: aaaaaa
: The current column line number is 6

Actually our original implementation couldn't cope with this case; from this
test case, we realized that the =blanks= and =word= string should have length
=FOLD + 1= not exactly =FOLD= to afford the end of string character.
***** Exercise 1-23
#+BEGIN_SRC C
printf("This is test for the response of C compiler about the ill-typed comment syntax");
/* like this
#+END_SRC

So it consume all the subsequent characters after opening comment syntax; all we
need to do is just discard all the subsequent input characters until the closing
comment syntax is matched -- =*/=. This is way more simpler task than the one
just before it.

In state diagram, we can draw what we should implement as follows:
#+BEGIN_SRC dot :file C_codes/ex1_23.png :exports results
digraph G {
    rankdir = LR;
    node [shape = doublecircle] "normal" "in comment";
    node [shape = circle];
    "normal" -> "normal" [label = "copy to output\nother than / character"]
    "normal" -> "/" [label = "consume /"]
    "/" -> "normal" [label = "barfage / and copy to output\nother than * character"]
    "/" -> "in comment" [label = "consume *"]
    "in comment" -> "in comment" [label = "consume other than * character"]
    "in comment" -> "*" [label = "consume *"]
    "*" -> "in comment" [label = "consume other than / character"]
    "*" -> "normal" [label = "consume /"]
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_23.png]]

Let's coding according to this diagram:
#+BEGIN_SRC C :main no :tangle C_codes/ex1_23.c
#include <stdio.h>
#define NORMAL 0
#define SLASH 1
#define INCOMMENT 2
#define ASTERISK 3

int main() {
    int c;
    int state = NORMAL;
    while ((c = getchar()) != EOF) {
        if (state == NORMAL) {
            if (c == '/')
                state = SLASH;
            else putchar(c);    /* copy the input to output */
        }
        else if (state == SLASH) {
            if (c == '*')
                state = INCOMMENT;
            else {
                putchar('/');   /* barfage / */
                putchar(c);     /* copy the input to output */
                state = NORMAL;
            }
        }
        else if (state == INCOMMENT) {
            if (c == '*')
                state = ASTERISK;
        }
        else if (state == ASTERISK) {
            if (c == '/')
                state = NORMAL;
            else state = INCOMMENT;

        }
        else {
            printf("Unknown state %d -- REMOVE_COMMENT", state);
            return 1;           /* error */
        }
    }
    return 0;
}
#+END_SRC

Now let's test! Setup the test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_23.c -o remove_comment
#+END_SRC

#+RESULTS:

Let feed the source file into the resulting program:
#+BEGIN_SRC sh :exports both :results verbatim
cat C_codes/ex1_23.c | ./C_codes/remove_comment
#+END_SRC

#+RESULTS:
#+begin_example
#include <stdio.h>
#define NORMAL 0
#define SLASH 1
#define INCOMMENT 2
#define ASTERISK 3

int main() {
    int c;
    int state = NORMAL;
    while ((c = getchar()) != EOF) {
        if (state == NORMAL) {
            if (c == '/')
                state = SLASH;
            else putchar(c);
        }
        else if (state == SLASH) {
            if (c == '*')
                state = INCOMMENT;
            else {
                putchar('/');
                putchar(c);
                state = NORMAL;
            }
        }
        else if (state == INCOMMENT) {
            if (c == '*')
                state = ASTERISK;
        }
        else if (state == ASTERISK) {
            if (c == '/')
                state = NORMAL;
            else state = INCOMMENT;

        }
        else {
            printf("Unknown state %d -- REMOVE_COMMENT", state);
            return 1;
        }
    }
    return 0;
}
#+end_example

Works as expected.
***** Exercise 1-24
We can classify what we should handle into three parts:
- Syntax that can nest:
  1. parenthesis;
  2. brackets;
  3. braces;
- Syntax that can not nest:
  1. single quotes;
  2. double quotes;
  3. comments;
- Syntax should be treated specially:
  - escape sequences.


Let's think about the behavior our program should have: The specifications we
should implement.

For the syntax that can nest, we want to think as

| Okay case | Ill-defined syntax |
| =[{()}]=  | =[{]}=             |

This example implies that we need to use /stack/ to hold these nested
expressions to check their possible syntax errors.

Stack is the dynamically evolving data structure. However, the only data
structure we have, which contains other expressions in it, is array and that
should be allocated when it is defined in source code, which in turn compiled
and then would be executed; once it defined the array object can not be altered
in their length, so it does not have dynamic process in itself.

To handle this unfortunate, we should notice that this situation is somewhat
familiar; this is exactly same problem we encountered [[*Exercise 1-16][Exercise 1-16]]; but we are
better than then -- now we can use the external variables to wire the
subroutines. Using this combination, we can achevie what we wanted rather
straightforward manner.

As usual, we first figure out what state diagram we want to achieve given task.
For now, we are going to assume that we have stack object to store the nested
bracket things. Then our state specification got simplified: All we need to
keep track of is current state -- in parenthesis or bracket or brace or single
quote or double quote or comment or escape sequences.

The only difference between the expression that can nest or not is that the
nestable expression is current state and another opening syntax consumed, the
current state should be the one encountered syntax and the previous expression
should be stored in stack on the top; on the other hand, if the expression can
not be nested is current state, then the subsequent expression other than
closing expression of the current syntax state are just consumed or, in other
word, ignored.

For the matching the paired syntax is same in both; if stack is not empty after
matching the paired syntax, set the current state to be the one popped from the
stack; if it is empty set the state same as start.

For the special syntax -- escape sequence -- we assume that escape sequence
should consist of two character, backslash to start the sequence and the
following whatever character; this is the only case we have encountered so far.
And we should ensure the escape sequence only occurs in quoted syntax (and in
comment since the inner character in comments are stripped when it handed to
compiler).

Also note that we can include single quotes in double quote syntax but the
opposed case works in unexpected as explained as follows.

#+BEGIN_SRC C :exports both
printf("'hi'");               /* \n */
#+END_SRC

#+RESULTS:
: 'hi'

#+BEGIN_SRC C :exports both
printf("%c", '"hello"');
#+END_SRC

#+RESULTS:

Or if we include more than one characters in between single quotes, we got

#+BEGIN_SRC C :exports both :results verbatim
printf("%c", 'hello');
#+END_SRC

#+RESULTS:
: o

only the last character as value.

Now we ready to draw the state diagram:
#+BEGIN_SRC dot :file C_codes/ex1_24.png :exports results
digraph G {
    rankdir = LR
    label = "While the character is not end of file"
    node[shape = circle]
    start -> nestable [label = "consume opening nestable character"]
    start -> quoted [label = "consume opening quote character"]
    start -> comment [label = "consume opening comment syntax sequence"]
    comment -> start [label = "consume closing comment syntax sequence;\nstack is empty"]
    comment -> nestable [label = "consume closing comment syntax sequence;\nstack is not empty"]
    comment -> comment [label = "consume other than\nclosing comment \nsyntax sequence"]
    start -> start [label = "consume other than special character"]
    quoted -> nestable [label = "consume matched \nquote character;\nstack is not empty"]
    quoted -> quoted [label = "consume other than matched quote character and backslash"]
    quoted -> escape [label = "consume backslash"]
    escape -> quoted [label = "consume one character;\nback to the previous quoted state"]
    quoted -> start [label = "consume matched quote character; stack is empty"]
    nestable -> nestable [label = "consume matched nestable character; stack is not empty"]
    nestable -> start [label = "consume matched character;\nstack is empty"]
    nestable -> nestable [label = "consume another opening nestable character / push current state into the stack"]
    nestable -> nestable [label = "consume normal character -- nor quote, nestable, backslash, comment"]
    nestable -> comment [label = "consume opening comment character"]
    nestable -> quoted [label = "consume opening quoted character"]
}
#+END_SRC

#+RESULTS:
[[file:C_codes/ex1_24.png]]

And here is the skeleton of code:
#+BEGIN_SRC C :main no
#include <stdio.h>

int main() {
    int c = getchar();
    int state;
    while (c != EOF) {
        if (state == START) {
            if (isOpeningQuote(c) || isOpeningNestable(c) || isTransientOpeningComment(c))
                state = c;

            else if (isOpeningEscape(c)){
                return error(c);
            }
            c = getchar();
        }
        else if (isTransientOpeningComment(state)) { /* no consumption of character just set the state */
            if (c == '*')
                state = INCOMMENT;
            else {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
        }
        else if (isTransientClosingComment(state)) { /* same as above since these are transient state */
            if (c == '/') {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
            else
                state = INCOMMENT;
        }
        else if (state == INCOMMENT) {
            if (isTransientClosingComment(c))
                state = c;
            c = getchar();
        }
        else if (isOpeningNestable(state)) {
            if (isOpeningNestable(c) || isOpeningQuote(c) || isTransientOpeningComment(c)) {
                push(state);    /* Push current state to stack */
                state = c;      /* update current */
            }
            else if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c) || isClosingNestable(c)) {
                return error(c);
            }
            c = getchar();
        }
        else if (isOpeningQuote(state)) {
            if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c)) {
                if ((c = getchar()) == EOF) {
                    return error(c);
                }
            }
            c = getchar();
        }
        else                    /* defensive programming */
            return error(c);
    }
    return 0;
}
#+END_SRC

We have to implement each operations we have assumed in above skeleton code.
Except the stack operations, the implementation would be straightforward. For
the test what we've implemented so far, let us replace the stack with static
array -- stack with maximum depth.

#+BEGIN_SRC C :main no :tangle C_codes/ex1_24.c
#include <stdio.h>

#define START 0
#define INCOMMENT 1
#define MAXIMUMDEPTH 1000

/* external varaible -- static stack */
char stack[MAXIMUMDEPTH];
int sp = 0;                     /* current stack point */

int isEmptyStack(void) {
    return sp == 0;
}

char pop(void) {
    --sp;
    return stack[sp];
}

void push(char c) {
    stack[sp] = c;
    ++sp;
}

int error(char c) {
    printf("Unexpected character %c encountered", c);
    return 0;
}

int isOpeningQuote(char c) {
    return c == '\'' || c == '"';
}

int isOpeningNestable(char c) {
    return c == '{' || c == '[' || c == '(';
}

int isClosingNestable(char c) {
    return c == '}' || c == ']' || c == ')';
}

int isTransientOpeningComment(char c) {
    return c == '/';
}

int isOpeningEscape(char c) {
    return c == '\\';
}

int isTransientClosingComment(char c) {
    return c == '*';
}

int isMatched(char o, char c) {
    if (o == '{')
        return c == '}';
    else if (o == '(')
        return c == ')';
    else if (o == '[')
        return c == ']';
    else if (isOpeningQuote(o))
        return c == o;
    else
        return 0;
}

int main() {
    int c = getchar();
    int state = START;
    while (c != EOF) {
        if (state == START) {
            if (isOpeningQuote(c) || isOpeningNestable(c) || isTransientOpeningComment(c))
                state = c;

            else if (isOpeningEscape(c)){
                return error(c);
            }
            c = getchar();
        }
        else if (isTransientOpeningComment(state)) { /* no consumption of character just set the state */
            if (c == '*')
                state = INCOMMENT;
            else {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
        }
        else if (isTransientClosingComment(state)) { /* same as above since these are transient state */
            if (c == '/') {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop();
            }
            else
                state = INCOMMENT;
        }
        else if (state == INCOMMENT) {
            if (isTransientClosingComment(c))
                state = c;
            c = getchar();
        }
        else if (isOpeningNestable(state)) {
            if (isOpeningNestable(c) || isOpeningQuote(c) || isTransientOpeningComment(c)) {
                push(state);    /* Push current state to stack */
                state = c;      /* update current */
            }
            else if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c) || isClosingNestable(c)) {
                return error(c);
            }
            c = getchar();
        }
        else if (isOpeningQuote(state)) {
            if (isMatched(state, c)) {
                if (isEmptyStack())
                    state = START;
                else
                    state = pop(); /* Pop from current stack if not empty */
            }
            else if (isOpeningEscape(c)) {
                if ((c = getchar()) == EOF) {
                    return error(c);
                }
            }
            c = getchar();
        }
        else                    /* defensive programming */
            return error(c);
    }
    if (!isEmptyStack()) {
        stack[sp + 1] = '\0';       /* for printing */
        printf("The stacked nestables are unmatched %s", stack);
    }
    return 0;
}
#+END_SRC

Then let's test!

Setup the test:
#+BEGIN_SRC sh
cd C_codes
cc ex1_24.c -o current
#+END_SRC

#+RESULTS:

Then test:
#+BEGIN_SRC sh :exports both
cat C_codes/ex1_24.c | ./C_codes/current
#+END_SRC

#+RESULTS:

Unexpected closing syntax case:
#+BEGIN_SRC sh :exports both
printf "{[}]" | ./C_codes/current
#+END_SRC

#+RESULTS:
: Unexpected character } encountered

General case (well typed syntax):
#+BEGIN_SRC sh :exports both
printf "{([({\'\\x\'})])}" | ./C_codes/current
#+END_SRC

#+RESULTS:

Unmatched quoted syntax case:
#+BEGIN_SRC sh :exports both
printf "{([({\'\\x})])}" | ./C_codes/current
#+END_SRC

#+RESULTS:
: The stacked nestables are unmatched {([({

Unconsumed nested syntax case:
#+BEGIN_SRC sh :exports both
printf "{([({\'\\x\'})]" | ./C_codes/current
#+END_SRC

#+RESULTS:
: The stacked nestables are unmatched {(

#+BEGIN_SRC sh :exports both
printf "{([({\'\\x\'/*})]*/})])}" | ./C_codes/current
#+END_SRC

#+RESULTS:

Now we think of the dynamic stack implementation. This is almost same as
[[*Exercise
1-16][Exercise 1-16]]; this implementation is dirty as those. We should destroy all the
modular function code. I don't want to get bogged down with the gory details to
do that; it is not worth to do. However it is worth to notice that we can
implement the behavior of dynamic stack even with current toolkit although it is
very dirty to read and all the guts of stack leaks out and spoils all other
almost irrelevant code.
** Chapter 2: Types, Operators, and Expressions
:PROPERTIES:
:NOTER_PAGE: 35
:END:
*** Variable Names
*** Data Types and Sizes
**** Exercise 2-1
:PROPERTIES:
:NOTER_PAGE: 36
:END:
First, let's use the standard headers =<limits.h>= and =<float.h>= to find out
the ranges. If we reference the Appendix B to find out those, we came to code as
follows.
#+BEGIN_SRC C :includes <limits.h> <float.h> :results verbatim :exports both
printf("The char type's bits is %d\n", CHAR_BIT);
printf("The char type's minimum value is %d\n", CHAR_MIN);
printf("The char type's maximum value is %d\n", CHAR_MAX);
printf("So the unsigned maximum value of char type is %d\n", UCHAR_MAX);
printf("And the unsigned minimum value of char type is %d\n", 0);

printf("\nThe int type's minimum value is %d\n", INT_MIN);
printf("The int type's maximum value is %d\n", INT_MAX);
printf("So the unsigned maximum value of int type is %ld\n", UINT_MAX);

printf("\nThe short type's minimum value is %d\n", SHRT_MIN);
printf("The short type's maximum value is %d\n", SHRT_MAX);
printf("So the unsigned maximum value of short type is %u\n", USHRT_MAX);

printf("\nThe long type's minimum value is %ld\n", LONG_MIN);
printf("The long type's maximum value is %ld\n", LONG_MAX);
printf("So the unsigned maximum value of long type is %lu\n", ULONG_MAX);

printf("\nThe radix of exponent is %d\n", FLT_RADIX);

printf("\nThe float type's minimum value is %le\n", FLT_MIN);
printf("The float type's maximum value is %le\n", FLT_MAX);
printf("The float type's decimal digits of precision is %d\n", FLT_DIG);
printf("The float type's smallest number to determine whether two number is same is %le\n", FLT_EPSILON);

printf("\nThe double type's minimum value is %le\n", DBL_MIN);
printf("The double type's maximum value is %le\n", DBL_MAX);
printf("The double type's decimal digits of precision is %d\n", DBL_DIG);
printf("The double type's smallest number to determine whether two number is same is %le\n", DBL_EPSILON);
#+END_SRC

#+RESULTS:
#+begin_example
The char type's bits is 8
The char type's minimum value is -128
The char type's maximum value is 127
So the unsigned maximum value of char type is 255
And the unsigned minimum value of char type is 0

The int type's minimum value is -2147483648
The int type's maximum value is 2147483647
So the unsigned maximum value of int type is 4294967295

The short type's minimum value is -32768
The short type's maximum value is 32767
So the unsigned maximum value of short type is 65535

The long type's minimum value is -9223372036854775808
The long type's maximum value is 9223372036854775807
So the unsigned maximum value of long type is 18446744073709551615

The radix of exponent is 2

The float type's minimum value is 1.175494e-38
The float type's maximum value is 3.402823e+38
The float type's decimal digits of precision is 6
The float type's smallest number to determine whether two number is same is 1.192093e-07

The double type's minimum value is 2.225074e-308
The double type's maximum value is 1.797693e+308
The double type's decimal digits of precision is 15
The double type's smallest number to determine whether two number is same is 2.220446e-16
#+end_example

The process via the direct computation, we need to figure out the method to
detect overflow; by assuming that method at our disposal, we can detect allowed
maximum and minimum number of given type only using arithmetic operations.

As we know every data in computer should be represented as bits, in principle,
we can compare the order of any two data if they are in same type. And our
language has no run-time support for overflow, we can assume (or experiment) it
would be wrapped around the limitation, that is, just to ignore the overflowed bit.

Using this observation, we can detect the limitation of number not to be
overflow; this threadhold number is the maximum number in that type.

It's enough word to describe in abstract manner. Now let's turn to concrete code:
#+BEGIN_SRC C :results verbatim :exports both
char c;
char o;
o = 0;
c = 1;
while (o < c)
    o = c++;
printf("The char type's maximum value is %d\n", o);
printf("And the overflowed number got wrapped as %d\n", c);

printf("\nActually this wrapped number is the minimum number of type char. We can show this by\n...");

o = 1;
c = 0;
while (o > c)
    o = c--;
printf("\nThe char type's minimum value is %d\n", o);
printf("And the underflowed number got wrapped as %d\n", c);
#+END_SRC

#+RESULTS:
: The char type's maximum value is 127
: And the overflowed number got wrapped as -128
:
: Actually this wrapped number is the minimum number of type char. We can show this by
: ...
: The char type's minimum value is -128
: And the underflowed number got wrapped as 127

Using this process, we can get those of =int= type:
#+BEGIN_SRC C :results verbatim :exports both
int c;
int o;
o = 0;
c = 1;
while (o < c)
    o = c++;
printf("The int type's maximum value is %d\n", o);
printf("And the overflowed number got wrapped as %d\n", c);

printf("\nActually this wrapped number is the minimum number of type int. We can show this by\n...");

o = 1;
c = 0;
while (o > c)
    o = c--;
printf("\nThe int type's minimum value is %d\n", o);
printf("And the underflowed number got wrapped as %d\n", c);
#+END_SRC

#+RESULTS:
: The int type's maximum value is 2147483647
: And the overflowed number got wrapped as -2147483648
:
: Actually this wrapped number is the minimum number of type int. We can show this by
: ...
: The int type's minimum value is -2147483648
: And the underflowed number got wrapped as 2147483647

We can apply exactly same idea into all of non-floating-point types.

For the floating-point types, we should use multiplication rather than addition
since floating-point numbers has exponent part in it; and this exponent part
mainly determines the range of that type:

#+BEGIN_SRC C :results verbatim :exports both
float c;
float o;
o = 1.0;
c = 10.0;
while (o < c) {
    o = c;
    c = 10.0 * c;
}

printf("The float type's maximum value is %le\n", o);
printf("And the overflowed number got wrapped as %le\n", c);

printf("\nActually this wrapped number is the minimum number of type float. We can show this by\n...");

o = 10.0;
c = 1.0;
while (o > c) {
    o = c;
    c = c / 10.0;
}
printf("\nThe float type's minimum value is %le\n", o);
printf("And the underflowed number got wrapped as %le\n", c);
#+END_SRC

#+RESULTS:
: The float type's maximum value is inf
: And the overflowed number got wrapped as inf
:
: Actually this wrapped number is the minimum number of type float. We can show this by
: ...
: The float type's minimum value is 0.000000e+00
: And the underflowed number got wrapped as 0.000000e+00

Oops.. Turns out it doesn't works as expected; I could not come up with the good
way to detect the overflow of floating-point type as it has =inf= notation for
that.
